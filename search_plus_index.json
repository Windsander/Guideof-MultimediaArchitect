{"./":{"url":"./","title":"《音视频开发技术：原理与实践》©","keywords":"","body":"《音视频开发技术：原理与实践》© =[>> 关于作者© =[>> 赞助本作© =[>> 版权申明© 目标 对于音视频工程师/架构师来说，日常工作长中总会有大量的知识技术积累，亟待梳理以期望能够被快速检索查阅。但由于工程技术所处领域的复合特征，往往针对一个工程问题所需要的专业知识，不论深浅程度，都会横跨几门学科。而想要获取有效的处理问题所能使用的信息，都需要依次回顾、搜集和关联。这样必不可少会花费大量时间查阅各类大部头资料和文献。而这么做往往是因为，对于待解答问题非常重要的知识点，分布碎片化导致的。 音视频规格的跨度构成了本身技术的多个维度，使得我们并不能按照以往的工程思维，从单一角度来考虑涉及此类型的复合问题。 因此，本书的目的旨在以工程解决方案的实践思路过程，对相关联的各学科核心知识进行串联。以求用一套完整且关联的技术栈模板，来贯穿当下多媒体技术的所有核心技术模块。从而 为读者提供针对多媒体（音视频）分析/处理/整合/架构方面，有效技术指导与学习路线。 特色 本书结合作者工作实践，对架构师日常工作工程中涉及使用到的：数字信号处理、计算机图形学、色彩学、相关工程规格规范、驱动特征及软件框架设计等，领域的专业学科知识进行了梳理和提炼。从音视频工程师不同的技术阶段需要面临的问题为出发点，将 全书分为，音视频基础与音视分析、流媒体规格与简易编解码播放框架设计、通用统一化音视频编辑框架与渲染驱动设计，三大阶段。每一阶段，统一采用知识图谱串联工程规格与编码实践，全面讲解对应技术阶段下需要掌握的，多媒体（音视频）技术之简史、原理、算法、设计及相关推导、制定、架构与应用。 基于此，全书按照技术逐级递进的关系，构成了整体音视频从数据分析、编解码器开发、播放器开发到图形化与图像处理、特效与特效引擎的 完整技术栈。使得全书每个章节内部自成一体但确相互关联，从而便于做技术字典、工程手册和整体学习之用。 面向 书中原理与技术面向全平台，因此主要开发语言为 C/C++。部分平台化及数据分析场景，会一定程度的应用到 C#、Java、Python 等其他语言。本书适合： 初入音视频开发的新手： 本书为您提供了完整学习路径，对于打算初入本行业的开发者，本书能够帮您梳理完整的音视频开发技术路线。协助您成功入行。 有基础的音视频工程师： 本书为您提供了知识技术字典，对于日常开发工作中涉及到的相关问题分析，本书能够帮您快速定位到所需要的核心知识点，进而方便您进一步根据所给信息来做出判断，或根据提示方向来进行深度资料查阅。 多媒体编解开发者友好： 本书为您提供了ITU-T的编解码协议技术索引和讲解，您可以快速通过本书查阅常用 H.264、H.265、H.266 的关键资料和技术对比。 流媒体协议开发者友好： 本书为您提供了常用流协议的拆分解析，您可以快速通过本书查阅常用 RTP/RTCP、RTMP、HLS 的规格设定和消息类型。 学研成果转向生产部署： 本书为您提供了理论转实践的事例方案，对于将研究成果转换到实际工业生产活动的老师，本书能够为您介绍一些现已有成功实践的多媒体方面学转产探索。协助您梳理思路。 硬核的多媒体技术大咖： 若您是深耕此领域多年的老师，您不妨将本书当作一次有趣的思维之旅，从不同的视角感受音视频工程魅力，希望本书能为您提供一些帮助。当然，也更希望获得您的交流。 为方便您定位章节难度，此处提供 =[>> 难度向导 建议。 受限于作者，本书难免存在一些不足，您可以 Book-issues 进行反馈，感谢您的帮助！ 目录 音视频工程基础 一、数字音频的保存与还原 1.1 音频基础 1.2 音频三要素（Three Elements of Audio） 1.2.1 幅度 & 响度（Volume） 1.2.2 频率 & 音调（Pitch） 1.2.3 波形 & 音色（Timbre） 1.3 音频的解构 1.3.1 时域图（Time Domain Graph） & 频域图（Frequency Domain Graph） 1.3.2 频谱图（Spectrogram） 1.3.3 主观调性（Tone）& 调性网络（Tonnetz） 1.4 音频的采样与调制 1.4.1 数字信号（Digital Signal）& 模拟信号（Analog Signal） 1.4.3 采样率（Sample Rate） & 采样位深（Bit Depth） & 采样声道（Channel） 1.4.2 脉冲编码调制（PCM [Pulse-Code Modulation]） 1.4.3 脉冲密度调制（PDM [Pulse-Density Modulation]） 1.5 音频的存储 1.5.1 音频格式（Audio Format） 1.5.2 无压缩编码格式（Uncompressed Encode） 1.5.3 无损压缩编码格式（Lossless Encode） 1.5.4 有损压缩编码格式（Uncompressed Encode） 二、色彩的运用与存储 2.1 色彩基础 2.2 颜色三要素（Three Elements of Color） 2.2.1 色调（Hue） 2.2.2 饱和度（Saturation） 2.2.3 光亮度（Luminance） 2.3 色彩的衡量 2.3.1 辐射亮度（Radiance）& 色温（Color Temperature）& 颜色的量化 2.3.2 配色函数（Color Matching Functions）& 色彩空间（Color Space） 2.3.3 经典三原色函数（Trichromatic Primaries Functions） 2.3.4 经典三刺激函数（Tristimulus Values Functions） 2.3.5 现代色彩体系（Modern Color System） 2.4 色彩的对比 2.4.1 色域（Color Gamut ） 2.4.2 色度（Chroma）& 色度平面（Chroma Plane）& 色度图（Chroma Diagram） 2.4.3 色差（Chromatic Aberration） 2.4.4 色温（Color Temperature）& 相关色温（Correlated Color Temperature） 2.4.5 标准光源（Standard Illuminants）& 白点（White Point） 2.4.6 显色指数（Color Rendering Index） 2.5 经典色彩空间（Classical Color Space） 2.5.1 光学三原色色彩空间（RGB） 2.5.2 颜料三原色色彩空间（CMY / CMYK ） 2.5.3 CIE RGB 色彩空间（CIE 1931 RGB Color Space） 2.5.4 CIE XYZ 色彩空间（CIE 1931 XYZ Color Space） 2.5.5 CIE LAB 色彩空间（CIE 1976 L*, a*, b* Color Space） 2.5.6 CIE LUV 色彩空间（CIE 1976 L*, u*, v* Color Space） 2.5.7 颜色三要素色彩空间（HSV / HSI / HSL） 2.6 色彩的存储 2.6.1 色彩格式（Color Format）与色彩存储 2.6.2 RGB 体系色彩格式 2.6.3 YUV 体系色彩格式 【参考文献】 三、音视频常用基础算法 3.1 信号分析的核心算法 - 傅立叶变换 3.1.1 一维傅立叶（1D-FT）与一维离散傅立叶变换（1D-DFT） 3.1.2 二维傅立叶（2D-FT）与二维离散傅立叶变换（2D-DFT） 3.1.3 傅立叶变化的经典 - 快速傅立叶变换（FFT） 3.1.4 傅里叶的硬件优化 - 多常数乘法矩阵逼近（Matrix-MCM Approach） 3.2 频率信息提取 - 常用滤波算法 3.2.1 高斯滤波（Gauss Filter） 3.2.2 双边滤波（Bilateral Filter） 3.2.3 拉普拉斯滤波（Laplacian Filter） 3.2.4 马尔滤波（Marr Filter） 3.2.5 索贝尔滤波（Sobel Filter） 3.2.6 各向异性扩散（Anisotropic Diffusion） 3.3 时间冗余控制 - 常用特征提取与朴素阈值处理 3.3.1 方向梯度直方图（HOG [Histogram of Oriented Gradient]） 3.3.2 朴素目标检测结果度量 - IoU & GIoU 3.3.3 朴素目标检测物体锁定 - 分步滑动窗口（Simple Sliding Window） 3.4 空域冗余控制 - 基础光流算法与色度压缩 3.4.1 传统光流法（Classic Optical Flow Methods） 3.4.2 双向光流预测（BDOF [Bi-Directional Optical Flow]） 3.4.3 光流仿射修正（PROF [Affine Prediction Refinement With Optical Flow]） 3.4.4 色度缩放亮度映射（LMCS [Luma Mapping with Chroma Scaling]） 3.5 频域冗余控制 - 基础变换编码 3.5.1 整数离散正余弦变换（DST/DCT） 3.5.2 哈达玛变换（WHT [Walsh-Hadamard Transform]） 3.5.3 低频不可分变换（LFNST [Low-Frequency Non-Separable Transform]） 【参考文献】 四、音视频机器学习基础 4.1 发展概览 4.2 模型结构速览 4.2.1 算子（Operator）& 层（Layer） 4.2.2 经典模型：MLP 4.2.3 经典模型：CNN & RNN 4.2.4 经典模型：Transformer 4.3 经典激活函数（Classic Activation Function） 4.3.1 Sigmoid 4.3.2 Tanh 4.3.3 Softplus 4.3.4 ReLU 族 4.3.5 ELU & SELU 4.3.6 Mish 4.3.7 Swish & h-Swish 4.4 连接函数/衰减函数（Connection/Attenuation Function） 4.4.1 Dropout 4.4.2 Maxout 4.4.3 SoftMax 4.5 损失函数（Loss Function） 4.5.1 损失函数的组成 4.5.2 回归项-平均绝对误差（MAE [Mean Absolute Error]） 4.5.3 回归项-均方误差（MSE [Mean Squared Error]） 4.5.4 回归项-休伯损失（Huber Loss） 4.5.5 回归项-分位数损失（Quantile Loss） 4.5.6 分类项-对数损失（Log Loss） 4.5.7 分类项-交叉熵损失（Cross Entropy Loss） 4.5.8 分类项-合页损失（Hinge Loss） 4.5.9 分类项-对比损失（Contrastive Loss） 4.5.10 分类项-三元损失（Triplet Loss） 4.5.11 分类项-对组排异损失（N-Pair Loss） 4.5.12 正则项-L1 惩罚 4.5.13 正则项-L2 惩罚 4.5.14 正则项-Dropout 4.6 常用最优化算法（Optimizer Operator） 4.6.1 基础优化算法 4.6.2 优化算法的优化-应对震荡 4.6.3 优化算法的优化-应对重点强（弱）化更新 4.6.4 自适应实时评估算法（Adam [Adaptive Moment Estimation]） 【参考文献】 五、音视频的单帧与帧分析 5.1 单帧的概念 5.1.1 音频帧（Chunk）& 视频帧（Frame） 5.1.2 时间戳（Timestamp） 5.1 常用分析工具介绍 5.1.1 视频分析 StreamEye & YUV-Viewer 5.1.2 音频分析 Audacity & Sonic Visualizer 5.2 常用分析 Python 库介绍 5.2.1 常用 Python 数学库（Numpy、Pandas、Mateplotlib） 5.2.2 视频分析库 ffmpeg-py、color-science 5.2.3 音频分析库 librosa 5.3 通过 Python 的手写程序片处理 5.3.1 搭建基本分析环境 5.3.2 分析一段音频 5.3.3 分析一段视频 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。 This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:15 "},"AUTHOR.html":{"url":"AUTHOR.html","title":" =[>> 关于作者© <<]= ","keywords":"","body":"关于作者 本书由 李述博©（Arikan.Li©）独立完成 李述博（Arikan.Li）👇（This guy!）👇 CV工程师 & 架构师 & Baker 借用名言（ 0_0）： “名字仅是代号，知识才是真理。” 编写有感（ )_T）： 写作难度较大，各种资料查阅、相关知识点梳理以及辅助Demo和配套项目开发，带来了极大的压力。因此，您的您宝贵支持与意见，将是作者的重要的力量之源。 如何联系（ -w-）： 您可以通过 知乎 或 Github 联系到作者，感谢您的帮助。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:10 "},"COPYRIGHT.html":{"url":"COPYRIGHT.html","title":" =[>> 版权申明© <<]= ","keywords":"","body":"版权申明© 本书由 李述博©（Arikan.Li©）独立完成 本人的所有作品，包括但不限于文字，图片等内容受《著作权》法的保护，凡未经权利人明确书面授权，转载上述内容，本人有权追究侵权行为。　　 本人关于图片作品版权的声明： 　　 本人在此刊载的原创作品，其版权归属本人所有。 　 任何传统媒体、商业公司或其他网站未经本人的授权许可，不得擅自从本人转载、转贴或者以任何其他方式复制、使用上述作品。 　 传统媒体、商业公司或其他网站对上述作品的任何使用，均须事先与本人联系。 　 对于侵犯本人的合法权益的公司、媒体、网站和人员，本人聘请的律师受本人的委托，将采取必要的措施，通过包括法律诉讼在内的途径来维护本人的合法权益。 特此声明，敬请合作。 通常情况下，允许 个人及非商业使用转载，但是请标注 作者和链接 。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。 This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:10 "},"GUIDER.html":{"url":"GUIDER.html","title":" =[>> 难度向导© <<]= ","keywords":"","body":"难度向导 阶段：音视频基础与音视分析 核心：入门必需掌握的音视频基础 入门的四章也是概念与基础理论最多的章节了。这几张的工程实践较少，但非常重要的原理、规格、定义及多。是后续更为复杂的工程实践中，被音视频工程师们做为根基般的存在。因此非常重要。 第一章 数字音频的保存与还原，本章从声学和心理声学角度对音频的相关工程量，以及数模转换和分析对比的关键概念进行了阐述。结合发展与规格演进，提供整体音频工程概念的梳理。 第二章 图像色彩的运用与存储，从色彩学发展史到工业体系对色彩的规格定义，章节大章以工程概念的递进关系进行介绍，并在小章节中按照相关规格原理的发现提出时间顺序进行了由浅入深的推导说明。从而保证前后逻辑和发展上的连贯性。 第三章 音视频常用基础算法，属于纯数理基础，对音视频开发过程中常用的 图像/音频 的 分析/处理 算法，进行了梳理和讲解；本章列出的部分，是作者在筛选掉大量非必需算法后的最小知识集合。 第四章 音视频的单帧与帧分析，是一个纯工程章节。这一章将对前三章里的知识点，在工程应用上，通过代码和实际操作来进行一次总结。 入门四章完成后，读者将有一定的音视频图像工程分析能力。并能够使用当前掌握的知识来处理音视频基本问题。 阶段：流媒体规格与简易编解码播放框架设计 核心：流的编解码与网络传输，音视频工程常用框架与技术 第五章 音视频解码与流传输，是一个综合性较强的章节。这一章将对当前编解码规格进行详细的拆分与解析。通过对 H.264、H.265、H.266 的规格分析，详细的阐述当今音视频工程中，如何对视频保质保量的进行数据压缩和处理。并通过对 主流三协议：RTMP、RTP/RTCP、HLS 的分析，从协议的封装、信号设计、传输过程、规格规定上全面说明了音视频传输过程的各个方面细节。完成本章，将会使读者较为深度的理解编解码与传输，并使其能够有一定程度的规格定制与改进能力。 第六章 音视频的编解播与流分析，结合了第五章与入门四章的知识要领做工程实践。本章节将注重工程能力建设，从软件工程设计角度剖析音视频的编解播三大经典工程方案，并引导读者建立架构师思维与匹配的动手能力。 中级两章完成后，读者将能够胜任大部分业界的音视频项目工作需求，和一定程度的音视频架构师要求。 阶段：通用统一化音视频编辑框架与渲染驱动设计 核心：图像处理技术与特效引擎 第七章 图形驱动统一化的理论基础，是为后续章节开始进行的计算机图形处理，进行相关的理论基础铺垫与解析。中级/高级架构师，在工作内容上已不可避免会涉及到音视频2D、3D特效的处理与实践，并会较多的参与到 AI 技术工程化的框架设计工作中。因此，对于计算机图形学的了解是必要且必须的。 第八章 图形驱动与渲染引擎技术，则是一个较为复杂的复合章节。本章结合作者开源工程实践（UltraDriver），在前面几章铺垫的基础上，深入驱动底层逻辑，剖析了常见渲染引擎的核心元素，并完整的讲解了从GPU通信管线建立到实际场景渲染的完整过程。完成本章，将会使读者对整个渲染驱动有详尽的理解，并能够独立运用GPU驱动特性完成复杂的 3D 渲染工作。 第九章 音视频播放与特效编辑，结合作者开源工程实践（UltraTimeline），讲解了音视频编辑中的最为关键的技术系统：UTT 统一时间轴系统，通过此系统，读者将能够独立完成一系列复杂音视频的编辑过程。从而在音视频特效处理方面正式的进入工程大门。 高级三章完成后，后续的继续学习提升将脱离工程范畴。因此，更进一步的探索，就要求深入了解算法和硬件驱动，从而衔接到 AI-CV 等方面的相关研究工作，或游戏引擎物理引擎的开发架设。此两个方向的经典文献与著作较多，且已有成熟体系，因此本书既到此为止。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:15 "},"DONATE.html":{"url":"DONATE.html","title":" =[>> 赞助本作© <<]= ","keywords":"","body":"买杯咖啡 如果您愿意为本书爆肝的作者买一些精神食粮，来让他当一名 24H 狼灭的话... Buy Me Espresso 👇( ✨w✨)👇 WeChat Best Wish！💗 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:15 "},"Chapter_2/Language/cn/Apex_2_Introduce.html":{"url":"Chapter_2/Language/cn/Apex_2_Introduce.html","title":"二、色彩的运用与存储","keywords":"","body":"二、色彩的运用与存储 引言 自人类对世界有认知开始，从寄思于物的艺术创作，日常生活的打扮穿着，再到科学研究对物理规律的探索，色彩始终伴随左右。什么是色彩？色彩是如何被应用到视觉工程的？ 本章节主要整理说明了，部分关键光学与色彩学概念的应用和推导。通过对当代计算机图像有关颜色处理发展史的梳理，以期为工程上应用于单一图像处理、色彩权衡对比等工作，和理论上深入理解图像规格标准迭代及原理，提供必要知识图谱。 图像本身是颜色的载体，因此对图像的讨论，也就是对色彩（颜色）的讨论。 关键字：色彩基础、色彩空间、色彩格式、配色函数、色度、色温 目录 2.1 色彩基础 2.2 颜色三要素（Three Elements of Color） 2.2.1 色调（Hue） 2.2.2 饱和度（Saturation） 2.2.3 光亮度（Luminance） 2.3 色彩的衡量 2.3.1 辐射亮度（Radiance）& 色温（Color Temperature）& 颜色的量化 2.3.2 配色函数（Color Matching Functions）& 色彩空间（Color Space） 2.3.3 经典三原色函数（Trichromatic Primaries Functions） 2.3.4 经典三刺激函数（Tristimulus Values Functions） 2.3.5 现代色彩体系（Modern Color System） 2.4 色彩的对比 2.4.1 色域（Color Gamut ） 2.4.2 色度（Chroma）& 色度平面（Chroma Plane）& 色度图（Chroma Diagram） 2.4.3 色差（Chromatic Aberration） 2.4.4 色温（Color Temperature）& 相关色温（Correlated Color Temperature） 2.4.5 标准光源（Standard Illuminants）& 白点（White Point） 2.4.6 显色指数（Color Rendering Index） 2.5 经典色彩空间（Classical Color Space） 2.5.1 光学三原色色彩空间（RGB） 2.5.2 颜料三原色色彩空间（CMY / CMYK ） 2.5.3 CIE RGB 色彩空间（CIE 1931 RGB Color Space） 2.5.4 CIE XYZ 色彩空间（CIE 1931 XYZ Color Space） 2.5.5 CIE LAB 色彩空间（CIE 1976 L*, a*, b* Color Space） 2.5.6 CIE LUV 色彩空间（CIE 1976 L*, u*, v* Color Space） 2.5.7 颜色三要素色彩空间（HSV / HSI / HSL） 2.6 色彩的存储 2.6.1 色彩格式（Color Format）与色彩存储 2.6.2 RGB 体系色彩格式 2.6.3 YUV 体系色彩格式 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:10 "},"Chapter_2/Language/cn/Docs_2_1.html":{"url":"Chapter_2/Language/cn/Docs_2_1.html","title":"2.1 色彩基础","keywords":"","body":"2.1 色彩基础 1666年，艾萨克·牛顿（Isaac Newton，1642 - 1726） 通过光的色散实验，发现了太阳光可以分解成依次为红、橙、黄、绿、蓝、靛、紫的单色光，并可以由单色光复合而成白光 ，由此提出了 牛顿颜色原理（Newton's theory of colour） 。并于 1705 年结合他在光学领域的其他发现与猜想，编著为《光学》[1]。在此之前，亚里士多德提出的白光为一种纯粹光源才是学界共识。色散试验的伟大，在于为人们揭示了人类视觉感知色彩形式的光学物理特性。人们首次接触到了光谱（Spectrum）概念。此后，人们对光谱进行了大量基于颜色观测的研究，并逐步完成了奠基色彩学（Color Science）的理论归纳总结。 人们发现，如果我们将由红到紫的 可见光谱（380nm - 780nm） 首尾相连，那么就能够得到一个 360 度的连续可分色表。这个表被称之为色轮（Color Wheel） [2]。色轮中， 0 度表示红色，360 度表示紫色。环的圆心，即正中央则为纯白。 在此基础上，色彩学就颜色的合成，产生了三大理论：加法混合论、减法混合论、中性混合论。从物理意义上讲，加法混合论代表着自然界中自发光物体的光源色彩混合，减法混合论代表着反光物体反射光色彩混合情况，中性混合论依赖人类生理特征进行的色彩还原形式。加法混合论和减法混合论分别在光学领域和艺术领域，得到了广泛的应用。所以，加法混合论所采用的红（Red）、绿（Green）、蓝（Blue）三基色被称为光学三原色（RGB），减法混合论所采用的深红（Cyan）、青（Magenta）、黄（Yellow）三基色被称为颜料三原色（CMY）。 图 2.1-1 色轮（Color Wheel）与颜色（Vienna，1772）[2] 1802年，托马斯·杨（Thomas Young，1773 - 1829） 在对可见光谱范围内光线波长测量时，发现人眼对红绿蓝三色光波极为敏感。杨确定了人眼中存在 3 种能够感知不同波长的光感神经纤维，佐证了光学三原色的生理基础，并粗略的测定了人的三色感知范围 [3]。 1850年，赫尔曼·冯·亥姆霍兹（Hermann von Helmholtz，1821 - 1894） 在杨的研究基础上，经实验确定了杨理论（Young's theory）中所提及三色感知的光感神经纤维，就是后续被我们所熟知的视锥细胞（cone cells），并对三类视锥细胞敏感的红、绿、蓝三色所对应光波波长进行了重测定。由此，进一步推动了三色理论（trichromatic theory）雏形的形成 [4] [5]。人们为了纪念两位的贡献，也将三色理论称为 杨-亥姆霍兹理论（Young–Helmholtz theory）。 图 2.1-2 赫尔曼·冯·亥姆霍兹的三色理论，关于视锥细胞感知范围的手稿 受限于当时的科研器材水平，亥姆霍兹很遗憾的没有确切的办法，测量到三类视锥细胞可感知的确切波长范围。不过现代医学领域的研究，已相对准确的得到了答案。我们的眼睛基于此三种颜色的波形叠加组合，形成了能够覆盖从紫到红（360nm - 780nm）的 312nm - 1050nm 可观测波长范围 [6]。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_2.html":{"url":"Chapter_2/Language/cn/Docs_2_2.html","title":"2.2 颜色三要素（Three Elements of Color）","keywords":"","body":"2.2 颜色三要素（Three Elements of Color） 1853 年，赫尔曼·格拉斯曼（Hermann Günter Grassmann，1809 - 1877） 基于三色理论，取一组红绿蓝三色光源，尝试还原其他类型视觉单色（monochromat）的实验。这就是著名的光谱的 色度特性实验 （The Colorimetric Properties of the Spectrum） [7]。实验过程经过对红绿蓝三色灯源的水平位置调整，来间接的调整了三色最终组合情况。对比则选用了契合目标结果的参考光源。根据实验结果，格拉斯曼发现，确实可以用一个变权三元一次等式来对所有可见单色光源进行基于光学三原色（RGB）的合成。但是这样的合成是有条件的，对于部分特殊的颜色，例如橄榄绿（Vibrantgreen），就需要将红色光源摆放到隔板左边靠近对比光源的位置，才能使目标色在目标采样区域合成出来。他将这种现象称为 负色匹配（'negative' colors matching） 。而在此次试验中，格拉斯曼得到大量需要使用 1 个或 2 个 负色才能匹配的单色。这种现象的出现，在于当时的物理实验设备并不能很好的找到，合适作为人眼感知波峰基准值的光学三原色（RGB）波长，导致需要通过较多负拟合的方式，来人为的处理三相波叠加的还原它色问题。不过这并不影响实验有奠基理论产出。 图 2.2-1 赫尔曼·格拉斯曼（Hermann Günter Grassmann，1809 - 1877） 1854年，格拉斯曼结合光谱色度特性试验的结果，在牛顿颜色混合理论的基础上，总结归纳出了 格拉斯曼颜色定律（Grassmann's law），奠定了光学理论下现代色度学基础 [8] 。定律包含五条，分别为： 1）补色律，指任何一种颜色都有另一种同它混合产生白和灰的颜色； 2）间色律，指混合任何两种非补色便可产生一种新的混合色或介于两者之间的中间颜色； 3）代替律，指任何不同颜色混合产生的颜色可相互替代； 4）相加律，指混合色的总光亮度为组成混合色的各颜色光亮度的总和； 5）混合律，人的视觉只能分辨颜色的色调、光亮度、饱和度三种变化。 这些规律仅适用于色光的加法混合理论。即在基色体系中，只适用于光学三原色（RGB）。格拉斯曼在规律中，首次提出了 色调（Hue）、饱和度（Saturation）、光亮度（Luminance） 的重要性，这三个属性继而被称为 颜色的三要素（Three Elements of Color） [9] 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_2_1.html":{"url":"Chapter_2/Language/cn/Docs_2_2_1.html","title":"2.2.1 色调（Hue）","keywords":"","body":"2.2.1 色调（Hue） 色调（Hue） 也被称为色相，指颜色实际种类。换一种角度来说。色调是对人眼可观察颜色的基础分类。通过色调，结合其他两个颜色的三要素，我们能够准确的描述自然界中能够形成的任意混合色。 格拉斯曼在混合律 中，以色轮作为环形颜色索引表，对色轮上颜色进行了基于几何弧度的划分，使颜色的色调能够用其与相对基准色的逆时针夹角表示。色调的作用在于，可以将任意两个环上选定颜色的权重看作物理重量，利用两点连线后线段质量中心与圆环圆心连线的延长线，来推算最终结果。 图 2.2.1-1 格拉斯曼的混合律颜色推算演示 图中，O 代表理想白点（White Point），D 代表混合后对应单色； 假设我们以选定颜色与0度的夹角，对应的弧度表示该颜色本身。现有两个颜色，分别为 (RA,GA,BA)(R_{A},G_{A},B_{A})(R​A​​,G​A​​,B​A​​) 和 (RB,GB,BB)(R_{B},G_{B},B_{B})(R​B​​,G​B​​,B​B​​) ，那么取权重 (WAC,WCB)(W_{AC},W_{CB})(W​AC​​,W​CB​​) ， W=WAC+DCB=1W = W_{AC} + D_{CB} = 1W=W​AC​​+D​CB​​=1 。对于 D 点的颜色 (RD,GD,BD)(R_{D},G_{D},B_{D})(R​D​​,G​D​​,B​D​​) 就有： RD=WACRA+WCBRBGD=WACGA+WCBGBBD=WACBA+WCBBB {\\displaystyle \\begin{aligned} R_{D} = W_{AC} R_{A} + W_{CB} R_{B} \\\\ G_{D} = W_{AC} G_{A} + W_{CB} G_{B} \\\\ B_{D} = W_{AC} B_{A} + W_{CB} B_{B} \\end{aligned} } ​R​D​​=W​AC​​R​A​​+W​CB​​R​B​​​G​D​​=W​AC​​G​A​​+W​CB​​G​B​​​B​D​​=W​AC​​B​A​​+W​CB​​B​B​​​​ 混合律是对加法混合论的一次成功拓展，此时已经隐约可以看到最初色度图的理论雏形了。不过这时对颜色的索引还停留在比较初级的阶段。现代学界和工业界已普遍采用 色度（Chromaticity） ，配合 颜色空间（Color Space），来代替描述颜色种类。色调更多的被用于艺术和设计领域。 另一方面，随着 现代色彩体系（Modern Color System） 的在细分领域的逐步分化，部分颜色空间的规格出发点，也对色调（Hue）和饱和度（Saturation）代表的概念本身进行了充分的抽象，形成了诸如 LAB、LUV 和 颜色三要素（HSL）等经典的色彩空间方案 。为当代计算机工业体系中，艺术设计、数据传输和工程计算方面的贯通，提供了较大的帮助（可参见后文 2.5 经典色彩空间 ）。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_2_2.html":{"url":"Chapter_2/Language/cn/Docs_2_2_2.html","title":"2.2.2 饱和度（Saturation）","keywords":"","body":"2.2.2 饱和度（Saturation） *饱和度 是指颜色的浓淡程度。以其对比标准的不同，被区分为 光学饱和度（Colorfulness） 和 感官饱和度（Saturation） [10]。光学饱和度多用于工程，感官饱和度则多用于艺术设计中。 光学饱和度指标 ，被定义为标准白点与实际颜色的强度分量与白点到其纯色分量的长度比； 感官饱和度指标 ，被定义为一个区域的颜色与其当前亮度的充盈配比； 从定义的角度来看，显然感官饱和度的主观成分较大。虽然色彩的光学饱和度和感官饱和度在概念上面存在较大差异。但是实际工程实践中，这两个通常被混为一谈（虽然这么做并不严谨）。工程师们经常以光学饱和度（Colorfulness）为主，将两个概念统称为饱和度（Saturation）。因此，我们这里使用的饱和度，即代指光学饱和度（Colorfulness）[11]。 在描述的格拉斯曼颜色推算过程中，我们提到过。将其单独抽出来看： 图 2.2.2-1 格拉斯曼的饱和度定义说明 其中，D点就是推算颜色 (RD,GD,BD)(R_{D},G_{D},B_{D})(R​D​​,G​D​​,B​D​​) 的最大饱和度，O点则是纯白光 OpureO_{pure}O​pure​​ 。 OC 代表白色分量强度，记为 DaD_{a}D​a​​ ； CD 代表纯色分量强度，记为 DbD_{b}D​b​​ ； 则， D=Da+Db=1D = D_{a} + D_{b} = 1D=D​a​​+D​b​​=1 ，记为总强度。 假设 C点的颜色为 (RC,GC,BC)(R_{C},G_{C},B_{C})(R​C​​,G​C​​,B​C​​)，我们就有： RC=DaOpure+DbRD=(1−Db)Opure+DbRDGC=DaOpure+DbGD=(1−Db)Opure+DbGDBC=DaOpure+DbBD=(1−Db)Opure+DbBD {\\displaystyle \\begin{aligned} R_{C} = D_{a} O_{pure} + D_{b} R_{D} = (1-D_{b}) O_{pure} + D_{b} R_{D} \\\\ G_{C} = D_{a} O_{pure} + D_{b} G_{D} = (1-D_{b}) O_{pure} + D_{b} G_{D} \\\\ B_{C} = D_{a} O_{pure} + D_{b} B_{D} = (1-D_{b}) O_{pure} + D_{b} B_{D} \\end{aligned} } ​R​C​​=D​a​​O​pure​​+D​b​​R​D​​=(1−D​b​​)O​pure​​+D​b​​R​D​​​G​C​​=D​a​​O​pure​​+D​b​​G​D​​=(1−D​b​​)O​pure​​+D​b​​G​D​​​B​C​​=D​a​​O​pure​​+D​b​​B​D​​=(1−D​b​​)O​pure​​+D​b​​B​D​​​​ 而 DbD_{b}D​b​​ 就是饱和度 SSS 。整个格拉斯曼颜色混合律就可以用一个公式表示了： C=(1−S)Opure+S(WACRA+WCBRB)=Opure+S(WACRA+WCBRB−Opure) C = (1-S) O_{pure} + S (W_{AC}R_{A}+W_{CB}R_{B}) = O_{pure} + S (W_{AC}R_{A}+W_{CB}R_{B} - O_{pure}) C=(1−S)O​pure​​+S(W​AC​​R​A​​+W​CB​​R​B​​)=O​pure​​+S(W​AC​​R​A​​+W​CB​​R​B​​−O​pure​​) 如果记白点 O 为无穷小（0）。那么整个式子就可以简化为： C=S(WACRA+WCBRB)=S⋅D C = S (W_{AC}R_{A}+W_{CB}R_{B}) = S \\cdot D C=S(W​AC​​R​A​​+W​CB​​R​B​​)=S⋅D 在已知白点（White Point）和选定色的情况下。依据格拉斯曼饱和度取值，人们可以计算得期望的渐变色泽，从而快速调色。 同 色调（Hue） 一样， 饱和度（Saturation） 也处于简单系统中，不方便体系下的量化。因此，饱和度的概念在现代学界和工业界中，同样也普遍被色度（Chromaticity）配合颜色空间（Color Space）代替表示 ，以便于工程量化计算。 现代色彩体系（Modern Color System） 中的部分方案，对饱和度概念进行了有效的利用转换（可参见后文 2.5.7 颜色三要素色彩空间 ）。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_2_3.html":{"url":"Chapter_2/Language/cn/Docs_2_2_3.html","title":"2.2.3 光亮度（Luminance）","keywords":"","body":"2.2.3 光亮度（Luminance） 光亮度（Luminance） 也被称为辉度，是指固定光所照射单位平面面积光照区域的物理发光强度，单位是尼特（ NitNitNit ），代表烛光每立方米（ cd/m2cd/m^2cd/m​2​​ ，candela per square metre）。光亮度属于光度学（Luminosity）概念。区别于亮度（Brightness）这种用来形容人生理光强直接感受的主观描述，光亮度是从可见光谱范围计量的物理量。 光亮度的计算依赖于发光强度度量。而 发光强度（Luminous Intensity） 则是用于表示光源给定方向上单位立体角内光通量的物理量，又被称为光强或光度，单位是烛光（ cdcdcd ， candelacandelacandela ）。 如果记光亮度为 LvL_{\\mathrm {v}}L​v​​ ，发光强度为 IvI_{\\mathrm {v}}I​v​​ ，那么两者单位间的关系为 1 Nit=1 cd/m2 1 \\ Nit = 1 \\ cd/m^2 1 Nit=1 cd/m​2​​ 光亮度的测量方法在格拉斯曼时期，并没有太好的量化标准，因此更多的是作为一个参数来配合其他要素进行颜色描述的。现如今，对于光亮度的国际统一测量标准如下图所示： 图 2.2.3-1 光亮度测量实验与关键变量示意图 其中， 记 Σ\\SigmaΣ 代表光源，SSS 代表接受光线的物体照射表面， 记 dΣ{d\\Sigma}dΣ , 代表发光源上包含到达照射表面指定定向光线出发点的无穷小面积， 记 dSdSdS 代表照射表面上包含指定出发点的光源定向光线照射目标点的无穷小面积， 记 dΩΣd\\Omega_\\SigmadΩ​Σ​​ , 代表光线出发点与 dSdSdS 所构锥体立体角（Solid Angle）的球面度（sr: Steradian）, 记 dΩSd\\Omega_SdΩ​S​​ , 代表光线接受点与 dΣd\\SigmadΣ 所构锥体立体角（Solid Angle）的球面度（sr: Steradian）, 记 nΣn_\\Sigman​Σ​​ 代表 dΣd\\SigmadΣ 的法向量， θΣ\\theta_\\Sigmaθ​Σ​​ 代表 nΣn_\\Sigman​Σ​​ 与指定定向光线的夹角， 记 nSn_Sn​S​​ 代表 dSdSdS 的法向量， θS\\theta_Sθ​S​​ 代表 nSn_Sn​S​​ 与指定定向光线的夹角， 如果取国际通用单位制，且光线在传播过程中经过的介质为无损介质的话，那么就存在如下的光亮度计算公式： LvΣ=d2ΦvdΣdΩΣcosθΣ=d2ΦvdSdΩScosθS=LvS {\\displaystyle L_{\\mathrm {v}_{\\Sigma } }={\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {v} }}{\\mathrm {d} \\Sigma \\,\\mathrm {d} \\Omega _{\\Sigma }\\cos \\theta _{\\Sigma }}}={\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {v} }}{\\mathrm {d} S\\,\\mathrm {d} \\Omega _{S}\\cos \\theta _{S}}}=L_{\\mathrm {v}_{\\mathrm {S}}}} L​v​Σ​​​​=​dΣdΩ​Σ​​cosθ​Σ​​​​d​2​​Φ​v​​​​=​dSdΩ​S​​cosθ​S​​​​d​2​​Φ​v​​​​=L​v​S​​​​ 取出入面积及立体角相等，记同等出入面积为 AAA ，立体角为 Ω\\OmegaΩ ，照射角为 θ\\thetaθ ，则有： dΩ=dΩΣ=dΩSdθ =dθΣ =dθSdA=dΣ  =dS {\\displaystyle \\begin{aligned} &{d} \\Omega = {d} \\Omega _{\\Sigma } = {d} \\Omega _{S} \\\\ &{d} \\theta \\ = {d} \\theta _{\\Sigma }\\ = {d} \\theta _{S} \\\\ &{d} A = {d} {\\Sigma }\\ \\ = {d} {S} \\\\ \\end{aligned} } ​​​​​​​dΩ=dΩ​Σ​​=dΩ​S​​​dθ =dθ​Σ​​ =dθ​S​​​dA=dΣ  =dS​​ Lv=d2ΦvdAdΩcosθ L_{\\mathrm {v}} = {\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {v} }}{\\mathrm {d} A\\,\\mathrm {d} \\Omega \\cos \\theta }} L​v​​=​dAdΩcosθ​​d​2​​Φ​v​​​​ 公式中， 以 Φv\\Phi _{\\mathrm {v} }Φ​v​​ 代表 光通量（Luminous Flux） , 单位是流明（ lmlmlm ，lumenlumenlumen ），是指标度可见光对人眼的视觉刺激程度，是光度学下的人眼视觉特性导出量（规格量）。1 cd1\\ cd1 cd 点光源在单位立体角（ 1 sr1\\ sr1 sr ）下的光通量为 1 lm1\\ lm1 lm , 即 1 lm=1 cd⋅sr1 \\ lm = 1 \\ cd \\cdot sr1 lm=1 cd⋅sr 。光通量计算公式是： Iv=dΦvdΩ→Φv=∫ΣIv⋅dΩ {I _{\\mathrm {v}}} = {\\frac {\\mathrm {d} \\Phi _{\\mathrm {v} }}{\\mathrm {d} \\Omega}} \\rightarrow {\\Phi _{\\mathrm {v}}} = \\int _{\\Sigma } I_v \\cdot {d} \\Omega I​v​​=​dΩ​​dΦ​v​​​​→Φ​v​​=∫​Σ​​I​v​​⋅dΩ 如果记 EvΣE_{\\mathrm {v}_{\\Sigma }}E​v​Σ​​​​ 为单位光源面积发出的光通量即 光出射度（Luminous Exitance） ，记 EvSE_{\\mathrm {v}_{S }}E​v​S​​​​ 为单位受照面积接受的光通量即 光照度（Illumination） 。那么在无损截止情况下 EvΣ=EvSE_{\\mathrm {v}_{\\Sigma }} = E_{\\mathrm {v}_{S }}E​v​Σ​​​​=E​v​S​​​​ ，我们记为 EvE_{\\mathrm {v}}E​v​​ 。被称为光照射度，单位是勒克斯（ luxluxlux ， lxlxlx ）。 1 lx=1 lm/m21 \\ lx = 1 \\ lm/m^21 lx=1 lm/m​2​​ 有： Ev=dΦvdA E_{\\mathrm {v}} = {\\frac {\\mathrm {d} \\Phi _{\\mathrm {v} }}{\\mathrm {d} A}} E​v​​=​dA​​dΦ​v​​​​ 则 d2Φv{\\mathrm {d} ^{2}\\Phi _{\\mathrm {v} }}d​2​​Φ​v​​ 代表由 dΣd\\SigmadΣ 发出的光线，在 dΩΣd\\Omega_\\SigmadΩ​Σ​​ 为球面度的立体角下的全方向光通量，即： d2Φv=dEv⋅dA d^{2}\\Phi _{\\mathrm {v} } = dE_{\\mathrm {v}} \\cdot dA d​2​​Φ​v​​=dE​v​​⋅dA 那么整个公式就可以化简为： Lv=dEvdΩ⋅cosθ {\\displaystyle L_{\\mathrm {v} }={\\frac {\\mathrm {d} E _{\\mathrm {v} }}{d \\Omega \\cdot \\cos \\theta }}} L​v​​=​dΩ⋅cosθ​​dE​v​​​​ 这个公式就是我们在光度学角度，用来计算物体 理想亮度的标准公式 。 如果需要计算介质造成的损耗，那么公式需要引入 光展量（Etendue） ，即在材质折射率下的光束所通过的面积和光束所占有的立体角的积分。我们计 GGG 代表光展量， nnn 代表折射率，则光展量公式： G=∫Σ∫SdG→dG=n2⋅dAdΩcosθ {\\displaystyle G=\\int _{\\Sigma }\\!\\int _{S}\\mathrm {d} G} \\rightarrow {\\mathrm {d}G }=n^{2} \\cdot {\\mathrm {d} A\\,\\mathrm {d} \\Omega \\cos \\theta } G=∫​Σ​​∫​S​​dG→dG=n​2​​⋅dAdΩcosθ 对于无损介质，折射率 n=1n=1n=1 。因此，整个亮度公式在知道光展量的情况下，就可以简化为： Lv=n2dΦvdG=dΦvdG∣n=1 {\\displaystyle L_{\\mathrm {v} }=n^{2}{\\frac {\\mathrm {d} \\Phi _{\\mathrm {v} }}{\\mathrm {d} G}}} = {\\frac {\\mathrm {d} \\Phi _{\\mathrm {v} }}{\\mathrm {d} G}}|_{n=1} L​v​​=n​2​​​dG​​dΦ​v​​​​=​dG​​dΦ​v​​​​∣​n=1​​ 光亮度不会影响物体的色彩信息，而仅代表物体本身发光的强度。决定物体本身颜色信息的，则是物体所具有的色调和饱和度属性。 光度单位体系是一套反映视觉亮暗特性的光辐射计量单位，被选作基本量的不是光通量而是发光强度，因此这套公式只适用于可见光范围。对光的更为客观的描述则依赖于辐射度学的相关概念。辐射度学从黑体辐射与能量密度的学角度出发更换了物理学参照物，将光度学系统提出的度量理念适用范围，扩展到了包含长短波的完整电磁波段。进而间接的促成了色温概念在色彩学的应用。这个会在后文中有关颜色度量的章节额外说明。 由于光亮度的这种自成体系的特性。在颜色的三要素的应用中，它通常被分离单独处理 。所以，现代工程体系中不会直接的应用光度学里的光亮度公式 ，而是采用 辐射亮度（Radiance） 的科学物理量，结合 色温（Color Temperature） ，或 色彩空间（Color Space）如 HSL 的色彩强度（Intensity） 的自设定参数，等概念平替。 至此，色彩学的经典理论：格拉斯曼颜色定律，所引申出的重要配参已准备完毕。问题随之而来： 我们能否将描述自然现象的参考标准，应用在有局限的实际生产活动中。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3.html":{"url":"Chapter_2/Language/cn/Docs_2_3.html","title":"2.3 色彩的衡量","keywords":"","body":"2.3 色彩的衡量 光学三要素的出现，让人们在对颜色的客观描述上，能够凭借传统色彩学体系内的参数，进行有限程度的量化。但这并不足以适用于除科学计算和测定外的批量工程作业。毕竟在算力限定的条件下，我们不可能对每一寸光的每一个物理量都进行独立的计算。同时，大量繁琐且模糊的设定也 无法便于简化 ，而我们也需要获得 能够将感官上的体验和客观上的物理值联系起来的方法论 。 如果能够将光波本身和颜色建立起直接的可量化的转换关系，就能够解决表示上的问题了。这就是 配色函数 的由来。 于是，首先需要做的是 获得科学证明 ，以 提供函数构建理论上的支持 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3_1.html":{"url":"Chapter_2/Language/cn/Docs_2_3_1.html","title":"2.3.1 辐射亮度（Radiance）& 色温（Color Temperature）& 颜色的量化","keywords":"","body":"2.3.1 辐射亮度（Radiance）& 色温（Color Temperature）& 颜色的量化 辐射亮度（Radiance） 也被称为辐亮度，是用于描述指定辐射源，单位方向上辐射强弱的客观物理量。 辐射度学（Radiometry） 和 光度学（Luminosity） ，都是对电磁辐射能量进行计量的学科。不同之处在于，辐射度学是物理电磁波能量角度的客观计量，光度学是人眼视觉的主观因素后的相应计量。因此，相比于之前在颜色三要素里提及的 光亮度（Luminance） ，辐射度学的 辐射亮度（Radiance） 其实才更贴近光亮度的物理本质。 而人们是如何通过辐射度学对能量的定义，将光的波长和颜色对应起来的呢？这就需要提到色温的概念了。 色温（Color Temperature） 是由物体本身的黑体辐射决定的一个物理量，计量单位为 K（开尔文温度）。它被定义为，绝对黑体从绝对零度（－273.15℃）开始加温后所呈现出的颜色。由于颜色本身就是一个主观量，而颜色又是由光的波长决定的，不同的色温本质上对应的是不同波长的光。所以，如果我们将色温这个纯粹的辐射度学概念延伸应用到了色彩领域，就能利用色温代表意义本身，建立起两个体系之间的联系了。 辐射度学与光度学的单位转换 同光亮度，辐射亮度的计算也需要依赖于辐射强度度量。 辐射强度（Radiant Intensity） 是用于表示光源给定方向上单位立体角内辐射通量的物理量，单位是瓦特每球面度（ W/srW/srW/sr ）。辐射通量（Radiant Flux）是指单位时间内通过某一截面的辐射能，位是瓦特（ WWW ）。 记辐射亮度为 LeL_{\\mathrm {e}}L​e​​ ，辐射强度为 IeI_{\\mathrm {e}}I​e​​ ，辐射通量为 Φe\\Phi _{\\mathrm {e}}Φ​e​​ ，辐射照射度 EeE _{\\mathrm {e}}E​e​​ 。那么四者间的关系为： Ie=dΦedΩ→Φe=∫ΣIe⋅dΩEe=dΦedA→d2Φe=dEe⋅dALe=d2ΦedAdΩcosθ=dEedΩ⋅cosθ {\\displaystyle \\begin{aligned} &{I _{\\mathrm {e}}} = {\\frac {\\mathrm {d} \\Phi _{\\mathrm {e} }}{\\mathrm {d} \\Omega} \\rightarrow \\Phi _{\\mathrm {e}}} = \\int _{\\Sigma } I_e \\cdot {d} \\Omega \\\\ &E_{\\mathrm {e}} = {\\frac {\\mathrm {d} \\Phi _{\\mathrm {e} }}{\\mathrm {d} A}} \\rightarrow \\mathrm {d} ^{2}\\Phi _{\\mathrm {e} } = \\mathrm {d} E_{\\mathrm {e}} \\cdot \\mathrm {d} A \\\\ & L_{\\mathrm {e}} =\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {e} }}{\\mathrm {d} A\\,\\mathrm {d} \\Omega \\cos \\theta } =\\frac {\\mathrm {d} E _{\\mathrm {e} }}{d \\Omega \\cdot \\cos \\theta } \\\\ \\end{aligned} } ​​​​​​​I​e​​=​dΩ​​dΦ​e​​​​→Φ​e​​=∫​Σ​​I​e​​⋅dΩ​E​e​​=​dA​​dΦ​e​​​​→d​2​​Φ​e​​=dE​e​​⋅dA​L​e​​=​dAdΩcosθ​​d​2​​Φ​e​​​​=​dΩ⋅cosθ​​dE​e​​​​​​ 公式中，辐射源面积为 AAA ，立体角为 Ω\\OmegaΩ ，照射角为 θ\\thetaθ ，概念基本等同光亮度公式同位参数。 显然，光亮度和辐射亮度的差异只在于参考系上。从有效范围上看，光亮度属于辐射亮度仅考虑可见光谱区域的特殊情况。为了使两个体系能够转换，1979年第十六届国际计量大会 上，人们对发光强度单位坎德拉进行了指定。现在我们说说的一单位坎德拉，即指代发光频率为 HzHzHz 的单色光，在垂直光源表面的定向单位幅角下，测量的辐射强度。即： 1 cd=1/683 W/sr=1 lm/sr  →  1 W=683 lm 1 \\ cd = 1/683 \\ W/sr = 1 \\ lm / sr \\ \\ \\rightarrow \\ \\ 1 \\ W = 683 \\ lm 1 cd=1/683 W/sr=1 lm/sr  →  1 W=683 lm 因此，记光辐转化率为 KKK ，单位为 lm/Wlm/Wlm/W ，则 KKK 、 Φe\\Phi _{\\mathrm {e}}Φ​e​​ 与 Φv\\Phi _{\\mathrm {v}}Φ​v​​ 存在两者之间的转换关系： Φv=K⋅ΦeK=683 lm/W {\\displaystyle \\Phi_v = K \\cdot \\Phi_e \\quad \\quad K = 683 \\ lm/W} Φ​v​​=K⋅Φ​e​​K=683 lm/W 带入光亮度 LvL_{\\mathrm {v}}L​v​​ 与辐射亮度 LeL_{\\mathrm {e}}L​e​​ 的公式，可得： Lv=K⋅Le {\\displaystyle L_{\\mathrm {v}} = K \\cdot L_{\\mathrm {e}} } L​v​​=K⋅L​e​​ 如此就可以通过 KKK 来完成，辐射度学和光度学间计量的转换了。 我们知道光度学中的不同颜色，本质是波长的不同。而不同的波长在辐射度学中，则代表为不同的能量密度。只要求得对应颜色光的能量密度，就能反向推算对应颜色光的波长了，进而可以将感知到的颜色用实际物理量标定。 借此，以主观感受的客观测量值，人为映射量化建立联系。 至于能量密度的测定，则可以经由物理学体系的黑体辐射定律揭示而出。 从色温到颜色 - 颜色的波长标定 色温（Color Temperature） 是由物体本身的黑体辐射决定的一个物理量，计量单位为 K（开尔文温度）。它被定义为，绝对黑体从绝对零度（－273.15℃）开始加温后，在辐射到达指定复合波情况时所具有的温度。 1900年在德国物理学会上，著名的德国物理学大师 马克思·普朗克（Max Karl Ernst Ludwig Planck，1858 - 1947） ，公布了自己在电磁波能量问题上的假设，这就是在物理学界影响深远的《论正常光谱中的能量分布》报告。报告的细部由同年普朗克发表的两篇论文组成，分别是《关于维恩频谱方程的改进论》(On an Improvement of Wien's Equation for the Spectrum) [23] 和《关于正常光谱中的能量分布的理论》（On the Theory of the Energy Distribution Law of the Normal Spectrum）[24] 。这两篇理论统一了之前由“紫外灾变”问题分割的，高频有效的维恩位移定律和低频有效的瑞利-金斯公式，并直接促成了量子理论的奠基和近代物理学革命。 记 λ\\lambdaλ 代表电磁波长，vvv 代表 λ\\lambdaλ 的频率， TTT 代表色温， ccc 为光速，普朗克黑体辐射定律（Planck's law｜Blackbody radiation law） 的能量密度公式提出： uλ (λ,T)=8πhcλ5⋅1ehcλkT−1=4πc⋅Ie(v)=8πhv3c5⋅1ehvkT−1=uv (v,T) {\\displaystyle \\begin{aligned} u_{\\lambda }\\ (\\lambda,T) ={\\frac {8\\pi hc}{\\lambda^{5}}} \\cdot {\\frac {1}{e^{\\tfrac{hc} {\\lambda kT}}-1}} ={\\frac {4\\pi}{c}} \\cdot I_e (v) ={\\frac {8\\pi hv^3}{c^{5}}} \\cdot {\\frac {1}{e^{\\tfrac{hv} {kT}}-1}} ={u_{v }\\ (v,T)} \\\\ \\end{aligned} } ​u​λ​​ (λ,T)=​λ​5​​​​8πhc​​⋅​e​​λkT​​hc​​​​−1​​1​​=​c​​4π​​⋅I​e​​(v)=​c​5​​​​8πhv​3​​​​⋅​e​​kT​​hv​​​​−1​​1​​=u​v​​ (v,T)​​​ 公式中， ccc 为光速， 有 hhh 为 普朗克常数 取 (6.62607015⋅10−34) J⋅s(6.62607015 \\cdot 10^{-34})\\ J\\cdot s(6.62607015⋅10​−34​​) J⋅s ，国际计量大会通过决议值， 有 kkk 为 玻尔兹曼常数 取 (1.380649⋅10−23) J/K(1.380649 \\cdot 10^{-23})\\ J/K(1.380649⋅10​−23​​) J/K ，国际计量大会通过决议值， 当已知黑体辐射源，其单位立方体所含能量与光波长关系如下图所示： 图 2.3.1-1 黑体辐射强度与波长分布曲线示意图 图上能明显看到，当物体处于不同色温时，其黑体辐射的总能量被分配到了不同波长光波携带。最终辐射波的情况，则是由不同区段的波长叠加而成，其叠加的强度则和对应波长携带的能量强度正相关。我们取 360nm - 780nm 可见光谱（Visible Spectrum） 范围，那么上图就有如下的展示了： 图 2.3.1-2 可见光谱范围内黑体辐射与波长分布曲线示意图 显然，色温高于 5000k 的物体在短波段出现了极大的富集程度，色温低于 5000k 的物体则是长波较为密集。所以自然界中的高温物体在人眼观察中往往偏向蓝白色，相关色温低温的物体则多呈现橙红色。 记色温为 T0T_{0}T​0​​ ， T0T_{0}T​0​​ 对应的颜色为 C0C_{0}C​0​​ 光亮度 L0L_{0}L​0​​ ， C0C_{0}C​0​​ 对应可见光范围总辐射强度为 IeI_{e}I​e​​ ，光强度 IvI_{v}I​v​​ 。单位面积辐射能为 QQQ ，存在映射函数 Mapping(C0, L0)=QMapping(C_0,\\ L_0) = QMapping(C​0​​, L​0​​)=Q 。 据电磁波辐射能公式有： Q=Le⋅dA=1K⋅Iv⋅dΦvdA2cosθ⋅dA=∫360nm780nmuλ (λ,T0)⋅dλ≈∑360nm780nmuλ (T0)⋅λ {\\displaystyle \\begin{aligned} &Q = {L_e} \\cdot dA = {\\frac {1}{K}} \\cdot {I_v} \\cdot {\\frac {\\mathrm {d} \\Phi _{\\mathrm {v} }}{\\mathrm {dA^2} \\cos{\\theta }}} \\cdot dA = \\int _{360nm} ^{780nm} u_{\\lambda }\\ (\\lambda,T_0) \\cdot {d} {\\lambda} \\approx \\sum _{360nm} ^{780nm} u_{\\lambda }\\ (T_0) \\cdot {\\lambda} \\end{aligned} } ​​​​Q=L​e​​⋅dA=​K​​1​​⋅I​v​​⋅​dA​2​​cosθ​​dΦ​v​​​​⋅dA=∫​360nm​780nm​​u​λ​​ (λ,T​0​​)⋅dλ≈​360nm​∑​780nm​​u​λ​​ (T​0​​)⋅λ​​ 取 1 sr1\\ sr1 sr 单位发光 1 lm1\\ lm1 lm 单位光通量，即 Iv=1 cdI_{v} = 1\\ cdI​v​​=1 cd 。 假设所有区段的电磁波在传播方向上相同，且法线方向。则上式可化为： Q=1K⋅Lv⋅dA=1K⋅IvdA=∑360nm780nmuλ (T0)⋅λ  →  Q=Lv⋅∑360nm780nmuλIvλ⋅K=Lv⋅∑360nm780nmuλIeλ {\\displaystyle \\begin{aligned} &Q = {\\frac {1}{K}} \\cdot {L_v} \\cdot {dA} = {\\frac {1}{K}} \\cdot {\\frac {I_v}{dA}} = \\sum _{360nm} ^{780nm} u_{\\lambda }\\ (T_0) \\cdot {\\lambda} \\ \\ \\rightarrow \\ \\ Q = {L_v} \\cdot \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_v}} \\lambda \\cdot {\\mathrm K } = {L_v} \\cdot \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_e}} \\lambda \\\\ \\end{aligned} } ​​​​​Q=​K​​1​​⋅L​v​​⋅dA=​K​​1​​⋅​dA​​I​v​​​​=​360nm​∑​780nm​​u​λ​​ (T​0​​)⋅λ  →  Q=L​v​​⋅​360nm​∑​780nm​​​I​v​​​​u​λ​​​​λ⋅K=L​v​​⋅​360nm​∑​780nm​​​I​e​​​​u​λ​​​​λ​​ 那么带入映射函数，我们就有： Mapping(C0,L0)=L0⋅∑360nm780nmuλIeλ=F(C0,L0) {\\displaystyle \\begin{aligned} &Mapping(C_0, L_0) = {L_0} \\cdot \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_e}} \\lambda = F(C_0, L_0) \\\\ \\end{aligned} } ​​​​​Mapping(C​0​​,L​0​​)=L​0​​⋅​360nm​∑​780nm​​​I​e​​​​u​λ​​​​λ=F(C​0​​,L​0​​)​​ C0=Convert(∑360nm780nmuλIeλ)=F(∑360nm780nmuλIeλ) {\\displaystyle \\begin{aligned} &C_0 = Convert( \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_e}} \\lambda ) = F( \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_e}} \\lambda ) \\\\ \\end{aligned} } ​​​​​C​0​​=Convert(​360nm​∑​780nm​​​I​e​​​​u​λ​​​​λ)=F(​360nm​∑​780nm​​​I​e​​​​u​λ​​​​λ)​​ 可见，只要选取合适的转换函数 F(C)F(C)F(C) ，我们就可以将色温为 T0T_{0}T​0​​ 时对应的颜色，以 F(C0, L0)F(C_0,\\ L_0)F(C​0​​, L​0​​) 的形式表述到函数所在参考系中。因此，这个用于颜色匹配的转换函数 F(C)F(C)F(C) ，就被称为 配色函数（Color-Matching Functions） 。 只要能找到适合的 F(C)F(C)F(C) 使颜色能够被统一的衡量，就能制定工业标准，正式开始现代化的工程实践了。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3_2.html":{"url":"Chapter_2/Language/cn/Docs_2_3_2.html","title":"2.3.2 配色函数（Color Matching Functions）& 色彩空间（Color Space）","keywords":"","body":"2.3.2 配色函数（Color Matching Functions）& 色彩空间（Color Space） 配色函数（Color Matching Functions） ，又被称为 色匹配函数 ，狭义上是用来完成从物理计量到色彩学计量的转换函数的代称。广义上，我们将用来描述一个人为设定的色彩系统里，用于量化颜色的函数称为配色函数。 我们知道，脱离参考系的函数是没有意义的，于是色彩空间概念伴随而生。通过色彩空间，颜色能够被人为设置条件下的单一系统表达。 那么，什么是色彩空间呢？ 色彩空间（Color Space） 又被称为 色彩模型（Color Model） ，是对使用一组抽象参数结合配色函数（Color-Matching Functions），来表示颜色的数学系统的统称。色彩空间更多的是对学科理论的实践，我们可以将其看为对色彩学最为直观的规格应用。从设计出发点来看，色彩空间大体分为两类：设备相关（Device-Dependent） 色彩空间，和 设备无关（Device-Independent） 色彩空间。 设备相关（Device-Dependent）色彩空间 ，是指颜色的表达依赖于物理设备本身情况和指定主观参数的色彩空间。诸如：IBM RGB、CMY/CMYK，配色函数可表示颜色范围依赖设备本身性能。 设备无关（Device-Independent）色彩空间 ，是指一类不依赖于物理设备的客观描述色彩空间。诸如：CIE RGB、CIE XYZ、CIE 1960 LAB、CIE 1960 UCS、HSL、CIE 1964 UVW，设备的选取并不影响色彩空间范围内的颜色表示。 所以，色彩空间虽然是用来理解颜色概念的有力工具，但它本身可能并不客观。需要选定一个，能够统一无论主客的不同数学系统对颜色描述的，基础色彩空间。以此来系统化整个色彩模型体系。直接以光学三原色为基础的设备无关色彩空间，相对的能更好满足这一点，并在简化表达上具有无可替代的优势。基于此，经典三原色函数诞生了。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3_3.html":{"url":"Chapter_2/Language/cn/Docs_2_3_3.html","title":"2.3.3 经典三原色函数（Trichromatic Primaries Functions）","keywords":"","body":"2.3.3 经典三原色函数（Trichromatic Primaries Functions） 1921 年左右，威廉·大卫·赖特（W. David Wright，1906 - 1997） [26] 与 约翰·吉尔德（John Guild，1889 - 1976） [27] 分别对光学三原色的基本度量系数进行了更为科学的测定，并分别于1928年 、1932年以论文形式发表了自己的结果。这两个实验，为 CIE 经典三原色函数（Trichromatic Primaries Functions）标准 的制定提供了极为关键的帮助。 我们将代表不同可见光波长对人眼视锥细胞的刺激程度的函数，称为色感函数，也就是选取人眼为传感器的 光谱响应函数（SPF [Spectral Response Function]）。由色感函数在可见光波段所构成的曲线，称为色感曲线。由实验所拟合的三原色的色感曲线，在 435.8nm（蓝）、 546.1nm（绿）、 700nm（红）处达到最大峰值，如下图： 图 2.3.3-1 CIE 1931 RGB 采用的三原色色感函数 CIE 在两者实验的基础上，确定了以 光谱功率分布（SPD [Spectral Power Distribution]） 为基准的混合波三色分离函数： R=∫0∞S(λ)r‾(λ)dλG=∫0∞S(λ)g‾(λ)dλB=∫0∞S(λ)b‾(λ)dλ {\\displaystyle \\begin{aligned} &{\\displaystyle R =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {r}}(\\lambda )\\,d\\lambda } \\\\ &{\\displaystyle G =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {g}}(\\lambda )\\,d\\lambda } \\\\ &{\\displaystyle B =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {b}}(\\lambda )\\,d\\lambda } \\\\ \\end{aligned} } ​​​​​​​R=∫​0​∞​​S(λ)​r​​​(λ)dλ​G=∫​0​∞​​S(λ)​g​​​(λ)dλ​B=∫​0​∞​​S(λ)​b​​​(λ)dλ​​ 其中， 以 r‾(λ){\\overline {r}}(\\lambda )​r​​​(λ) 、 g‾(λ){\\overline {g}}(\\lambda )​g​​​(λ) 、 b‾(λ){\\overline {b}}(\\lambda )​b​​​(λ) 即为基准三原色实验测得的拟合结果的色感函数，存在关系： ∫0∞r‾(λ)dλ=∫0∞g‾(λ)dλ=∫0∞b‾(λ)dλ {\\displaystyle \\int _{0}^{\\infty }{\\overline {r}}(\\lambda )\\,d\\lambda =\\int _{0}^{\\infty }{\\overline {g}}(\\lambda )\\,d\\lambda =\\int _{0}^{\\infty }{\\overline {b}}(\\lambda )\\,d\\lambda } ∫​0​∞​​​r​​​(λ)dλ=∫​0​∞​​​g​​​(λ)dλ=∫​0​∞​​​b​​​(λ)dλ 有 S(λ)S(\\lambda )S(λ) 为目标波长 λ\\lambdaλ 的光谱功率分布函数： S(λ)=Le(λ)θ=2∘≈d2Φe(λ)dAdΩ=dEe(λ)dΩ {\\displaystyle S(\\lambda) = L_{\\mathrm {e}}(\\lambda)_{\\theta=2^{\\circ}} \\approx {\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {e} }(\\lambda)}{\\mathrm {d} A\\,\\mathrm {d} \\Omega }} ={\\frac {\\mathrm {d} E _{\\mathrm {e} }(\\lambda)}{d \\Omega }} } S(λ)=L​e​​(λ)​θ=2​∘​​​​≈​dAdΩ​​d​2​​Φ​e​​(λ)​​=​dΩ​​dE​e​​(λ)​​ SPD 公式式中，LeL_{\\mathrm {e}}L​e​​ 为辐射亮度， Φe\\Phi _{\\mathrm {e}}Φ​e​​ 为辐射通量为， EeE _{\\mathrm {e}}E​e​​ 为辐射照射度。 通过这几个属于 辐射度学（Radiometry） 中的可被测量物理量，指定波长 的光线，就能被相对化表示为： Ray(λ)=C(R,G,B) Ray(\\lambda)= C(R,G,B) Ray(λ)=C(R,G,B) 由于 CIE RGB 所采用的改进后的配色实验，仍然存在亥姆霍兹配色实验里就存在的红光波段的负色匹配。 因此还需要进一步改进才能用于工业应用。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3_4.html":{"url":"Chapter_2/Language/cn/Docs_2_3_4.html","title":"2.3.4 经典三刺激函数（Tristimulus Values Functions）","keywords":"","body":"2.3.4 经典三刺激函数（Tristimulus Values Functions） CIE 在 1931 年同年提出 CIE XYZ 色彩空间，尝试通过人为设计的色感函数 [12] [13]，来避 RGB 的 负色匹配 问题。为了区别于 CIE RGB 中，通过实验测定拟合而得的三原色色感函数。我们将新的函数称为 CIE 三刺激函数（Tristimulus Values Functions） ，用来代替原有 r‾(λ){\\overline {r}}(\\lambda )​r​​​(λ) 、 g‾(λ){\\overline {g}}(\\lambda )​g​​​(λ) 、 b‾(λ){\\overline {b}}(\\lambda )​b​​​(λ) ，记为 x‾(λ){\\overline {x}}(\\lambda )​x​​​(λ) 、 y‾(λ){\\overline {y}}(\\lambda )​y​​​(λ) 、 z‾(λ){\\overline {z}}(\\lambda )​z​​​(λ) 。三个刺激函数对应的刺激曲线如下图： 图 2.3.4-1 CIE 1931 XYZ 采用的三原色色感函数 CIE 在三个刺激函数为基准下，确定了的不同波长光的三刺激值分离函数： X=∫0∞S(λ)x‾(λ)dλY=∫0∞S(λ)y‾(λ)dλZ=∫0∞S(λ)z‾(λ)dλ {\\displaystyle \\begin{aligned} &{\\displaystyle X =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {x}}(\\lambda )\\,d\\lambda } \\\\ &{\\displaystyle Y =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {y}}(\\lambda )\\,d\\lambda } \\\\ &{\\displaystyle Z =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {z}}(\\lambda )\\,d\\lambda } \\\\ \\end{aligned} } ​​​​​​​X=∫​0​∞​​S(λ)​x​​​(λ)dλ​Y=∫​0​∞​​S(λ)​y​​​(λ)dλ​Z=∫​0​∞​​S(λ)​z​​​(λ)dλ​​ 其中， 有 r‾(λ){\\overline {r}}(\\lambda )​r​​​(λ) 、 g‾(λ){\\overline {g}}(\\lambda )​g​​​(λ) 、 b‾(λ){\\overline {b}}(\\lambda )​b​​​(λ) 是将理想刺激值峰值 (μ,σ1,σ2)(\\mu ,\\sigma _{1},\\sigma _{2})(μ,σ​1​​,σ​2​​) ，带入高斯公式所得，这和 RGB 色感函数的拟合有一定的不同。峰值 (μ,σ1,σ2)(\\mu ,\\sigma _{1},\\sigma _{2})(μ,σ​1​​,σ​2​​) 中， μ\\muμ 代表峰值波长， σ1\\sigma _{1}σ​1​​ 代表 μ\\muμ 值左侧生效范围偏移量， σ2\\sigma _{2}σ​2​​ 代表 μ\\muμ 值右侧生效范围偏移量。XYZ 在度量峰值上取用了理想状态值，有： g(λ; μ,σ1,σ2)={exp(−12(λ−μ)2/σ12),λμ,exp(−12(λ−μ)2/σ22),λ≥μ. {\\displaystyle g(\\lambda;\\ \\mu ,\\sigma _{1},\\sigma _{2}) = {\\begin{cases} \\exp {\\bigl (}{-{\\tfrac {1}{2}}(\\lambda-\\mu )^{2}/{\\sigma _{1}}^{2}}{\\bigr )}, &\\lambdag(λ; μ,σ​1​​,σ​2​​)={​exp(−​2​​1​​(λ−μ)​2​​/σ​1​​​2​​),​exp(−​2​​1​​(λ−μ)​2​​/σ​2​​​2​​),​​​λμ,​λ≥μ.​​ 推导而出： x‾(λ)=1.056g(λ; 599.8, 37.9, 31.0)+0.362g(λ; 442.0, 16.0, 26.7)−0.065g(λ; 501.1, 20.4, 26.2)y‾(λ)=0.821g(λ; 568.8, 46.9, 40.5)+0.286g(λ; 530.9, 16.3, 31.1)z‾(λ)=1.217g(λ; 437.0, 11.8, 36.0)+0.681g(λ; 459.0, 26.0, 13.8) {\\displaystyle \\begin{aligned} &{\\displaystyle {\\overline {x}}(\\lambda ) = 1.056g(\\lambda ;\\ 599.8,\\ 37.9,\\ 31.0)+0.362g(\\lambda ;\\ 442.0,\\ 16.0,\\ 26.7)-0.065g(\\lambda ;\\ 501.1,\\ 20.4,\\ 26.2) } \\\\ &{\\displaystyle {\\overline {y}}(\\lambda ) = 0.821g(\\lambda ;\\ 568.8,\\ 46.9,\\ 40.5)+0.286g(\\lambda ;\\ 530.9,\\ 16.3,\\ 31.1) } \\\\ &{\\displaystyle {\\overline {z}}(\\lambda ) = 1.217g(\\lambda ;\\ 437.0,\\ 11.8,\\ 36.0)+0.681g(\\lambda ;\\ 459.0,\\ 26.0,\\ 13.8) } \\\\ \\end{aligned} } ​​​​​​​​x​​​(λ)=1.056g(λ; 599.8, 37.9, 31.0)+0.362g(λ; 442.0, 16.0, 26.7)−0.065g(λ; 501.1, 20.4, 26.2)​​y​​​(λ)=0.821g(λ; 568.8, 46.9, 40.5)+0.286g(λ; 530.9, 16.3, 31.1)​​z​​​(λ)=1.217g(λ; 437.0, 11.8, 36.0)+0.681g(λ; 459.0, 26.0, 13.8)​​ 而 S(λ)S(\\lambda )S(λ) 仍然为为目标波长 λ\\lambdaλ 的光谱功率分布函数： S(λ)=Le(λ)θ=2∘≈d2Φe(λ)dAdΩ=dEe(λ)dΩ {\\displaystyle S(\\lambda) = L_{\\mathrm {e}}(\\lambda)_{\\theta=2^{\\circ}} \\approx {\\frac {\\mathrm {d} ^{2}\\Phi _{\\mathrm {e} }(\\lambda)}{\\mathrm {d} A\\,\\mathrm {d} \\Omega }} ={\\frac {\\mathrm {d} E _{\\mathrm {e} }(\\lambda)}{d \\Omega }} } S(λ)=L​e​​(λ)​θ=2​∘​​​​≈​dAdΩ​​d​2​​Φ​e​​(λ)​​=​dΩ​​dE​e​​(λ)​​ 同样的，指定波长 λ\\lambdaλ 的光线，就能被相对化表示为： Ray(λ)=C(X,Y,Z) Ray(\\lambda)= C(X,Y,Z) Ray(λ)=C(X,Y,Z) 通过以 (X,Y,Z)(X,Y,Z)(X,Y,Z) 代替 (R,G,B)(R,G,B)(R,G,B) 的度量方式，CIE XYZ 解决了负色匹配问题。为了区别于 (R,G,B)(R,G,B)(R,G,B) 光学三原色的称谓，我们将 (X,Y,Z)(X,Y,Z)(X,Y,Z) 称为 三刺激值（Tristimulus Values）。 不过，CIE 1931 RGB & CIE 1931 XYZ 中对于光学三原色标准波长的测量/设置，在现代光学体系中被认为有所偏颇的。在选取基准波长时，1931 RGB 蓝绿取用气态水银（Hg）放电获谱线产生的峰值波长 435.8nm（蓝）和 546.1nm（绿），而红色却因为人眼在对 700nm 波长附近的颜色感知几乎无变化的情况下，人为介入设定为还原配色实验理想值 700nm。这一历史局限性导致的情况，也被基于 RGB 测定而考量的 XYZ 继承了。以致于为两者的 “均色问题” 埋下了伏笔。 即便如此，经典三原色函数和三刺激函数，仍然为现代色彩体系奠定了基础公式。使我们能够 以数理形式转换对应目标波长的目标光波，到相应的度量衡系统 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_3_5.html":{"url":"Chapter_2/Language/cn/Docs_2_3_5.html","title":"2.3.5 现代色彩体系（Modern Color System）","keywords":"","body":"2.3.5 现代色彩体系（Modern Color System） 现代色彩体系（Modern Color System） 的基石，即为 1931 年由前身为国际光度委员会（1900, IPC [International Photometric Commission]）的国际照明委员会（CIE [International Commission on Illumination]) 提出的 CIE RGB & CIE YUV 色彩空间 。 图 2.3.5-1 现代色彩体系（Modern Color System）关系图谱[20] 上图很好的展示了 CIE RGB & CIE XYZ 色彩空间与经典物理学概念和其余色彩空间之间的转换关系。当前被广泛用于流媒体传输和图像颜色信息压缩的 YUV 系列颜色格式（Color Format） ，便是 CIE RGB 体系下的产物。 既然 CIE RGB 配合 CIE XYZ 色彩空间已经能够达成贯通存粹理论与工程应用的边界，那为什么还要引入或设计其余的色彩空间呢？ 其中最典型的问题就在于上文提到的，CIE RGB & CIE XYZ 的“均色问题”。CIE RGB & CIE XYZ 并不能很好的代表人对色彩的直观感受。通俗来讲，就是人对颜色变化的感知是均匀的，而 CIE XYZ 无法将这种主观的均匀感，再不经过参考系转换的情况下，完全等价的表示出来。 所以，CIE 在 1960 年针对性的提出了 “均匀色彩空间”（UCS [Uniform Color Space]）色彩空间 [21] [22]，来尝试进一步整合相关概念并更换规范化体系。UCS 自诞生后便经过了多次迭代，如 1960 UCS、1976 UCS 等。1976 UCS 对于均色度量非常关键，它还有另外一个更为知名的名称，那就是 CIE LUV 色彩空间 。 另一方面，因为受限于设备和技术，很多商业化产品（包括软硬件）根本无法表表示出来全部可见光谱区域。这种情况下，虽然 CIE RGB & CIE XYZ 色彩空间能够起到度量颜色的作用，却不适合用于指定设备来有条件的表示有限的颜色。这也让很多设备供应商，不得不根据自身的软硬件情况，来定制一些色彩模型供给设备使用。诸如 sRGB 就属于此类。 即便如此，在整个现代色彩体系之下，CIE RGB & CIE XYZ 色彩空间仍然是最为通用的度量衡体系。这或许是因为，它们较高的推广程度和便于计算的特性决定的。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4.html":{"url":"Chapter_2/Language/cn/Docs_2_4.html","title":"2.4 色彩的对比","keywords":"","body":"2.4 色彩的对比 自 1931 年 CIE RGB & CIE XYZ 色彩空间 [12] 被提出后，色彩在工程中的对比标准就被统一在了 CIE 逐步采纳、整理和定义的 一系列规格之下 。而 CIE XYZ 色彩空间具有直观客观和正向全可见光色域的特点，使得它更适合被用来作为工业应用的基准体系。所以，我们往往都会将需要处理的颜色数据， 转换到 CIE XYZ 之下进行权衡 。 当然，整个 CIE 色彩空间体系，其提出迭代的过程和当下的统治地位也并不是一蹴而就。这里先对工程上由 CIE 规范的关键概念进行介绍。以便于为我们更好的理解后续章节中，不同色彩空间的提出背景和针对性解决的问题困难，提供帮助。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_1.html":{"url":"Chapter_2/Language/cn/Docs_2_4_1.html","title":"2.4.1 色域（Color Gamut ）","keywords":"","body":"2.4.1 色域（Color Gamut） 色域（Color Gamut） 是一个泛指的广义概念，代表对应色彩空间可被表达的所有颜色构成的区域。不同色彩空间的色域可能是不一样的，所以必须有一个统一的度量衡系统来进行比对。被选中作为度量衡的系统必须能客观的表示颜色的物理信息，并且不受其他主观因素影响。因此，只有设备无关色彩空间可以满足要求。当前最常用的度量衡系统，就是 CIE XYZ 色彩空间。CIE XYZ 色彩空间的色域，涵盖了人眼能够观察到的整个可见光谱范围，被 CIE 称为 CIE 标准观察者色域（CIE Standard Observer Gamut） 。简称 标准色域 。 通常，我们使用 CIE 色度图 来表示 CIE 标准观察者色域。 图 2.4.1-1 CIE 标准观察者色域在 CIE 色度图上的表示 由于 CIE RGB & XYZ 最基本的定义是基于 2° 角 的 视网膜小窝（Fovea Centralis）间隔 来获取的人眼视觉感受效果。因此，通常我们所称的色域以及其相关概念（如色度等），在未明确说明视网膜小窝间隔夹脚的情况下，都是假定指定基于 2° 角的测量结果（ 除 2° 角外，相对常用的还有 10° 角 ）。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_2.html":{"url":"Chapter_2/Language/cn/Docs_2_4_2.html","title":"2.4.2 色度（Chroma）& 色度平面（Chroma Plane）& 色度图（Chroma Diagram）","keywords":"","body":"2.4.2 色度（Chroma）& 色度平面（Chroma Plane）& 色度图（Chroma Diagram） 色度（Chroma｜Chromaticity） 是一个泛指的广义概念，是对除 光亮度（Luminance） 之外，由色调和饱和度或其衍生参数组成的颜色信息的统称。现代工程上的色度概念，最早是在 CIE XYZ 色彩空间对标准色度图的推导过程中引入的。 CIE XYZ 将色度定义为：XYZ 色彩空间内代表颜色的三维向量，由指定平面切割和归一化后，沿 Z 轴垂直方向在 XY 轴平面上二维投影向量。这个用于切割降维和压缩参数范围的平面，被称为 色度平面（Chroma Plane｜Chromaticity Plane） 。整个色彩空间色域在 XY 轴平面的二维投影，被称为 CIE xyY 色度图（CIE xyY Chromaticity Diagram） ，简称 色度图（Chroma Diagram） 。 为什么是 xyY 色度图？因为决定颜色的除了 xy 代表色度外，还需要光亮度（Luminance）关键量。CIE XYZ 直接取用颜色在 XYZ 色彩空间里的 Y 方向分量，代替指代光亮度。 图 2.4.2-1 CIE 色度平面切割标准色域并投影色度图的示意图 可见，使用色度的色彩空间，色度的量化和其内部参数的选取息息相关。不同的色彩空间在色度的定义上，存在着表述上的不同。在大多数情况下，CIE XYZ 之后的色彩空间，都会取用 CIE 测定的 700nm 波长标准红点（Red Point） 为 基准轴正轴方向 ，来构建自身的色度参数。究其原因是，相同的基准可以便于将自身色域转换到 CIE XYZ 统一度量衡上对比。所以，色度也常常被直接用 CIE XYZ 色彩空间的定义来表示。 CIE XYZ 色彩空间取用 [X=1, Y=1, Z=1] 构成的三棱锥底面所在平面为色度平面。该平面上的 XYZ 坐标系内点存在关系： Plane:{X+Y+Z=1} {\\displaystyle \\begin{aligned} &{\\displaystyle Plane :\\{ {X+Y+Z} = 1 \\}} \\\\ \\end{aligned} } ​​​​​Plane:{X+Y+Z=1}​​ 记 XYZ 色彩空间中存在颜色 (X,Y,Z)(X, Y, Z)(X,Y,Z) 在 XY 平面的投影为 (x,y)(x, y)(x,y) ，则有： Set: (x+y+z)=1   Then:Chromaticity:{(x,y)=(XX+Y+Z,YX+Y+Z)}Luminance:{Y} {\\displaystyle \\begin{aligned} &Set:\\ (x+y+z) = 1 \\ \\ \\ {Then:} \\\\ &{\\displaystyle Chromaticity:\\{ (x,y) = ({\\frac {X}{X+Y+Z}}, {\\frac {Y}{X+Y+Z}}) \\} } \\\\ &{\\displaystyle Luminance:\\{ Y \\} } \\\\ \\end{aligned} } ​​​​​​​Set: (x+y+z)=1   Then:​Chromaticity:{(x,y)=(​X+Y+Z​​X​​,​X+Y+Z​​Y​​)}​Luminance:{Y}​​ 在已知 (x,y,Y)(x, y, Y)(x,y,Y) 的情况下，也可以反向获得 (X,Y,Z)(X, Y, Z)(X,Y,Z) ： (X,Y,Z)=(Yy⋅x,  Y,  Yy⋅(1−x−y) ) {\\displaystyle \\begin{aligned} (X, Y, Z) &= ({\\frac {Y}{y}} \\cdot x, \\ \\ Y, \\ \\ {\\frac {Y}{y}} \\cdot (1-x-y) \\ ) \\end{aligned} } ​(X,Y,Z)​​​=(​y​​Y​​⋅x,  Y,  ​y​​Y​​⋅(1−x−y) )​​ 所以，只要根据 (x,y,Y)(x, y, Y)(x,y,Y) 值，就能将色度图上的颜色还原到 XYZ 实际坐标。而其中的 (x,y)(x, y)(x,y) 值，就是 CIE 中颜色色度的表示形式。 那么在颜色能够被统一描述的前提下，颜色间的差异怎么来说明呢？ Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_3.html":{"url":"Chapter_2/Language/cn/Docs_2_4_3.html","title":"2.4.3 色差（Chromatic Aberration）","keywords":"","body":"2.4.3 色差（Chromatic Aberration） 色差（Chromatic Aberration） 是一个相对概念，指的是两个色度不同的颜色之间的差异。 广义色差（gCA [General Chromatic Aberration]） 不限定用于对比的两个颜色对应的色调，此时的色差计算的是颜色色度的差异。 狭义色差（sCA [Special Chromatic Aberration]） 则要求对比的两个颜色具有相同的色调，此时的色差计算的仅仅是颜色饱和度的变化。因此，狭义色差可以被认为是广义色差的一种特殊情况 。 色差的计算为了简洁，通常都选择使用欧式距离表示。记对比的两颜色分别为 C1C_1C​1​​ 、 C2C_2C​2​​ ，色差为 CCC ，广义色差为 ΔC\\Delta CΔC ，有： C={gCA:{ΔC=ΔH2+ΔS2≈distance(C1, C2)}sCA:{ΔC∣(ΔH=0)=ΔS2=ΔS≈range(C1, C2)} {\\displaystyle \\begin{aligned} &C={ \\begin{cases} &{\\displaystyle gCA: \\{\\Delta C ={\\sqrt {\\Delta H ^{2} + \\Delta S ^{2} }} \\approx {distance} (C_1,\\ C_2)} \\} \\\\ &{\\displaystyle sCA: \\{ {\\Delta C}|_{({\\Delta H = 0})} = {\\sqrt {\\Delta S ^{2}}} = \\Delta S \\approx {range} (C_1,\\ C_2) \\} } \\end{cases}} \\\\ \\end{aligned} } ​​​​​C={​​​​​gCA:{ΔC=√​ΔH​2​​+ΔS​2​​​​​≈distance(C​1​​, C​2​​)}​sCA:{ΔC∣​(ΔH=0)​​=√​ΔS​2​​​​​=ΔS≈range(C​1​​, C​2​​)}​​​​ 带入 CIE XYZ 规则，色差的表示就可以直接以色度 (x,y)(x, y)(x,y) 计算了： C=Δx2+Δy2 {\\displaystyle \\begin{aligned} &C = {\\sqrt {\\Delta x ^{2} + \\Delta y ^{2} }} \\\\ \\end{aligned} } ​​​​​C=√​Δx​2​​+Δy​2​​​​​​​ 替换了色调饱和度参数，使广义狭义在公式层面得到了统一。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_4.html":{"url":"Chapter_2/Language/cn/Docs_2_4_4.html","title":"2.4.4 色温（Color Temperature）& 相关色温（Correlated Color Temperature）","keywords":"","body":"2.4.4 色温（Color Temperature）& 相关色温（Correlated Color Temperature） 我们在之前讲述配色函数的理论基础时，已经阐述过色温的概念了。这里做一下回顾。 色温（Color Temperature） 是由物体本身的黑体辐射决定的一个物理量，计量单位为 K（开尔文温度）。它被定义为，绝对黑体从绝对零度（－273.15℃）开始加温后所呈现出的颜色。 CIE 于 1960 UCS 色彩空间 中引入了色温的表示，并根据工业光源特性引入了 相关色温（CCT [Correlated Color Temperature]） 来表示 一系列物理（辐射度）色温的近似值 。 色温与 1960 UCS 快速计算 记色温 TTT 有对应复合波长 λT\\lambda_Tλ​T​​ ，色温 TTT 在 CIE XYZ 色彩空间上的颜色为 CT(XT,YT,ZT)C_T(X_T,Y_T,Z_T)C​T​​(X​T​​,Y​T​​,Z​T​​) ，则根据前文中对于配色函数理论基础的推导，将波长 λT\\lambda_Tλ​T​​ 带入经典三刺激函数，我们有： CT=FXYZ (λT) ,   Q=∫0∞S(λ)dλ≈Lv⋅∑360nm780nmuλIeλ=Lv⋅u(λT)XT=∫0∞S(λ)x‾(λ)dλ≈Lv⋅∑360nm780nm(uλIeλ⋅x‾(λ))YT=∫0∞S(λ)y‾(λ)dλ≈Lv⋅∑360nm780nm(uλIeλ⋅y‾(λ))ZT=∫0∞S(λ)z‾(λ)dλ≈Lv⋅∑360nm780nm(uλIeλ⋅z‾(λ)) {\\displaystyle \\begin{aligned} &C_T = F_{XYZ\\ }(\\lambda_T) \\ , \\ \\ \\ Q = \\int _{0}^{\\infty }S(\\lambda )\\,d\\lambda \\approx {L_v} \\cdot \\sum _{360nm} ^{780nm} {\\frac {u_{\\lambda}}{I_e}} \\lambda = {L_v} \\cdot {u (\\lambda_T)} \\\\ &X_T =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {x}}(\\lambda )\\,d\\lambda \\approx {L_v} \\cdot \\sum _{360nm} ^{780nm} ({\\frac {u_{\\lambda}}{I_e}} \\lambda \\cdot {\\overline {x}}(\\lambda )) \\\\ &Y_T =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {y}}(\\lambda )\\,d\\lambda \\approx {L_v} \\cdot \\sum _{360nm} ^{780nm} ({\\frac {u_{\\lambda}}{I_e}} \\lambda \\cdot {\\overline {y}}(\\lambda )) \\\\ &Z_T =\\int _{0}^{\\infty }S(\\lambda )\\,{\\overline {z}}(\\lambda )\\,d\\lambda \\approx {L_v} \\cdot \\sum _{360nm} ^{780nm} ({\\frac {u_{\\lambda}}{I_e}} \\lambda \\cdot {\\overline {z}}(\\lambda )) \\\\ \\end{aligned} } ​​​​​​​​C​T​​=F​XYZ ​​(λ​T​​) ,   Q=∫​0​∞​​S(λ)dλ≈L​v​​⋅​360nm​∑​780nm​​​I​e​​​​u​λ​​​​λ=L​v​​⋅u(λ​T​​)​X​T​​=∫​0​∞​​S(λ)​x​​​(λ)dλ≈L​v​​⋅​360nm​∑​780nm​​(​I​e​​​​u​λ​​​​λ⋅​x​​​(λ))​Y​T​​=∫​0​∞​​S(λ)​y​​​(λ)dλ≈L​v​​⋅​360nm​∑​780nm​​(​I​e​​​​u​λ​​​​λ⋅​y​​​(λ))​Z​T​​=∫​0​∞​​S(λ)​z​​​(λ)dλ≈L​v​​⋅​360nm​∑​780nm​​(​I​e​​​​u​λ​​​​λ⋅​z​​​(λ))​​ 上式就是色温 TTT 在 CIE XYZ 上的表达，这样的表示不够简练。 如果能够找到一个由 XYZ 衍生的色彩空间，能够直接由色温 TTT 值本身计算相应的颜色就好了。借用此空间，我们就能够依据该色彩空间与 XYZ 之间的联系，快速转换色温在该色彩空间上的表示到 XYZ 内，从而间接起到在 XYZ 上精简色温计算的目的。 1960年，CIE 采用了来自柯达实验室的 大卫·麦克亚当（David Lewis MacAdam，1910 - 1998） 在 迪恩·布鲁斯特·朱迪（Deane Brewster Judd，1900 - 1972） 的研究上提出的简化色度、色温与相关色温表示方案，并将方案应用在了 CIE 1931 XYZ 色彩空间上作为对 CIE 1931 XYZ 体系的补充。1960 UCS 对 XYZ 色彩空间的观察角度进行了透视变换，从不同的方向获取了 XYZ 色度平面的投影，以此构建了自身的色度特征。 记 CIE 1960 UCS 中颜色为 (U,V,W)(U, V, W)(U,V,W) ，有： (X, Y, Z)=(32U,   Y,   32U−3V+2W)(U,V,W)=(23X,   Y,   −X+3Y+2Z2) {\\displaystyle \\begin{aligned} &(X,\\ Y,\\ Z) = ({\\tfrac {3}{2}} U, \\ \\ \\ Y, \\ \\ \\ {\\tfrac {3}{2}} U -3V + 2W ) \\\\ &(U, V, W) = ({\\tfrac {2}{3}} X, \\ \\ \\ Y, \\ \\ \\ {\\frac {-X +3Y + 2Z}{2}} ) \\end{aligned} } ​​​​​(X, Y, Z)=(​2​​3​​U,   Y,   ​2​​3​​U−3V+2W)​(U,V,W)=(​3​​2​​X,   Y,   ​2​​−X+3Y+2Z​​)​​ 取 (U,V,W)(U, V, W)(U,V,W) 对应色度为 (u,v)(u, v)(u,v) 。存在： (u,v)=(4x12y−2x+3, 6y12y−2x+3)(x,y)=(3u2u−8v+4  , 2v2u−8v+4 ) {\\displaystyle \\begin{aligned} &(u, v) = ({\\frac {4x}{12y-2x+3}}, \\ {\\frac {6y}{12y-2x+3}}) \\\\ &(x, y) = ({\\frac {3u}{2u-8v+4}}\\ \\ , \\ {\\frac {2v}{2u-8v+4}} \\ ) \\end{aligned} } ​​​​​(u,v)=(​12y−2x+3​​4x​​, ​12y−2x+3​​6y​​)​(x,y)=(​2u−8v+4​​3u​​  , ​2u−8v+4​​2v​​ )​​ 显然，颜色表示在 1960 UCS 和 1931 XYZ 间的坐标转换仅为 线性变化，计算非常便捷。 1960 UCS 有什么优势能让 CIE 大动干戈呢？关键在于 UCS 能够以 切比雪夫近似值 [27] ，逼近范围在 (1000K, 15000K)(1000K, \\ 15000K)(1000K, 15000K) 的色温对应的色度 (u¯(T), v¯(T))(\\bar u(T),\\ \\bar v(T))(​u​¯​​(T), ​v​¯​​(T)) 取值，且控制在 ∣u−u¯∣8⋅10−5\\left|u-{\\bar {u}}\\right|∣u−​u​¯​​∣8⋅10​−​​5 和 ∣v−v¯∣9⋅10−5\\left|v-{\\bar {v}}\\right|∣v−​v​¯​​∣9⋅10​−​​5 的误差范围。如此误差可称得上相当精确了。有： u¯(T)≈0.860117757+1.54118254⋅10−4⋅T+1.28641212⋅10−7⋅T21+8.42420235⋅10−4⋅T+7.08145163⋅10−7⋅T2v¯(T)≈0.317398726+4.22806245⋅10−5⋅T+4.20481691⋅10−8⋅T21−2.89741816⋅10−5⋅T+1.61456053⋅10−7⋅T2 {\\displaystyle \\begin{aligned} &{\\bar {u}}(T)\\approx {\\frac {0.860117757+1.54118254\\cdot 10^-4\\cdot T+1.28641212\\cdot 10^-7\\cdot T^{2}} {1+8.42420235\\cdot 10^-4\\cdot T+7.08145163\\cdot 10^-7\\cdot T^{2}}} \\\\ &{\\bar {v}}(T)\\approx {\\frac {0.317398726+4.22806245\\cdot 10^-5\\cdot T+4.20481691\\cdot 10^-8\\cdot T^{2}} {1-2.89741816\\cdot 10^-5\\cdot T+1.61456053\\cdot 10^-7\\cdot T^{2}}} \\end{aligned} } ​​​​​​u​¯​​(T)≈​1+8.42420235⋅10​−​​4⋅T+7.08145163⋅10​−​​7⋅T​2​​​​0.860117757+1.54118254⋅10​−​​4⋅T+1.28641212⋅10​−​​7⋅T​2​​​​​​v​¯​​(T)≈​1−2.89741816⋅10​−​​5⋅T+1.61456053⋅10​−​​7⋅T​2​​​​0.317398726+4.22806245⋅10​−​​5⋅T+4.20481691⋅10​−​​8⋅T​2​​​​​​ 上式也被称为 UCS 色温函数。以色温函数计算色度 (u,v)(u, v)(u,v) ，再通过固定三刺激值的 Y=Y0Y = Y_0Y=Y​0​​ 来快速的返向计算色温 TTT 的 (X,Y,Z)(X, Y, Z)(X,Y,Z) 表示。有： (X, Y, Z)=(Y0⋅3u2v,  Y0,  Y0⋅−u−10v+42v) {\\displaystyle \\begin{aligned} &(X,\\ Y,\\ Z) = (Y_0 \\cdot {\\tfrac {3u}{2v}} , \\ \\ Y_0, \\ \\ Y_0 \\cdot {\\tfrac {-u-10v+4}{2v}}) \\end{aligned} } ​​​​(X, Y, Z)=(Y​0​​⋅​2v​​3u​​,  Y​0​​,  Y​0​​⋅​2v​​−u−10v+4​​)​​ 基于这一点，到现在为止 1960 UCS 仍然是色温及相关色温的最佳计算工具。 CIE 利用 UCS 特性，将一系列物理色温的色彩学近似概念引入了 CIE 系统。 普朗克轨迹（Planckian Locus） 如果取 TTT 范围为 (0, ∞)(0, \\ \\infty)(0, ∞) 开尔文，那么由 TTT 在指定色彩空间上的所有对应颜色所构成的轨迹曲线，就被称为 普朗克轨迹（Planckian Locus） ，也被称为 黑体轨迹（Blackbody Locus） 。换而言之，通过将色温 带入色温函数所求的的色度，都在普朗克轨迹上。所以，我们只需要将选定范围色温带入 UCS 色温函数，就能将普朗克轨迹表示到 UCS 色度图上。 图 2.4.4-1 普朗克轨迹在 UCS 色度图上的表示 把 UCS 色温函数转到 XYZ 的色度表示，就有： (x¯(T),y¯(T))=(3u¯(T)2u¯(T)−8v¯(T)+4  , 2v¯(T)2u¯(T)−8v¯(T)+4 ) {\\displaystyle \\begin{aligned} &({\\bar {x}}(T), {\\bar {y}}(T)) = ({\\frac {3{\\bar {u}}(T)}{2{\\bar {u}}(T)-8{\\bar {v}}(T)+4}}\\ \\ , \\ {\\frac {2{\\bar {v}}(T)}{2{\\bar {u}}(T)-8{\\bar {v}}(T)+4}} \\ ) \\end{aligned} } ​​​​(​x​¯​​(T),​y​¯​​(T))=(​2​u​¯​​(T)−8​v​¯​​(T)+4​​3​u​¯​​(T)​​  , ​2​u​¯​​(T)−8​v​¯​​(T)+4​​2​v​¯​​(T)​​ )​​ 此表达式，即色温在 CIE 色度图上的普朗克轨迹函数（Planckian Locus Functions） ，也被称为 CIE 色温函数 。效果如下： 图 2.4.4-2 普朗克轨迹在 CIE 色度图上的表示 含有普朗克轨迹的 CIE 色度图，让我们能够直观的表现自然辐射源在 CIE 标准下的色彩特点。但是人眼对色温的感受并不会如此精准，很多在感知上近似物理色温的颜色，实际色度却在普朗克轨迹外。 如何在色温基础上引入人眼感受特征呢？相信已经有读者注意到图中，与普朗克轨迹垂直或交叉的直线了。这就是解决人眼感受问题而用到相关色温和等色温线工具。作为 CIE 体系内的标准度量衡工具，相关色温和等色温线必须具有体系内完全可求的特点，即：从指定色度推算相关色温，和从相关色温推算对应色度的能力。 那么，什么是相关色温？ 相关色温（CCT）的等色温线（CCT Isotherms）与麦克亚当法 相关色温（CCT [Correlated Color Temperature]） 是指在同等光亮度情况下，于感知上趋同于选定色温的范围内颜色的集合 [28] [29]。通常我们会直接以选定的色温参考系的温度，来代替表示相关色温的温度。从主观角度理解，色温与相关色温在颜色上并无差异，或差异无法被明显察觉。 而由选定色温与其相关色温共同构成色彩空间内的连线，就被称为 等色温线（CCT Isotherms），有时也会被简称为 等温线 [29]。 相关色温在 CIE 中依赖于等温线表示，而等温线依赖于对普朗克轨迹。CIE 采用麦克亚当建议的测量方式，以两个视觉恰克区分临界点间的跨度为单位麦勒德（ mrdmrdmrd [Maillard]），记为 mrdmrdmrd 。有麦勒德和色温单位开尔文间换算关系： mrd=106Tc mrd = {\\tfrac {10^6}T_c } mrd=​T​​10​6​​​​​c​​ CIE 以麦勒德为度量，来等分普朗克轨迹。例如，取 1 mrd=106K1 \\ mrd = 10^6 K1 mrd=10​6​​K 就指以 106K10^6 K10​6​​K 为分割步长，取 500 mrd=2000 K500 \\ mrd = 2000\\ K500 mrd=2000 K 就指以 2000 K2000\\ K2000 K 为分割步长。具体麦勒德的选取，依赖于实际应用场景下，对相关色温配色精确程度的要求。麦勒德取值越小，精确程度越低；反之，麦勒德取值越大，精确程度越高；即精确度与麦勒德成正比关系。可知当麦勒德取值趋近于 ∞ mrd\\infty \\ mrd∞ mrd 时，整个普朗克轨迹不再分割而是完全连续 。 那么在分割后，CIE 怎么计算 CCT 呢？麦克亚当采用的是垂直取值法，即从当前想要知道相关色温的颜色在 UCS 色度图上表示位置处，向 UCS 色度图中的普朗克曲线做垂线。做得垂线与普朗克轨迹交点处对应的色温，就是当前相关色温对应的物理色温。 记目标相关色温 TcctT_{cct}T​cct​​ 的色度为 (u¯(Tcct), v¯(Tcct))(\\bar u(T_{cct}),\\ \\bar v(T_{cct}))(​u​¯​​(T​cct​​), ​v​¯​​(T​cct​​)) ， TcctT_{cct}T​cct​​ 对应的物理色温 TcT_cT​c​​ 的色度为 (u¯(Tc), v¯(Tc))(\\bar u(T_c),\\ \\bar v(T_c))(​u​¯​​(T​c​​), ​v​¯​​(T​c​​)) ，那么在 麦克亚当法（MacAdam's CCT method） 之下，我们需要计算： cct⃗⋅c⃗′=vector (u¯(Tcct)−u¯(Tc), v¯(Tcct−v¯(Tc))⋅vector (u¯′(Tcct), v¯′(Tcct)=0 \\vec{cct} \\cdot \\vec{c}' = vector\\ (\\bar u(T_{cct}) - \\bar u(T_c),\\ \\bar v(T_{cct} - \\bar v(T_c)) \\cdot vector\\ (\\bar u'(T_{cct}) ,\\ \\bar v'(T_{cct}) = 0 ​cct​⃗​​⋅​c​⃗​​​′​​=vector (​u​¯​​(T​cct​​)−​u​¯​​(T​c​​), ​v​¯​​(T​cct​​−​v​¯​​(T​c​​))⋅vector (​u​¯​​​′​​(T​cct​​), ​v​¯​​​′​​(T​cct​​)=0 式中 cct⃗\\vec{cct}​cct​⃗​​ 为从交点指向色温色度的向量， c⃗′\\vec{c}'​c​⃗​​​′​​ 为普朗克轨迹对应交点色温处的导数（即切线方向），代入色温函数和欲求相关色温色度，所得 TcT_cT​c​​ 即为所求。 由色度推算相关色温（CCT）的罗伯逊算法 使用麦克亚当法计算 CCT 不太好定位交点求值，因此 艾伦·罗伯逊（Alan R. Robertson） 在 1968年提出了另一种快速算法：选取两个普朗克轨迹上的色温，以线性插值方法近似计算目标相关色温 [30]。这一方法也被称为 罗伯逊相关色温算法（Robertson's CCT method） 。 图 2.4.4-3 罗伯逊相关色温算法（Robertson's CCT method）示意图 如图 2.4.4-3 所示， (uT,vT)(u_T, v_T)(u​T​​,v​T​​) 代表目标相关色温 TcT_cT​c​​ 色度， TiT_iT​i​​ 、 Ti+1T_{i+1}T​i+1​​ 代表普朗克轨迹上以指定麦勒德分割的量个最近相邻色温， did_id​i​​ 、 di+1d_{i+1}d​i+1​​ 为 (uT,vT)(u_T, v_T)(u​T​​,v​T​​) 与 TiT_iT​i​​ 、 Ti+1T_{i+1}T​i+1​​ 所在等温线的垂直距离， θ1\\theta _1θ​1​​ 、 θ2\\theta _2θ​2​​ 为延 (uT,vT)(u_T, v_T)(u​T​​,v​T​​) 所做等温线与 TiT_iT​i​​ 、 Ti+1T_{i+1}T​i+1​​ 所在等温线的交点处夹脚。有罗伯逊相关色温公式就可以如下表示： 1Tc=1Ti+θ1θ1+θ2(1Ti+1−1Ti) \\frac{1}T_c=\\frac{1}{T_i}+\\frac{\\theta_1}{\\theta_1+\\theta_2} \\left( \\frac{1}{T_{i+1}} - \\frac{1}{T_i} \\right) ​T​​1​​​c​​=​T​i​​​​1​​+​θ​1​​+θ​2​​​​θ​1​​​​(​T​i+1​​​​1​​−​T​i​​​​1​​) 可以等价转换为 did_id​i​​ 、 di+1d_{i+1}d​i+1​​ 表示 θ1\\theta _1θ​1​​ 、 θ2\\theta _2θ​2​​ ，即： 1Tc=1Ti+didi−di+1(1Ti+1−1Ti) \\frac{1}T_c=\\frac{1}{T_i}+\\frac{d_i}{d_i-d_{i+1}} \\left( \\frac{1}{T_{i+1}} - \\frac{1}{T_i} \\right) ​T​​1​​​c​​=​T​i​​​​1​​+​d​i​​−d​i+1​​​​d​i​​​​(​T​i+1​​​​1​​−​T​i​​​​1​​) 而 did_id​i​​ 、 di+1d_{i+1}d​i+1​​ 在分割用麦勒德 mrdmrdmrd 固定的情况下，可以表示为： di=(vT−vi)−mrd⋅(uT−ui)1+mrd2 d_i=\\frac{ (v_T-v_i)-mrd \\cdot (u_T-u_i) }{\\sqrt {1+mrd^2}} d​i​​=​√​1+mrd​2​​​​​​​(v​T​​−v​i​​)−mrd⋅(u​T​​−u​i​​)​​ 带入上式可知： Tc=(di−di+1)⋅Ti⋅Ti+1di⋅Ti−di+1⋅Ti+1 T_c = \\frac{ (d_i-d_{i+1}) \\cdot T_i \\cdot T_{i+1}}{d_i \\cdot T_i -d_{i+1} \\cdot T_{i+1}} T​c​​=​d​i​​⋅T​i​​−d​i+1​​⋅T​i+1​​​​(d​i​​−d​i+1​​)⋅T​i​​⋅T​i+1​​​​ 显然 罗伯逊相关色温算法虽然化解了麦克亚当法的交点坐标问题，但也不够简便 。在不追求过度精度的情况下，是否存在一种足够快捷的算法来达成相关色温的近似取值呢？这便有了 相关色温的快速逼近法 。 由色度推算相关色温（CCT）的麦卡米快速逼近算法 1992年，卡尔文·麦卡米（Calvin S. McCamy） 以选定参照点后使用 三次厄尔密样条（Cubic Hermite Spline） 的方法，得到了一组能够在 CIE XYZ 上直接使用的快速逼近公式，进一步简化了相关色温的取值过程 [31] 。为了纪念麦卡米的贡献，CIE 将此快速算法称为 麦卡米算法（McCamy's CCT method） 。 由于三次厄尔密样条的准确性依赖于参考点选取的特点。麦卡米优化了 肯尼斯·凯利（Kenneth L. Kelly） 的采样实验，取用了 XYZ 色彩空间上，能够使求得逼近函数更贴近于范围内实际值的关键色度 (0.3320, 0.1858)(0.3320,\\ 0.1858)(0.3320, 0.1858) 作为参考点 [32] 。他将这个关键参考点称为 “震中（Epicenter）” 。 如果记震中为 (xe,ye)(x_e, y_e)(x​e​​,y​e​​) 则 (xe=0.3320, ye=0.1858)(x_e = 0.3320,\\ y_e = 0.1858) (x​e​​=0.3320, y​e​​=0.1858) ，记 (x,y)(x, y)(x,y) 为指定希望求得相关色温 TcT_cT​c​​ 的颜色色度。取 nnn 使得： n=x−xey−ye {n = \\frac {x-x_e}{y-y_e} } n=​y−y​e​​​​x−x​e​​​​ 有麦卡米算法公式： Tc=McCamy(n)=−449⋅n3+3525⋅n2−6823.3⋅n+5520.33 {\\displaystyle T_c = McCamy(n) = -449 \\cdot n^{3} + 3525 \\cdot n^{2}-6823.3 \\cdot n + 5520.33} T​c​​=McCamy(n)=−449⋅n​3​​+3525⋅n​2​​−6823.3⋅n+5520.33 因为只采用了单点的方式逼近 ，算法在保证 精确度的条件下，仅能用于计算物理色温接近于 间的相关色温。 1999年，哈维尔·埃尔南德斯·安德烈斯（Javier Hernández-Andrés） 等人提出的，“在麦卡米算法基础上，采用指数函数的形式以提升公式适用范围” 的改进建议 [33] 。哈维尔等人在论文中给出了两段测量结果，将估值范围扩展到了 [3000 K, 8⋅105 K][3000 \\ K, \\ 8 \\cdot 10^5\\ K][3000 K, 8⋅10​5​​ K] 。其改进的指数估值函数为： Tc=A0+A1⋅e−nT1+A2⋅e−nT2+A3⋅e−nT3 {\\displaystyle T_c = A_{0}+A_{1} \\cdot e^{\\frac{-n}{T_{1}}} + A_{2} \\cdot e^{\\frac{-n}{T_{2}}} + A_{3} \\cdot e^{\\frac{-n}{T_{3}}} } T​c​​=A​0​​+A​1​​⋅e​​T​1​​​​−n​​​​+A​2​​⋅e​​T​2​​​​−n​​​​+A​3​​⋅e​​T​3​​​​−n​​​​ 对应生效范围被分为两段，nnn 值计算同麦卡米，其余固定参照点参数取如下值： 图 2.4.4-4 改进指数估值法的适用范围[33] 指数改进版虽然提升了估值范围，但同时也提升了算法的复杂度 。大部分工程相关色温都在传统麦卡米算法适用范围内，这使得改进方法有些鸡肋。相较于使用范围广但复杂度高的算法，传统麦卡米算法就能胜任，这也是 CIE 暂时没有采纳此建议的原因。不过，CIE 将其列入为对传统麦卡米更广域范围的补充方法中，以被特殊情况使用。 在从已知 CIE 色度获取相关色温的手段已经基本够用的情况下，剩下相对急迫的问题，就是找到从已知相关色温反向求其在 CIE 色度的快速算法了。 由相关色温（CCT）推算色度的反向逼近算法 由相关色温反向计算色度的算法，在 2002年和 2006年前并没有太多突破。一方面是因为，如果已知相关色温，那么我们完全可以将其等效为物理色温带入 CIE 色温函数中，直接以求得的物理色温的色度代替；另一方面，也的确没有找到除了直接使用反向求解外的，在满足精度条件的同时还能降低计算复杂度的近似算法来解决这一问题。 2002年，由 康奉顺（Bongsoon Kang）等人 利用相关色温等温线的特点，用双步逐级进行的三次厄尔密样条差值法，构建了一组误差可接受的求解方程 [34] 。此方法在 2006年，经过金敬熙（Kyounghae Kim）等人的进一步测量和推导后，形成了现有的由 TcT_cT​c​​ 求色度 (x,y)(x, y)(x,y) 的快速近似值算法 [34]： x={−0.2661239⋅109Tc3−0.2343589⋅106Tc2+0.8776956⋅103Tc+0.179910   1667K≤Tc≤4000K−3.0258469⋅109Tc3+2.1070379⋅106Tc2+0.2226347⋅103Tc+0.240390   4000K≤Tc≤25000Ky={−1.1063814⋅x3−1.34811020⋅x2+2.18555832⋅x−0.20219683   1667K≤Tc≤2222K−0.9549476⋅x3−1.37418593⋅x2+2.09137015⋅x−0.16748867   2222K≤Tc≤4000K+3.0817580⋅x3−5.87338670⋅x2+3.75112997⋅x−0.37001483   4000K≤Tc≤25000K {\\displaystyle \\begin{aligned} x &= { \\begin{cases} -0.2661239 \\cdot {\\frac {10^9}{T_c^3}} -0.2343589 \\cdot {\\frac {10^6}{T_c^2}} +0.8776956 \\cdot {\\frac {10^3}T_c} +0.179910 \\ \\ \\ &1667{\\text{K}}\\leq T_c\\leq 4000{\\text{K}}\\\\ -3.0258469 \\cdot {\\frac {10^9}{T_c^3}} +2.1070379 \\cdot {\\frac {10^6}{T_c^2}} +0.2226347 \\cdot {\\frac {10^3}T_c} +0.240390 \\ \\ \\ &4000{\\text{K}}\\leq T_c\\leq 25000{\\text{K}} \\end{cases} } \\\\ y &= { \\begin{cases} -1.1063814 \\cdot x^{3} -1.34811020 \\cdot x^{2} +2.18555832 \\cdot x -0.20219683 \\ \\ \\ &1667{\\text{K}}\\leq T_c\\leq 2222{\\text{K}}\\\\ -0.9549476 \\cdot x^{3} -1.37418593 \\cdot x^{2} +2.09137015 \\cdot x -0.16748867 \\ \\ \\ &2222{\\text{K}}\\leq T_c\\leq 4000{\\text{K}}\\\\ +3.0817580 \\cdot x^{3} -5.87338670 \\cdot x^{2} +3.75112997 \\cdot x -0.37001483 \\ \\ \\ &4000{\\text{K}}\\leq T_c\\leq 25000{\\text{K}} \\end{cases} } \\\\ \\end{aligned} } ​x​y​​​​=​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​−0.2661239⋅​T​c​3​​​​10​9​​​​−0.2343589⋅​T​c​2​​​​10​6​​​​+0.8776956⋅​T​​10​3​​​​​c​​+0.179910   ​−3.0258469⋅​T​c​3​​​​10​9​​​​+2.1070379⋅​T​c​2​​​​10​6​​​​+0.2226347⋅​T​​10​3​​​​​c​​+0.240390   ​​​1667K≤T​c​​≤4000K​4000K≤T​c​​≤25000K​​​=​⎩​⎪​⎨​⎪​⎧​​​−1.1063814⋅x​3​​−1.34811020⋅x​2​​+2.18555832⋅x−0.20219683   ​−0.9549476⋅x​3​​−1.37418593⋅x​2​​+2.09137015⋅x−0.16748867   ​+3.0817580⋅x​3​​−5.87338670⋅x​2​​+3.75112997⋅x−0.37001483   ​​​1667K≤T​c​​≤2222K​2222K≤T​c​​≤4000K​4000K≤T​c​​≤25000K​​​​ 但是这一套算法，仍然无法代替非精确场景下，直接通过对应物理色温计算普朗克轨迹上色度的方法实用。因此，CIE 也和麦卡米指数逼近的情况一样，仅是将其列入了相关色温在需求精确值情况下的补充。这里有所了解即可。 时至今日，此方向也还在等待更 SOTA 的突破 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_5.html":{"url":"Chapter_2/Language/cn/Docs_2_4_5.html","title":"2.4.5 标准光源（Standard Illuminants）& 白点（White Point）","keywords":"","body":"2.4.5 标准光源（Standard Illuminants）& 白点（White Point） 相比其他几个概念，色温 无疑要“物理”的多。所以在工业体系中，由色温衍生出的指标有着更多的应用。CIE 以色温参考，从 1960 年后定义了一系列指定色温的可见光光源点（族）来规范工业用光标准，被称为 标准光源（Standard Illuminants）*。 CIE 标准光源主要分为由 A 到 F，外加 LED 的 7 个类别，分别是： A类光源点，代表相关色温 Tc≈2856 KT_{c} \\approx 2856 \\ KT​c​​≈2856 K 的白炽发光体； B类光源点，代表相关色温 Tc≈4874 KT_{c} \\approx 4874 \\ KT​c​​≈4874 K 的正午日光； C类光源点，代表相关色温 Tc≈6774 KT_{c} \\approx 6774 \\ KT​c​​≈6774 K 的平均日光； D类光源族，代表标准日光源，其存在多个指标，常用有（ D50、D55、D60、D65、D75 ）； E类光源点，代表相关色温 Tc≈5455 KT_{c} \\approx 5455 \\ KT​c​​≈5455 K 的均匀发光体； F类光源族，代表荧光发光体，常用为 F1～F12 和 FL3.1～FL3.15 的共计 27 个阶梯指标； LED光源族，代表相关色温范围在 [2700 K, 6600 K][2700 \\ K, \\ 6600\\ K][2700 K, 6600 K] 的 LED 光源，于 2018 年最新提出； 我们将光源的指定色温带入上一节中讲解过的 CIE 色温函数，就可以求得对应的色度了。下表中列出了常用的 CIE 标准光源的对应结果 [36] [37] [38] [39] ： 图 2.4.5-1 常用 CIE 标准光源信息表[36][37][38][39] 除了为工业用光服务外，标准光源对设备相关色彩空间也有着至关重要的作用。设备指定的作为白点的标准光源，将会直接影响设备的色彩表示，从而产生不同的设备色域范围。想要理解这一点，首先就需要了解什么是 白点（White Point） 。 白点（White Point）与白点选择对设备相关色彩空间的影响 白点（White Point） 是指一个被用于表示色彩空间标准纯白色的色度点。白点的选取直接影响到色彩空间对颜色的偏向。因此，我们将通过调整白点指定色度，来影响色彩空间实际颜色表示的操作，称为 色温白平衡（Color Temperature White Balance） 。有关于包含 白平衡（White Balance） 在内的 颜色平衡（Color Balance） 部分，本书将会在后续的特效处理一章中详细展开。 白点除了选用标准光源外，也可以使用任意色度点。不过，因为太阳是一个标准的黑体辐射源，而人对光线颜色的感知多依赖于阳光。因此，白点最常见的还是取 D65 日光光源，或者其他位于普朗克轨迹上的色温所对应的色度。由于 CIE 规定标准光源三刺激值的 YYY 值被指定为 Y=100Y = 100Y=100 ，实际的标准光源在 XYZ 下的颜色表示值 C(X,Y,Z)C(X,Y,Z)C(X,Y,Z) 与依据色温 TTT 直接计算的 CT(XT,YT,ZT)C_T(X_T,Y_T,Z_T)C​T​​(X​T​​,Y​T​​,Z​T​​) 间，存在放缩关系： C=100YT⋅CT C = {\\frac{100}{Y_T}} \\cdot C_T C=​Y​T​​​​100​​⋅C​T​​ 下表列出了一些常被取用作为 D 系标准光源替代 的，其他普朗克轨迹关键点在 XYZ 上的色度表示： 图 2.4.5-2 常用于作为白点的日光色温对应色度表 对应从低到高的颜色变化如图： 图 2.4.5-3 从 1000K 到 12000K 色温颜色表示 由于 设备相关色彩空间，在颜色表示上依赖于设备本身 ，而这种依赖关系的直观体现就是：颜色的存储，往往采用色彩空间内选定颜色与白点的色度向量差值，或类似变体，经过归一化来定义的。这么做也是一种无奈的妥协：由于设备存储介质空间有限，颜色在保存上需要离散化和均匀化，而最广泛使用的 RGB & XYZ 设备无关色彩空间都不能满足这两个要求。于是，存储问题结合色温的特征，使得不同白点的选取将会直接导致，颜色从数据还原至当前设备色彩空间后的色度与实际期望色度的偏差。 对于设备厂商（或软件供应商），一种可选的白点决策方案是在基于自身产品特性制定相关色彩空间时，首先通过 CIE 色度图将当前设备可表示的颜色边界确定下来，再依据由可表达颜色边界围成的闭包图形中心色度点附近的标准光源来确定白点。从而在一定程度上避免白点导致的定制色彩空间的均色问题。但均色问题从来不是一个能通过白点来解决的单一问题，在这种场景下，最大的影响其实来源自产品本身。所以大多数厂商还是以 CIE 建议，直接指定 D65 来避免这一吃力不讨好的过程。而有关产品本身色域对标准色域表达程度的衡量指标，则被用 显色指数 来更为直观的说明了。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_4_6.html":{"url":"Chapter_2/Language/cn/Docs_2_4_6.html","title":"2.4.6 显色指数（Color Rendering Index）","keywords":"","body":"2.4.6 显色指数（Color Rendering Index） 显色指数（CRI [Color Rendering Index]） 是用来指代设备期望表达颜色与实际展示颜色差异程度的指标，单位为 RaRaRa ，取值范围 [0 Ra, 100 Ra][0 \\ Ra, \\ 100 \\ Ra][0 Ra, 100 Ra] 。通俗来讲， 0 Ra0 \\ Ra0 Ra 意味着完全偏差，比如黑洞； 100 Ra100 \\ Ra100 Ra 则代表着 100% 的颜色还原，比如太阳。 CIE 为了量化显色指数的测量标准，在 1995 年给出了一组被称为 CIE 基准颜色（CIE SC [CIE 1995 Standard Color]） 的 测试用例（TCS [Test Color Samples]） 如下： 图 2.4.6-1 显色指数（CRI）CIE 颜色标准测试用例 这组测试用例，在随后的大量验证中被发现是 不太准确的。 2005 年，专注于日光颜色还原的，现如今已被 爱丽色（X-Rite） 收购的 原科尔莫根（Kollmorgen）子公司格雷塔格（Gretag AG）和麦克白（Macbeth），基于自身及爱丽色（X-Rite）生产的分光光度仪和比色计工程报告的统计信息，对比了 CIE 基准颜色标准的弊端 [40] [41] ，并推出了一套新的颜色测试标准用例。这套用例就是随后被广泛使用的 24 色标准色卡（Color Checker） ，也被称为 麦克白标准色卡（MCC [Macbeth Color Checker]） 。 图 2.4.6-2 MCC 2005 标准色卡 目前工程上大都采用 MCC 作为设备显色指数的测试标准 。除了标准 24 色外，还有更为丰富的 160 色。颜色的丰富程度有助于提升测量的准确性，因此，在更为严苛标准下得到的显色指数结果，将更具有代表性。 最新一次的基于 CIE XYZ 的校准结果如下，可作为工程参考： 图 2.4.6-2 MCC 2005 标准色卡 那么怎么计算 CRI 呢？最为简单的方法就是计算设备实际显示颜色和目标颜色的色差，并归一化。1964 年，CIE 提出了 UVW 色彩空间（CIE 1964 U* V* W* Color Space） ，作为对于 1960 UCS 在归一化能力上的补充。UVW 通过引入白点，使 UCS 上表示的颜色能够被以相对白点坐标的形式转换到一个等大的数值范围内，从而解决了显色指数的计算问题。此后，CIE 将 UVW 作为 UCS 的 特定补充方案 ，计入到了 XYZ 的体系内并 沿用至今 。 假设当前我们测得的颜色在 CIE 1960 UCS 中的色度为 (u, v)(u,\\ v)(u, v) ，取白点为 (u0, v0)(u_0,\\ v_0)(u​0​​, v​0​​) 。记 CIE 1960 UCS 中颜色为 (U,V,W)(U, V, W)(U,V,W) ，对应 CIE 1964 UVW 中坐标为 (U∗,V∗,W∗)(U^*, V^*, W^*)(U​∗​​,V​∗​​,W​∗​​) ，有： (u,v)=(4x−2x+12y+3, 6y−2x+12y+3)(U∗,V∗,W∗)=(13W∗⋅(u−u0),   13W∗⋅(v−v0),   25Y13−17) {\\displaystyle \\begin{aligned} (u, v) &= ({\\frac {4x}{-2x+12y+3}}, \\ {\\frac {6y}{-2x+12y+3}}) \\\\ (U^*, V^*, W^*) &= (13W^{*} \\cdot (u-u_{0}), \\ \\ \\ 13W^{*} \\cdot (v-v_{0}), \\ \\ \\ {25Y^{\\frac {1}{3}}-17}) \\end{aligned} } ​(u,v)​(U​∗​​,V​∗​​,W​∗​​)​​​=(​−2x+12y+3​​4x​​, ​−2x+12y+3​​6y​​)​=(13W​∗​​⋅(u−u​0​​),   13W​∗​​⋅(v−v​0​​),   25Y​​3​​1​​​​−17)​​ 带入 CIE XYZ 色差计算规则，就有色差 ΔC\\Delta CΔC 取欧氏距离： ΔC=ΔE(U∗,V∗,W∗)=(ΔU∗)2+(ΔV∗)2+(ΔW∗)2 {\\displaystyle \\begin{aligned} \\Delta C = \\Delta E(U^*, V^*, W^*)={\\sqrt {\\left(\\Delta U^{*}\\right)^{2}+\\left(\\Delta V^{*}\\right)^{2}+\\left(\\Delta W^{*}\\right)^{2}}} \\end{aligned} } ​ΔC=ΔE(U​∗​​,V​∗​​,W​∗​​)=√​(ΔU​∗​​)​2​​+(ΔV​∗​​)​2​​+(ΔW​∗​​)​2​​​​​​​ 基于 CIE 颜色标准规定，我们要求的显色指数为 RaRaRa 在 UVW 中有： Ra=100−4.6⋅ΔEUVW=100−4.6⋅ΔC {\\displaystyle \\begin{aligned} Ra = 100 - 4.6 \\cdot \\Delta E_{UVW} = 100 - 4.6 \\cdot \\Delta C \\end{aligned} } ​Ra=100−4.6⋅ΔE​UVW​​=100−4.6⋅ΔC​​ 虽然 CIE 对 UVW 的定义是基于 CIE SC，但 MCC 仍然可以使用此快速算法。我们将上述整个计算过程统称为 CIE 色度自适应转换（CAT [Chromatic Adaptation Transformation]）的 CRI 公式 ，简称 CIE CAT-CRI。 到此，色彩的度量的关键指标基本介绍完毕 。不难发现，每一次色彩关键标准的制定都与设备无关色彩空间的迭代密切相关。每一个设备无关色彩空间的设计，都针对性的解决某一种顺承而来的色彩度量问题。可以说，正是这些设备无关色彩空间，共同构成了色彩衡量发展的里程碑。 现在，我们已经从各个度量指标的演化角度，对概念进行了整理。是时候从发展史出发，来纵观整个过程中这些里程碑式的经典色彩空间了。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_5.html":{"url":"Chapter_2/Language/cn/Docs_2_5.html","title":"2.5 经典色彩空间（Classical Color Space）","keywords":"","body":"2.5 经典色彩空间（Classical Color Space） 统一的标准制定和实践的演化推进总是需要循序渐进。而各个 经典色彩空间（Classical Color Space） 就是此领域内的关键节点。 在色彩的衡量中，我们了解了色彩空间偏重描述的特性。不同色彩空间中的相同颜色，必须得经过适当的映射变化和基准变化，才能相互等价。各类颜色描述，需要依托其描述本身对应的色彩空间来看，才会具有意义。 因此，为了简明扼要的阐述转换关系，此处假设用于例举的经典色彩空间，其 RGB 三色基准波长一致，即都为 CIE 1931 RGB 测定标准值。白点统一取用 D65 。而后文中介绍色彩空间所用的配色函数，如无特殊指定，则都为广义配色函数。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_5_1.html":{"url":"Chapter_2/Language/cn/Docs_2_5_1.html","title":"2.5.1 光学三原色色彩空间（RGB）","keywords":"","body":"2.5.1 光学三原色色彩空间（RGB Color Space） 光学三原色色彩空间（RGB Color Space） 又被称为 光三原色空间 或 RGB 色彩空间 。光学三原色色彩空间，是对颜色的加法混合论的有效应用。以光学三原色（RGB）的叠波权重作为三维坐标单位轴，来表示大部分可见光颜色的一种色彩模型。从亥姆霍兹的三色理论之后，光学三原色被广泛的用来表示颜色特性，但并没有形成工程化的系统。 图 2.5.1-1 光学三原色色彩空间（RGB Color Space）坐标系 而由格拉斯曼颜色定律可知，人对颜色的感知其实是比较线性的。所以，光学三原色色彩空间的颜色表示非常简洁。如果记目标颜色为 CRGBC_{RGB}C​RGB​​ ，那么 配色函数 为： CRGB=R⋅Red+G⋅Green+B⋅Blue=Vector[R,G,B] C_{RGB} = R \\cdot Red + G \\cdot Green + B \\cdot Blue = Vector[R, G, B] C​RGB​​=R⋅Red+G⋅Green+B⋅Blue=Vector[R,G,B] 所有可见光都可以利用此公式表示出来。 光学三原色色彩空间的基准取自 RGB 的锚定，因此 RGB 三色的代表波长选取，将会影响整个光学三原色色彩空间的颜色表示水平。 由于足够简单且便于量化，基于光学三原色色彩空间配色函数的有局限改版模型，如 IBM RGB、Adobe RGB等，被广泛使用于计算机科学 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_5_2.html":{"url":"Chapter_2/Language/cn/Docs_2_5_2.html","title":"2.5.2 颜料三原色色彩空间（CMY / CMYK ）","keywords":"","body":"2.5.2 颜料三原色色彩空间（CMY / CMYK Color Space） 颜料三原色色彩空间 ，根据其是否包含对黑色（Black）的描述，被分为 印刷三分色模型（CMY Color Space） 即 CMY 色彩空间 ，和 印刷四分色模型（CMYK Color Space） 即 CMYK 色彩空间 。其中，CMY 即指代颜料三原色，K 则为 Black 取尾字母，以和纯蓝色（Blue）作为区分。 颜料三原色色彩空间，是对颜色的减法混合论的直接应用。 图 2.5.2-1 颜料三原色色彩空间（CMY/CMYK Color Space）坐标系 对于 CMY 色彩空间，如果记目标颜色为 CCMYC_{CMY}C​CMY​​ ，那么 配色函数 为： CCMY=C⋅Cyan+M⋅Magenta+Y⋅Yellow=Vector[C,M,Y] C_{CMY} = C \\cdot Cyan + M \\cdot Magenta + Y \\cdot Yellow = Vector[C, M, Y] C​CMY​​=C⋅Cyan+M⋅Magenta+Y⋅Yellow=Vector[C,M,Y] 可以发现 CMY 色彩空间与 RGB 色彩空间，恰好以立方体质心堆成。因此存在转换： CCMY=1−CRGB C_{CMY} = 1 - C_{RGB} C​CMY​​=1−C​RGB​​ 印刷三分色模型最早被应用于人们于绘画中。通过对颜料三原色的调色板混合，可以形成不同的颜色。由于 CMY 色彩空间在人类历史长河中，已被应用于绘画创作许久，因此这个颜色空间较难追溯最初的提出者了。不过真正对颜料三原色进行色彩空间的标准化工作，还是在打印机被发明后。 无论是喷墨打印机、照相打印机，还是激光打印机。打印出的结果都是依靠反射光被人们观察到的。这决定了此类型工程和绘画基本一致。早期打印机采用 CMY 色彩空间，并用红、青、黄三色混合，来实现黑色的显示。但是，这样混合出的黑色在显示上偏红黑。为了应对这种现象，人们在工程上引入了独立的黑色墨盒，以求解决黑色的打印问题。因此，为了描述被独立引入的黑色在颜色还原上的转换，提出了 CMYK 色彩空间。 CMYK 色彩空间 ，对黑色进行了重设。如果记目标颜色为 CCMYKC_{CMYK}C​CMYK​​ ，那么配色函数为： CCMYK=C⋅Cyan+M⋅Magenta+Y⋅Yellow+K⋅Black=Vector[C,M,Y,K] C_{CMYK} = C \\cdot Cyan + M \\cdot Magenta + Y \\cdot Yellow + K \\cdot Black = Vector[C, M, Y, K] C​CMYK​​=C⋅Cyan+M⋅Magenta+Y⋅Yellow+K⋅Black=Vector[C,M,Y,K] 由于 CMYK 比 CMY 多一维度K，从 CMY 到 CMYK 的映射就需要进行升维。 记 K=1K = 1K=1 时， CCMYK=Vector[0, 0, 0, 1]C_{CMYK} = Vector[0,\\ 0,\\ 0,\\ 1]C​CMYK​​=Vector[0, 0, 0, 1] ，那么 K≠1K \\neq 1K≠1 时就有： [CMYK]=[(C′−K)/(1−K)(M′−K)/(1−K)(Y′−K)/(1−K)K]  ∣  [K=min(C′,M′,Y′),  K≠1] {\\begin{bmatrix} C \\\\ M \\\\ Y \\\\K \\end{bmatrix}} = {\\begin{bmatrix} (C^{\\prime} - K) / (1-K) \\\\ (M^{\\prime} -K ) / (1-K) \\\\ (Y^{\\prime} - K) / (1-K) \\\\K \\end{bmatrix}} \\ \\ | \\ \\ [K = min(C^{\\prime}, M^{\\prime}, Y^{\\prime}),\\ \\ K \\neq 1] ​⎣​⎢​⎢​⎡​​​C​M​Y​K​​​⎦​⎥​⎥​⎤​​=​⎣​⎢​⎢​⎡​​​(C​′​​−K)/(1−K)​(M​′​​−K)/(1−K)​(Y​′​​−K)/(1−K)​K​​​⎦​⎥​⎥​⎤​​  ∣  [K=min(C​′​​,M​′​​,Y​′​​),  K≠1] 而从 CMYK 到 CMY 的映射，就简单了： [C′M′Y′]=[(1−K)⋅C+K(1−K)⋅M+K(1−K)⋅Y+K] {\\begin{bmatrix} C^{\\prime} \\\\ M^{\\prime} \\\\ Y^{\\prime} \\end{bmatrix}} = {\\begin{bmatrix} (1-K) \\cdot C + K \\\\ (1-K) \\cdot M + K \\\\ (1-K) \\cdot Y + K \\end{bmatrix}} ​⎣​⎡​​​C​′​​​M​′​​​Y​′​​​​​⎦​⎤​​=​⎣​⎡​​​(1−K)⋅C+K​(1−K)⋅M+K​(1−K)⋅Y+K​​​⎦​⎤​​ 而对于 CYMK 色彩空间和 RGB 色彩空间互转，就有需要以 CMY 色彩空间作为桥梁。先根据转换方向，通过 CMY 色彩空间进行 CRGB→CCMYC_{RGB} \\rightarrow C_{CMY}C​RGB​​→C​CMY​​ 或者 CCMYK→CCMY C_{CMYK} \\rightarrow C_{CMY}C​CMYK​​→C​CMY​​ ，再通过 CMY 与 RGB 与 CMYK 的关系，进行间接转换。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:11 "},"Chapter_2/Language/cn/Docs_2_5_3.html":{"url":"Chapter_2/Language/cn/Docs_2_5_3.html","title":"2.5.3 CIE RGB 色彩空间（CIE 1931 RGB Color Space）","keywords":"","body":"2.5.3 CIE RGB 色彩空间（CIE 1931 RGB Color Space） 在经过大量对理论的实践探索后，人们发现三维坐标系统无疑是从空间和原理上，最为合适构建色彩模型的描述载体。但传统的 RGB 色彩空间由于没有系统，且存在 基准波长校准问题 ，并不适用于现代工业。 1931年，为了解决工业体系内颜色描述的模型化， 国际照明委员会（CIE [International Commission on Illumination]） 进行了对光学三原色色彩空间抽象汇总的工作。 现在我们所称的 RGB 色彩空间，多指 CIE RGB 色彩空间 。CIE RGB 色彩空间最为重要的贡献，是在格拉斯曼颜色实验的基础上确定了光谱三刺激值，以 Red 取 700nm、Green 取 546.1nm、Blue 取 435.8nm 作为光学三原色波长的基准标定，将人眼可见光谱范围内的所有颜色，依据前文中提到的 三原色函数（Trichromatic Primaries Functions） 统一到了模型。 图 2.5.3-1 CIE RGB 色彩空间（CIE RGB Color Space）顶点色示意图 CIE RGB 色彩空间的 配色函数 直接采用 了传统三原色色彩空间的配色函数，唯一不同的只在于三原色的选取 ： CRGB=R⋅Red700+G⋅Green546.1+B⋅Blue435.8=Vector[R,G,B] C_{RGB} = R \\cdot Red_{700} + G \\cdot Green_{546.1} + B \\cdot Blue_{435.8} = Vector[R, G, B] C​RGB​​=R⋅Red​700​​+G⋅Green​546.1​​+B⋅Blue​435.8​​=Vector[R,G,B] 因此，CIE RGB 也不可避免的继承了光学三原色色彩空间的 负色匹配 问题。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_5_4.html":{"url":"Chapter_2/Language/cn/Docs_2_5_4.html","title":"2.5.4 CIE XYZ 色彩空间（CIE 1931 XYZ Color Space）","keywords":"","body":"2.5.4 CIE XYZ 色彩空间（CIE 1931 XYZ Color Space） 1931年，国际照明委员会（CIE [International Commission on Illumination]） 提出，以经过设计的 XYZ 基准坐标系来锚定 RGB 边界的方案可以解决问题。这一映射方案所对应的颜色描述模型，被称为 XYZ 色彩空间（XYZ Color Space） [12] [13] 。 CIE 以线性等式关系构建了 XYZ 系统与 RGB 系统的转换，以三刺激函数（Tristimulus Values Functions）使可见光基于 XYZ 坐标的混合向量全部局限于正象限 [X≥0, Y≥0, Z≥0]。 如果记目标颜色为 CXYZC_{XYZ}C​XYZ​​ ，一单位 RGB 到一单位 XYZ 有： 从 R→XR \\rightarrow XR→X 的转换因子为 CrxC_{rx}C​rx​​ ，从 G→YG \\rightarrow YG→Y 的转换因子为 CgyC_{gy}C​gy​​ ，从 B→ZB \\rightarrow ZB→Z 的转换因子为 CbzC_{bz}C​bz​​ 那么 XYZ 色彩空间的 配色函数 为： CXYZ=X⋅CrxR+Y⋅CgyG+Z⋅CbzB=Vector[X,Y,Z] C_{XYZ} = X \\cdot C_{rx}R + Y \\cdot C_{gy}G + Z \\cdot C_{bz}B = Vector[X, Y, Z] C​XYZ​​=X⋅C​rx​​R+Y⋅C​gy​​G+Z⋅C​bz​​B=Vector[X,Y,Z] 而从 RGB 到 XYZ 是天然可转的，记转换矩阵为 MRGB2XYZM_{RGB2XYZ}M​RGB2XYZ​​ ，那么有映射： CXYZ=MRGB2XYZ⋅CRGB C_{XYZ} = M_{RGB2XYZ} \\cdot C_{RGB} C​XYZ​​=M​RGB2XYZ​​⋅C​RGB​​ 即： [XYZ]=[+0.49000+0.31000+0.20000+0.17697+0.81240+0.01063+0.00000+0.01000+0.99000]⋅[RGB] {\\displaystyle {\\begin{bmatrix} X \\\\ Y \\\\ Z \\end{bmatrix}}= {\\begin{bmatrix} +0.490\\,00 & +0.310\\,00 & +0.200\\,00\\\\ +0.176\\,97 & +0.812\\,40 & +0.010\\,63\\\\ +0.000\\,00 & +0.010\\,00 & +0.990\\,00 \\end{bmatrix}} \\cdot {\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix}} } ​⎣​⎡​​​X​Y​Z​​​⎦​⎤​​=​⎣​⎡​​​+0.49000​+0.17697​+0.00000​​​+0.31000​+0.81240​+0.01000​​​+0.20000​+0.01063​+0.99000​​​⎦​⎤​​⋅​⎣​⎡​​​R​G​B​​​⎦​⎤​​ 而从 XYZ 到 RGB，就相当于反向求逆，因此如下： CXYZ=MRGB2XYZ−1⋅CRGB C_{XYZ} = {M_{RGB2XYZ}}^{-1} \\cdot C_{RGB} C​XYZ​​=M​RGB2XYZ​​​−1​​⋅C​RGB​​ 即： [RGB]≈[+2.36461385−0.89654057−0.46807328−0.51516621+1.42640810+0.08875810+0.00520370−0.01440816+1.00920446][XYZ] {\\displaystyle {\\begin{bmatrix}R\\\\G\\\\B\\end{bmatrix}} \\approx {\\begin{bmatrix} +2.364\\,61385 & -0.896\\,54057 & -0.468\\,07328\\\\ -0.515\\,16621 & +1.426\\,40810 & +0.088\\,75810\\\\ +0.005\\,20370 & -0.014\\,40816 & +1.009\\,20446 \\end{bmatrix}}{\\begin{bmatrix}X\\\\Y\\\\Z\\end{bmatrix}}} ​⎣​⎡​​​R​G​B​​​⎦​⎤​​≈​⎣​⎡​​​+2.36461385​−0.51516621​+0.00520370​​​−0.89654057​+1.42640810​−0.01440816​​​−0.46807328​+0.08875810​+1.00920446​​​⎦​⎤​​​⎣​⎡​​​X​Y​Z​​​⎦​⎤​​ 其中， MRGB2XYZM_{RGB2XYZ}M​RGB2XYZ​​ 为测量所得 [12]（见前文）推导而出的坐标映射矩阵。 基于此映射关系，所有实际可见波长的 视觉单色（Monochromat）和混合色 在经过坐标转换后，都可以被描述到由 XYZ 色彩空间。这为统一视觉颜色对比标准和迭代推进色彩空间色设计，创造了有力基础工具。工程中为了表示设备颜色特性，常将设备颜色范围以 XYZ 色彩空间的色度图切面，即 CIE 标准色度图（CIE Standard Observer Chromaticity Diagram） 表示。因此，CIE XYZ 颜色空间的配色函数也被称为 “CIE 标准观测者（CIE Standard Observer ）”函数 。 但 XYZ 的也继承了 RGB 的 “均匀色差” (即 平均色差 问题) 挑战（见前文）。人眼各类视锥细胞的数目是存在差异的。纯物理描述转换为感知上的情况，在 RGB 与 XYZ 所选基准波长条件下，就会因为人对光学三原色光线的敏感程度不同，产生冷色调区域相近颜色富集，而暖色调相近颜色离散的问题。如果取用广义色差 ，即两个颜色的欧式距离，为色差 ΔC\\Delta CΔC 的话。那么 XYZ 色彩空间中，单位 ΔC\\Delta CΔC 的颜色变化情况就显得不那么均匀。这个就是 平均色差 问题。 如何处理平均色差问题？CIE 和美标给出了不同的思路。CIE 将色差问题，拆分为色度图均匀化和白点取值影响归一化两个问题，区分考虑。提出了着重于细微色差变化的 CIE LAB 色彩空间标准，和偏重标准光源线性归一化的 CIE LUV 色彩空间标准。而美标则以商业出发点，追求色彩还原更接近人眼生理感受，同时还要兼顾工业体系中对色彩信息的精细度要求，进而推进了颜色三要素色彩空间的制定。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_5_5.html":{"url":"Chapter_2/Language/cn/Docs_2_5_5.html","title":"2.5.5 CIE LAB 色彩空间（CIE 1976 L*, a*, b* Color Space）","keywords":"","body":"2.5.5 CIE LAB 色彩空间（CIE 1976 L*, a*, b* color space） 1952 年，色彩科学家 里查德·塞瓦尔·亨特（Richard Sewall Hunter，1909–1991） 创建了至今任然是业界最高端颜色解决方案供应商的 亨特联合实验室（HunterLab [Hunter Associates Laboratory]） ，并在之后提出了著名的 Hunter L,a,b 色彩空间 。 Hunter L,a,b 色彩空间结合 CIE XYZ 色彩空间，共同组成了 CIE 1976 LAB 色彩空间的前身。所以，CIE LAB 与 RGB 间需要通过 XYZ 来缔结转换关系。 1976 年，在经过一系列建议的采纳和对 1931 色彩标准体系的完善后，CIE 尝试用一种全新的角度来处理均色问题。CIE 在 Hunter L,a,b 色彩空间的基础上，沿用了 Hunter L,a,b 的色度处理方式与 CIE XYZ 体系结合 ，将 CIE 标准观察者应用在了 CIE 1976 LAB 色彩空间上。由于 Hunter L,a,b 设定之初的目的，就是将不同颜色间的差异更为显著的客观表示出来，因此 CIE LAB 也继承了这一特点，成为了 设备无关 适合于色差比对的色彩空间。 CIE 1976 LAB 将 XYZ 色度图（非色度平面）在其所在平面，以选定白点为中心拓扑变换为圆形，分别代表：红（Red）、绿（Green）、蓝（Blue）、黄（Yellow） 的 4 个等大象限（扇区），并以平面中心构建了二维坐标系 (a, b)(a,\\ b)(a, b) 。以平面内向量 (a, b)(a,\\ b)(a, b) 来索引实际色度。 我们知道，单纯的靠色度是没办法完全描述颜色特征的。除了色度外，我们还需要引入光亮度因素。CIE LAB 中的依旧沿用了 1960 UCS 和 1931 XYZ 中对光亮度的处理方式，单取由白到黑的 灰度线（Grey Line） 作为了光亮度的刻度。但是对与不同光亮度的切分，LAB 也对 XYZ 原有的亮度表示进行了调整。以在一定程度上保证，每个亮度下切割得到的色度平面都有相对均匀表示。 如果记目标颜色为 CLABC_{LAB}C​LAB​​ ，那么 LAB 色彩空间的 配色函数 为： CLAB=L⋆⋅Luminance+Plane(a⋆, b⋆)=Vector[L⋆,a⋆,b⋆] C_{LAB} = L^{\\star } \\cdot Luminance + Plane(a^{\\star },\\ b^{\\star }) = Vector[L^{\\star }, a^{\\star }, b^{\\star }] C​LAB​​=L​⋆​​⋅Luminance+Plane(a​⋆​​, b​⋆​​)=Vector[L​⋆​​,a​⋆​​,b​⋆​​] 记 D65 白点在 XYZ 色彩空间内颜色为 CD65C_{D65}C​D65​​ ，有色温 1960 UCS 快速计算得： CD65 (XD65, YD65, ZD65)≈(95.049, 100, 108.884) {\\displaystyle \\begin{aligned} &C_{D65}\\ (X_{D65},\\ Y_{D65},\\ Z_{D65}) \\approx (95.049,\\ 100,\\ 108.884) \\\\ \\end{aligned} } ​​​​​C​D65​​ (X​D65​​, Y​D65​​, Z​D65​​)≈(95.049, 100, 108.884)​​ 如果记目标颜色为 CLABC_{LAB}C​LAB​​ ，一单位 XYZ 到一单位 LAB 有： [L⋆a⋆b⋆]=[0+116016+500−500000+200−2000]⋅[F(XXwhite)F(YYwhite)F(ZZwhite)1] {\\displaystyle {\\begin{bmatrix} L^{\\star } \\\\ a^{\\star } \\\\ b^{\\star } \\end{bmatrix}}= {\\begin{bmatrix} 0 & +116 & 0 & 16 \\\\ +500 & -500 & 0 & 0 \\\\ 0 & +200 & -200 & 0 \\\\ \\end{bmatrix}} \\cdot {\\begin{bmatrix} F(\\tfrac{X}{X_{white}}) \\\\ F(\\tfrac{Y}{Y_{white}}) \\\\ F(\\tfrac{Z}{Z_{white}}) \\\\ 1 \\end{bmatrix}} } ​⎣​⎡​​​L​⋆​​​a​⋆​​​b​⋆​​​​​⎦​⎤​​=​⎣​⎢​⎢​⎡​​​0​+500​0​​​​+116​−500​+200​​​0​0​−200​​​16​0​0​​​⎦​⎥​⎥​⎤​​⋅​⎣​⎢​⎢​⎡​​​F(​X​white​​​​X​​)​F(​Y​white​​​​Y​​)​F(​Z​white​​​​Z​​)​1​​​⎦​⎥​⎥​⎤​​ 即，从 XYZ 到 LAB 有： L⋆=116⋅ F(YYD65)−16a⋆=500⋅(F(XXD65)−F(YYD65))b⋆=200⋅(F(YYD65)−F(ZZD65)) {\\displaystyle \\begin{aligned} L^{\\star }&=116 \\cdot \\ F\\!\\left({\\frac {Y}{Y_{D65}}}\\right)-16 \\\\ a^{\\star }&=500 \\cdot \\left(F\\!\\left({\\frac {X}{X_{D65}}}\\right)-F\\!\\left({\\frac {Y}{Y_{D65}}}\\right)\\right) \\\\ b^{\\star }&=200 \\cdot \\left(F\\!\\left({\\frac {Y}{Y_{D65}}}\\right)-F\\!\\left({\\frac {Z}{Z_{D65}}}\\right)\\right) \\\\ \\end{aligned} } ​L​⋆​​​a​⋆​​​b​⋆​​​​​​=116⋅ F(​Y​D65​​​​Y​​)−16​=500⋅(F(​X​D65​​​​X​​)−F(​Y​D65​​​​Y​​))​=200⋅(F(​Y​D65​​​​Y​​)−F(​Z​D65​​​​Z​​))​​ 其中： F(n)={n3   n>δ3n3δ2+429   n≤δ3   ,  δ=629 {\\displaystyle \\begin{aligned} F(n)&={ \\begin{cases} {\\sqrt [{3}]{n}} & \\ \\ \\ n > \\delta ^{3} \\\\ {\\dfrac {n}{3\\delta ^{2}}}+{\\frac {4}{29}} & \\ \\ \\ n \\le \\delta ^{3} \\end{cases} }\\ \\ \\ , \\ \\ \\delta ={\\tfrac {6}{29}} \\end{aligned} } ​F(n)​​​=​⎩​⎨​⎧​​​​3​​√​n​​​​​3δ​2​​​​n​​+​29​​4​​​​​   n>δ​3​​​   n≤δ​3​​​​   ,  δ=​29​​6​​​​ 而从 LAB 到 XYZ，就相当于反向求逆，因此如下： X=XD65⋅F−1(L⋆+16116+a⋆500)Y=YD65⋅F−1(L⋆+16116)Z=ZD65⋅F−1(L⋆+16116−b⋆200) {\\displaystyle \\begin{aligned} X &= X_{D65} \\cdot F^{-1}\\left({\\frac {L^{\\star }+16}{116}} + {\\frac {a^{\\star }}{500}}\\right) \\\\ Y &= Y_{D65} \\cdot F^{-1}\\left({\\frac {L^{\\star }+16}{116}} \\right) \\\\ Z &= Z_{D65} \\cdot F^{-1}\\left({\\frac {L^{\\star }+16}{116}} - {\\frac {b^{\\star }}{200}}\\right) \\end{aligned} } ​X​Y​Z​​​=X​D65​​⋅F​−1​​(​116​​L​⋆​​+16​​+​500​​a​⋆​​​​)​=Y​D65​​⋅F​−1​​(​116​​L​⋆​​+16​​)​=Z​D65​​⋅F​−1​​(​116​​L​⋆​​+16​​−​200​​b​⋆​​​​)​​ 其中： F−1(n)={n3   n>δ3δ2(n−429)   n≤δ   ,  δ=629 {\\displaystyle \\begin{aligned} F^{-1}(n)&={ \\begin{cases} {n^3} & \\ \\ \\ n > \\delta \\\\ {3\\delta ^2}(n-{\\frac {4}{29})} & \\ \\ \\ n \\le \\delta \\end{cases} }\\ \\ \\ , \\ \\ \\delta ={\\tfrac {6}{29}} \\end{aligned} } ​F​−1​​(n)​​​=​⎩​⎨​⎧​​​n​3​​​3δ​2​​(n−​29​​4​​)​​​   n>δ​   n≤δ​​   ,  δ=​29​​6​​​​ 可见，XYZ 与 LAB 间的转换关系，并不是线性的。由于 CIE LAB 中的白点直接参与了转换运算，白点调参对 LAB 的影响程度会更大一些。带入色差公式 ΔC=(Δa⋆)2+(Δb⋆)2{\\displaystyle \\begin{aligned} {\\displaystyle \\Delta C = {\\sqrt {\\left(\\Delta a^{\\star}\\right)^{2}+\\left(\\Delta b^{\\star}\\right)^{2}}}} \\end{aligned} }​ΔC=√​(Δa​⋆​​)​2​​+(Δb​⋆​​)​2​​​​​​​ 会发现，通过这种方式切割得到的整个人眼可见光色域范围，色差均匀程度依赖于白点的同时，也并非完全均匀。越靠近色度图白点，色差变化越小；越靠近色度图边缘，色差变化越大，不过相较于 XYZ 已有很大改善 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_5_6.html":{"url":"Chapter_2/Language/cn/Docs_2_5_6.html","title":"2.5.6 CIE LUV 色彩空间（CIE 1976 L*, u*, v* Color Space）","keywords":"","body":"2.5.6 CIE LUV 色彩空间（CIE 1976 L*, u*, v* color space） 1976 年，在 CIE 采纳 CIE LAB 色彩空间的同年，CIE 以 CIE 1960 UCS 和 CIE 1964 UVW（这两个在前文色彩度量中介绍过，做为补充型色彩空间，用于量化色温和 CRI 到 CIE 标准体系内）为基础 进一步拓展，提出了 CIE LUV 色彩空间。 显然，CIE LUV 提出的目的，是为了将 CIE 1960 UCS 和 CIE 1964 UVW 两个色彩空间的 特性统一 到单一色彩空间。通过整合两者在度量衡相关量方面的计算，来 化解得到目标尺度值后的色彩空间互转问题 。我们知道 CIE 1960 UCS 是由 XYZ 拓扑变换而得，CIE 1964 UVW 是由 CIE 1960 UCS 引入白点而得，两者的关键点皆在于平面色度值，而两者区别只在于 UVW 引入了白点。因此，整个问题就变为，找到一个合适的映射函数（狭义配色函数），使得在任何白点取值条件下， CIE LUV 中颜色的色度转 XYZ 皆为线性 。 基于此，LUV 对光亮度参数 进行了依托于白点的非线性变化。以此来保证，在不同白点选取下的色度，都能维持同 UCS 和 UVW 一致的线性转换方式。这一操作使 LUV 色彩空间不论白点如何选取，都能有从 LUV 到 XYZ 的色度的线性变换和逆变换。 如果记目标颜色为 CLUVC_{LUV}C​LUV​​ ，那么 LUV 色彩空间的 配色函数 为： CLUV=L⋆⋅Luminance+Plane(u⋆, v⋆)=Vector[L⋆,u⋆,v⋆] C_{LUV} = L^{\\star } \\cdot Luminance + Plane(u^{\\star },\\ v^{\\star }) = Vector[L^{\\star }, u^{\\star }, v^{\\star }] C​LUV​​=L​⋆​​⋅Luminance+Plane(u​⋆​​, v​⋆​​)=Vector[L​⋆​​,u​⋆​​,v​⋆​​] 记 D65 白点在 XYZ 色彩空间内颜色为 CD65C_{D65}C​D65​​ ，有色温 1960 UCS 快速计算得： CD65 (xD65, yD65, YD65)≈(0.31271, 0.32902, 100) {\\displaystyle \\begin{aligned} &C_{D65}\\ (x_{D65},\\ y_{D65},\\ Y_{D65}) \\approx (0.31271,\\ 0.32902,\\ 100) \\\\ \\end{aligned} } ​​​​​C​D65​​ (x​D65​​, y​D65​​, Y​D65​​)≈(0.31271, 0.32902, 100)​​ 如果记目标颜色为 CLUVC_{LUV}C​LUV​​ ，从 XYZ 到 LUV 有： (x,y)=(   XX+Y+Z    ,   YX+Y+Z    )(u,v)=(4x−2x+12y+3, 9y−2x+12y+3)(u⋆,v⋆,L⋆)=F(Y)⋅(13⋅(u−uD65),   13⋅(v−vD65),   1 ) {\\displaystyle \\begin{aligned} &(x, y) = (\\ \\ \\ {\\frac {X}{X+Y+Z}} \\ \\ \\ \\ , \\ \\ \\ {\\frac {Y}{X+Y+Z}} \\ \\ \\ \\ ) \\\\ &(u, v) = ({\\frac {4x}{-2x+12y+3}}, \\ {\\frac {9y}{-2x+12y+3}}) \\\\ &(u^{\\star }, v^{\\star }, L^{\\star }) = F\\!\\left({Y}\\right) \\cdot ( 13 \\cdot \\left(u-u_{D65}\\right), \\ \\ \\ 13 \\cdot \\left(v-v_{D65}\\right), \\ \\ \\ 1\\ ) \\\\ \\end{aligned} } ​​​​​​​(x,y)=(   ​X+Y+Z​​X​​    ,   ​X+Y+Z​​Y​​    )​(u,v)=(​−2x+12y+3​​4x​​, ​−2x+12y+3​​9y​​)​(u​⋆​​,v​⋆​​,L​⋆​​)=F(Y)⋅(13⋅(u−u​D65​​),   13⋅(v−v​D65​​),   1 )​​ 其中： L⋆=F(Y)={(293)3⋅YYD65   YYD65≤δ3116⋅YYD653 −16   YYD65>δ3   ,  δ=629 {\\displaystyle \\begin{aligned} L^{\\star } = F(Y)&={ \\begin{cases} {\\left( {\\frac {29}{3}} \\right)^3 \\cdot {\\frac {Y}{Y_{D65}}}} & \\ \\ \\ {\\frac {Y}{Y_{D65}}} \\le \\delta ^{3} \\\\ {116 \\cdot {\\sqrt [3]{\\frac {Y}{Y_{D65}}}} \\ - 16} & \\ \\ \\ {\\frac {Y}{Y_{D65}}} > \\delta ^{3} \\end{cases} }\\ \\ \\ , \\ \\ \\delta ={\\tfrac {6}{29}} \\end{aligned} } ​L​⋆​​=F(Y)​​​=​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​(​3​​29​​)​3​​⋅​Y​D65​​​​Y​​​116⋅​3​​√​​Y​D65​​​​Y​​​​​ −16​​​   ​Y​D65​​​​Y​​≤δ​3​​​   ​Y​D65​​​​Y​​>δ​3​​​​   ,  δ=​29​​6​​​​ 而从 LUV 到 XYZ，就相当于反向求逆，因此如下： (u,v)=(u⋆13⋅L⋆+uD65  ,  v⋆13⋅L⋆+vD65 )(x,y)=(9u6u−16v+12  , 4v6u−16v+12 )(X,Y,Z)=F−1(L⋆)⋅(9u4v,   1,   12−3u−20v4v ) {\\displaystyle \\begin{aligned} &(u, v) = ( {\\frac {u^{\\star }}{13 \\cdot L^{\\star }}} + u_{D65}\\ \\ , \\ \\ {\\frac {v^{\\star }}{13 \\cdot L^{\\star }}} + v_{D65} \\ ) \\\\ &(x, y) = ({\\frac {9u}{6u-16v+12}}\\ \\ , \\ {\\frac {4v}{6u-16v+12}} \\ ) \\\\ &(X, Y, Z) = F^{-1}(L^{\\star }) \\cdot ( {\\frac {9 u}{4 v}}, \\ \\ \\ 1, \\ \\ \\ {\\frac {12 - 3 u - 20 v}{4 v}} \\ ) \\\\ \\end{aligned} } ​​​​​​​(u,v)=(​13⋅L​⋆​​​​u​⋆​​​​+u​D65​​  ,  ​13⋅L​⋆​​​​v​⋆​​​​+v​D65​​ )​(x,y)=(​6u−16v+12​​9u​​  , ​6u−16v+12​​4v​​ )​(X,Y,Z)=F​−1​​(L​⋆​​)⋅(​4v​​9u​​,   1,   ​4v​​12−3u−20v​​ )​​ 其中： Y=F−1(L⋆)={YD65⋅(329)3⋅L⋆   L⋆≤8YD65⋅(L⋆+16116)3   L⋆>8 {\\displaystyle \\begin{aligned} Y = F^{-1}(L^{\\star })&={ \\begin{cases} {Y_{D65} \\cdot \\left( {\\frac {3}{29}} \\right)^3 \\cdot {L^{\\star }}} & \\ \\ \\ L^{\\star } \\le 8 \\\\ {Y_{D65} \\cdot \\left( {\\frac {L^{\\star }+16}{116}} \\right)^3 } & \\ \\ \\ L^{\\star } > 8 \\end{cases} } \\end{aligned} } ​Y=F​−1​​(L​⋆​​)​​​=​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​Y​D65​​⋅(​29​​3​​)​3​​⋅L​⋆​​​Y​D65​​⋅(​116​​L​⋆​​+16​​)​3​​​​​   L​⋆​​≤8​   L​⋆​​>8​​​​ 同 LAB，CIE LUV 的优势也在于白点确定后的快速计算。 由于 CIE LUV 并没有针对自身 LUV 色度图所在平面，即 所在平面， 做类似于 LAB 的均匀化拓扑变形。因此，LUV 在色差均匀问题上的表现，要逊于 LAB。 但是，基于 LUV 在选定白点后的线性色彩空间转换特性，LUV 在数据传输和色彩压缩方面却起到了意料之外的表现。其设计思想最终为 YUV 色彩格式的制定打下了理论基础 。 既然将色差问题拆分为均匀化和归一化的间接处理方法不太行，那么以颜色三要素角度出发将色差均匀直接做为目标，是否就能得到完美答案呢？之前我们提到，于 LAB 和 LUV 同时期下的挑战者是美标 HSL。HSL 正是探索这一问题答案的先行者，虽然最终得到的结果 可能不尽如人意 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_5_7.html":{"url":"Chapter_2/Language/cn/Docs_2_5_7.html","title":"2.5.7 颜色三要素色彩空间（HSV / HSI / HSL）","keywords":"","body":"2.5.7 颜色三要素色彩空间（HSL [HSV / HSI / HSL（Lightness）]） HSL（Hue，Saturation，Luminance） 色彩空间 又被称为 颜色三要素色彩空间 ，是对 HSV（Hue，Saturation，Value）色彩空间、 HSI（Hue，Saturation，Intensity）色彩空间、HSL（Hue，Saturation，Lightness）色彩空间的统称 ，简称 三要素色彩空间 。这里的 V（Value）、I（Intensity）、L（Lightness）其实代指的，基本等同于前文中提及的光亮度（Luminance）的简化概念 。HSI 色彩空间，在设计理念上趋同于 HSV 色彩空间。HSL(Lightness) 在 HSV 、 HSI上进行了改进整合。因此，通常所称的 HSL 色彩空间，即为 HSL（Lightness）色彩空间。 后文中为了说明，保持 HSL 统一代称，在需要区分说明时，使用 HSV、HSI、HSL（Lightness）独立称谓指定区别。 1938年，为了解决彩色电视信号的转换和传输问题，一位名叫 乔治·瓦伦西（Georges Valensi，1889 - 1980） 的法国电信工程师，提交了以色调与光亮度来进行彩色图片编码传输的解决方案并注册了专利 [14] [15] 。方案中首次引入了使用色调和光亮度，来构建色彩空间的概念。瓦伦西在持有专利的有效时间内，经过反复延长申请，使他的专利权从 1939年 一直持续到了 1971年。尴尬的是，彩色电视机在 1946年才被 约翰·洛吉·贝尔德（J.L.Baird，1888 - 1946） 发明出来。而彩电和彩色信号，真正得到大规模商业化应用和普及的时间节点，几乎到了20世纪70年代。因此，在美电 1953年出台美国安全彩电标准和 1954年推出 RCA彩色电视机之前，瓦伦西几乎没有靠此专利得到任何收益。 图 2.5.7-1 乔治·瓦伦西（Georges Valensi）于 1945 年在美专利局注册手稿 [15] 1978年，HSV 色彩空间的概念由 阿尔维·雷·史密斯（A.R Smith，Alvy Ray Smith III，1943 - 今） 提出。HSV 的目的是为了解决计算机显示对 RGB 的主色还原问题。这要求我们提供一种更直观，并更接近经典理论的，可连续变化且动态可分的色彩模型 [16] 。 而于1978年同年，在 乔布洛夫（George H. Joblove） 和 格林伯格（Donald Greenberg） 发表的的论文 《为计算机图形设计的色彩空间》 中 [17]，也通过引入 HSI 色彩空间，来尝试解决这个问题。论文同时还拿 HSI 与 HSV 做了比对。 为什么认为 HSV 和 HSI 是可以约等的？仅仅只是因为两者近乎先后出现于同年？并不是。最关键的判断，还是来自于 HSV 和 HSI 对颜色空间的定义。可以认为 HSV 和 HSI 的差异，是一种观察角度导致的偏差，是同种概念的参考位选取的不同而导致的。这种差异主要体现在光亮度与饱和度在模型中的处理。两者的解决方案，在这两个色彩要素的计算与设定上，各有优劣。HSI 的饱和度选取方式，让模型更接近人眼对颜色的感知，使颜色从 RGB 转换 HSI 更为便捷。但同时也导致还原相对麻烦。HSV 正好相反。那么是否存在一种模型，可以取弊存优呢？ 1979年，在 美国计算机协会（ACM） 旗下的 计算机图形图像特别兴趣小组（SIGGRAPH） 组织的年度会报会议上。 泰克科技有限公司（Tektronix, Inc. US） 的工程师们提出了 HSL（Lightness）色彩空间 [18]，尝试综合 HSV 和 HSI 解决色彩感知还原与颜色空间转换问题。 HSL（Lightness）从数学角度上， 以中值对 HSV 和 HSI 的光亮度概念进行了整合 ，使饱和度的表示得到简化，并保留了 HSI 的视觉感官还原特点。这也使 HSL（Lightness）模型，于 1979 年年末的计算机图形标准委员会（Computer Graphics Standards Committee，CGSC）报告上，被选定作为 三要素色彩空间基础标准 的原因 [19] 。 为了更好的理解这一点，需要分析 HSV、HSI、HSL（Lightness）的异同。 相同的色调拓扑计算 HSV 和 HSI 色彩空间为了计算机色彩还原服务，本身模型基于 RGB 色彩空间的拓扑变化。如果我们将 RGB 色彩空间中的 白点（White Point） 和 黑点（Black Point） 连线，那么我们就能得到一条由白到灰到黑的渐变对角线，这条线被我们称之为 灰度线（Grey Line） 。 HSV 和 HSI 以灰度线作为法线，取过黑点的平面为投影平面，将 RGB 色彩空间的单位立方体投影到了此平面上。为了区别于 标准 CIE 色度平面（CIE Chromaticity Plane），这个平面被称为 HSL 色度平面（HSL Chromaticity Plane）。 图 2.5.7-2 RGB 色彩空间投影建立 HSL 色度平面（HSL Chromaticity Plane）示意图 HSL 色彩空间，以该平面做为 基准平面 。取从 青色（Cyan）指向红色（Red）的连线作为基准轴，取红色为 0°，青色为 180° 。 假设 RGB 色彩空间内存在颜色 CRGBC_{RGB}C​RGB​​ ，在 HSL 色度平面上的投影为 CRGB′{C_{RGB}}^{\\prime}C​RGB​​​′​​ 。 CRGB′{C_{RGB}}^{\\prime}C​RGB​​​′​​ 与黑点连线和基准轴的逆时针夹角，记为 HHH 。为了更好的表示 CRGBC_{RGB}C​RGB​​ 与其 HSL 色度平面投影的关系，瓦伦西曾在自己的专利 [14] [15] 中将， 与黑点连线的长度称为 色相（Chrominance） 。在 HSL 中，继承了这一点，记为 CCC 。 图 2.5.7-3 HSL 色度平面（HSL Chromaticity Plane）示意图 需要注意的是，引入色相是为了用一个中间变量，把 CRGB′{C_{RGB}}^{\\prime}C​RGB​​​′​​ 的投影平面特性转化为颜色三要素的物理表述 [14] [18] 。色相本身并不是一个标准概念 ，在此处的意义为白点颜色与选定颜色之间的欧式距离，而 并非指 色度（Chromaticity）。它是 HSL 引入的对同色调下颜色饱和度的代称，即狭义色差（sCA）。 所以，为了便于说明，我们将 HSL 的中间量 CCC 按照更贴近的含义，称为色差。 显然， 实际上就是色调（Hue），有 HHH 、 CCC 的关系为： M=max(R,G,B)C=max(R,G,B)−min(R,G,B)H=60∘×{undefined,if C=0G−BC+0,if M=RB−RC+2,if M=GR−GC+4,if M=B {\\displaystyle \\begin{aligned} &M=\\max(R,G,B) \\\\ &C =\\text {max} (R,G,B) - \\text {min} (R,G,B) \\\\ &H = 60^ \\circ \\times {\\begin{cases} \\mathrm {undefined} ,& {\\text{if }} C=0 \\\\ {\\frac {G-B} {C}} + 0 ,& {\\text{if }} M=R \\\\ {\\frac {B-R} {C}} + 2 ,& {\\text{if }} M=G \\\\ {\\frac {R-G} {C}} + 4 ,& {\\text{if }} M=B \\end{cases}} \\end{aligned} } ​​​​​​M=max(R,G,B)​C=max(R,G,B)−min(R,G,B)​H=60​∘​​×​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​undefined,​​C​​G−B​​+0,​​C​​B−R​​+2,​​C​​R−G​​+4,​​​if C=0​if M=R​if M=G​if M=B​​​​ 这样的表示方法有些不尽如人意。因为 RGB 色彩空间在 HSL 色度平面的投影，是一个正六边形。导致了 H′H^{\\prime}H​′​​ 在转换为角度表示上，存在分段的情况。那么如何使其简化为非条件函数表示呢？HSL 采用了 对正六边形投影做了二维拓扑变为单位圆 ，来处理此问题。 图 2.5.7-4 HSL 色度平面（HSL Chromaticity Plane）连续性处理拓扑示意图 取基准轴从黑点指向红色为 X轴正方向，做直角坐标系。 记为 X轴单位长度为 α\\alphaα ，Y轴单位长度为 β\\betaβ ，有： α=R−G⋅cos(60∘)−B⋅cos(60∘)=12(2R−G−B)β=G⋅sin(60∘)−B⋅sin(60∘)=32(G−B) {\\displaystyle \\begin{aligned} &\\alpha =R-G\\cdot \\cos(60^ \\circ)-B\\cdot \\cos(60^ \\circ)={\\tfrac {1}{2}}(2R-G-B) \\\\ &\\beta =G\\cdot \\sin(60^ \\circ)-B\\cdot \\sin(60^ \\circ)={\\tfrac {\\sqrt {3}}{2}}(G-B) \\\\ \\end{aligned} } ​​​​​​α=R−G⋅cos(60​∘​​)−B⋅cos(60​∘​​)=​2​​1​​(2R−G−B)​β=G⋅sin(60​∘​​)−B⋅sin(60​∘​​)=​2​​√​3​​​​​(G−B)​​ 那么，中间量 CCC 可以表示为： C=α2+β2 {\\displaystyle C ={\\sqrt {\\alpha ^{2}+\\beta ^{2}}}} C=√​α​2​​+β​2​​​​​ 同时，色调（Hue） HHH 与 CCC 的关系，就可以转化为 HHH 与 α\\alphaα 、 β\\betaβ 的关系了： H=atan2(β,α) {\\displaystyle \\begin{aligned} &H =\\text{atan2} (\\beta ,\\alpha ) \\end{aligned} } ​​​​H=atan2(β,α)​​ 这样在描述上，就比较简洁了。便于计算机处理。 不同的光亮度与饱和度处理 计算色调之后，HSV、HSI、HSL（Lightness）在 光亮度（Luminance） ，和 饱和度（Saturation） 的处理上就存在不同了。因为以灰度线为法线的缘故，光亮度较好抽象。记各模型光亮度（Luminance）表示分别为 Lvalue=VL_{value} = VL​value​​=V 、 Lintensity=IL_{intensity} = IL​intensity​​=I 、 Llightness=LL_{lightness} = LL​lightness​​=L 。 有 VVV 、 III 、 LLL 与原 RGB 颜色空间内颜色 CRGBC_{RGB}C​RGB​​ 的关系如下： V=max(R,G,B)=MI =avg(R,G,B)=(R+G+B)3L=mid(R,G,B)=(max(R,G,B)+min(R,G,B))2 {\\displaystyle \\begin{aligned} &V = \\max(R,G,B) = M \\\\ &I \\ = \\text{avg} (R,G,B)={\\tfrac {(R+G+B)}{3}} \\\\ &L = \\text {mid} (R,G,B)={\\tfrac {(\\max(R,G,B)+\\min(R,G,B))}{2}} \\end{aligned} } ​​​​​​V=max(R,G,B)=M​I =avg(R,G,B)=​3​​(R+G+B)​​​L=mid(R,G,B)=​2​​(max(R,G,B)+min(R,G,B))​​​​ 如果我们取色调（Hue） HHH 为 50∘50^ \\circ50​∘​​ （偏黄） & 230∘230^ \\circ230​∘​​ （偏蓝）。以色差 CCC 和光亮度构成坐标系，取色差 CCC 为横轴，各模型光亮度参数为纵轴。那么条件下 在 HSV、HSI、HSL（Lightness）的 色差切面（Chrominance Slice） ，就如下图所示： 图 2.5.7-5 HSV、HSI、HSL（Lightness）色差切面（Chrominance Slice）示意图 图中灰色区域为无效值。指定色差 CCC 与光亮度配参构成的切面，需要在坐标范围内避开无效取值。这就意味着 以色差 CCC 作为关键参数的模型，必须以区域限定的方法处理灰区问题 。而 HSV、HSI、HSL（Lightness）被设计的目的，是为计算机色彩还原服务的。以条件限定的方式来处理，将会为计算机运算带来大量逻辑判断，极大的影响图片处理效率。因此，色差 CCC 并不能 被直接用作 HSL 的基础参数。这也是为何不以饱和度（Saturation）的称谓，来直接指代色差 CCC 的原因。HSL 中的饱和度概念，与实际颜色三要素的饱和度定义（狭义）存在差异。这里的饱和度，是对实际物理饱和度概念进行衍射拓展后的结果，即广义饱和度 。 如何减少这些不必要的运算，得到广义饱和度参数呢？直接的做法是对 色差切面（Chrominance Slice） 进行 一定程度的形变 ，使得色差切面能够填充整个坐标平面。由于各模型在设定之初，已经通过取用灰度线为投影法线的方式，在几何定义上抽象出纵轴参数 VVV 、 III 、 LLL 。参数 VVV 、 III 、 LLL 直观体现了颜色三要素的光亮度（Luminance）对物理发光强度的描述 。因此，只需要做水平方向的拉伸（压缩），用拓扑后的横坐标单位，来替换色差 作为模型的饱和度参数即可。记 各模型饱和度（Saturation）分别为 SHSV=SVS_{HSV} = S_{V}S​HSV​​=S​V​​ 、 SHSI=SIS_{HSI} = S_{I}S​HSI​​=S​I​​ 、 SHSL=SLS_{HSL} = S_{L}S​HSL​​=S​L​​ 。 有 SVS_{V}S​V​​ 、 SIS_{I}S​I​​ 、 SLS_{L}S​L​​ 与 CRGBC_{RGB}C​RGB​​ 、色差 CCC 、各自亮度值的关系如下： SV={0,if V=0CV,  otherwiseSI={0,if I=01−min(R,G,B)I,  if I≠0SL={0,if L=1 or L=0C1−∣2L−1∣,      otherwise {\\displaystyle \\begin{aligned} &S_{V}={ \\begin{cases} {0}, &{\\text{if }} V = 0 \\\\ {\\frac {C}{V}}, \\ \\ &{\\text{otherwise}} \\end{cases}} \\\\ &S_{I}={ \\begin{cases} {0}, &{\\text{if }} I = 0 \\\\ {1-{\\frac {\\min(R,G,B)}{I}}}, \\ \\ &{\\text{if }} {I \\neq 0} \\end{cases}} \\\\ &S_{L}={ \\begin{cases} {0}, &{\\text{if }} L = 1 {\\text{ or }} L = 0 \\\\ {\\frac {C}{1-|2L-1|}}, \\ \\ \\ \\ \\ \\ &{\\text{otherwise}} \\end{cases}} \\end{aligned} } ​​​​​​S​V​​=​⎩​⎨​⎧​​​0,​​V​​C​​,  ​​​if V=0​otherwise​​​S​I​​=​⎩​⎨​⎧​​​0,​1−​I​​min(R,G,B)​​,  ​​​if I=0​if I≠0​​​S​L​​=​⎩​⎨​⎧​​​0,​​1−∣2L−1∣​​C​​,      ​​​if L=1 or L=0​otherwise​​​​ 转换后，的 色差切面（Chrominance Slice） 就 比较连续 了： 图 2.5.7-6 HSV、HSI、HSL（Lightness）切面拓扑示意图 很容易看出 HSL（Lightness）在保证自身任意选定色调 HHH 时的色差切面不包含无效区域的同时，还具有 HSI 本身对人眼观察颜色还原的特点。而其计算过程中依赖的条件判断，则可以使用绝对值运算代替。可以说，HSL（Lightness）结合了 HSV、HSI 的优点，且一定程度上避开了两者的缺陷 。 三要素色彩空间的配色函数 现在，所有要素准备齐全。如果记目标颜色为 CHSLC_{HSL}C​HSL​​ ，则 HSL 配色函数 如下： CHSL=H⋅Hue+S⋅Saturation+L⋅Luminance=Vector[H,S,L] {\\displaystyle C_{HSL} = H \\cdot Hue + S \\cdot Saturation + L \\cdot Luminance = Vector[H, S, L]} C​HSL​​=H⋅Hue+S⋅Saturation+L⋅Luminance=Vector[H,S,L] 如果记 CHSLC_{HSL}C​HSL​​ 在 RGB 色彩空间对应颜色为 CRGB=(R,G,B)C_{RGB} = (R, G, B)C​RGB​​=(R,G,B) ，记有 CRGB→CHSLC_{RGB} \\rightarrow C_{HSL}C​RGB​​→C​HSL​​ 的转换函数为 FFF ，则 CHSL→CRGBC_{HSL} \\rightarrow C_{RGB}C​HSL​​→C​RGB​​ 的反向过程就为 F−1F^{-1}F​−1​​ 。有之前使用的通用中间量： α=12(2R−G−B)β=32(G−B)      C=α2+β2≈(max(R,G,B)−min(R,G,B))=range(R,G,B) {\\displaystyle \\begin{aligned} &\\quad \\quad \\quad \\quad \\quad \\alpha = {\\tfrac {1}{2}}(2R-G-B) \\quad \\quad \\quad \\beta = {\\tfrac {\\sqrt {3}}{2}}(G-B) \\ \\ \\ \\ \\ \\ \\\\ & C = {\\sqrt {\\alpha ^{2}+\\beta ^{2}}} \\approx (\\max(R,G,B) - min(R,G,B)) = \\text {range} (R,G,B) \\\\ \\end{aligned} } ​​​​​​α=​2​​1​​(2R−G−B)β=​2​​√​3​​​​​(G−B)      ​C=√​α​2​​+β​2​​​​​≈(max(R,G,B)−min(R,G,B))=range(R,G,B)​​ 存粹使用 α\\alphaα 、 β\\betaβ 会使计算过于复杂，因此中间量 CCC 在处理时大多数都是用原有定义代替。 α\\alphaα 、 β\\betaβ 仅用于角度计算。从之前讲解可知，这样做并不会导致偏色，而只会影响 HSL 色度平面的几何样式。结合之前的完整推导过程，带入 α\\alphaα 、 β\\betaβ 、 CCC ，能得到从 RGB 到 HSL 的映射 FFF 为： FHSV={H=atan2(β,α)S=range(R,G,B)⋅max(R,G,B)−1V=max(R,G,B)FHSI={H=atan2(β,α)S={0,if I=01−min(R,G,B)⋅avg(R,G,B)−1,  if I≠0I =avg(R,G,B)=(R+G+B)3FHSL={H=atan2(β,α)S=12⋅range(R,G,B)⋅min(L, 1−L)−1L=mid(R,G,B)=(max(R,G,B)+min(R,G,B))2 {\\displaystyle \\begin{aligned} &F_{HSV} ={ \\begin{cases} & H = \\text {atan2} (\\beta ,\\alpha ) \\\\ & S = \\text {range} (R,G,B) \\cdot \\max(R,G,B)^{-1} \\\\ & V = \\max(R,G,B) \\end{cases} } \\\\ &F_{HSI} ={ \\begin{cases} & H = \\text {atan2} (\\beta ,\\alpha ) \\\\ & S = { \\begin{cases} {0}, &{\\text{if }} I = 0 \\\\ 1- {\\min(R,G,B)} \\cdot {\\text {avg} (R,G,B)^{-1}}, \\ \\ &{\\text{if }} {I \\neq 0} \\end{cases}} \\\\ & I \\ = \\text {avg} (R,G,B)={\\tfrac {(R+G+B)}{3}} \\end{cases} } \\\\ &F_{HSL} ={ \\begin{cases} & H = \\text {atan2} (\\beta ,\\alpha ) \\\\ & S = \\tfrac {1}{2} \\cdot \\text {range} (R,G,B) \\cdot {\\min(L,\\ 1 - L)}^{-1} \\\\ & L = \\text {mid} (R,G,B)={\\tfrac {(\\max(R,G,B)+\\min(R,G,B))}{2}} \\end{cases} } \\end{aligned} } ​​​​​​F​HSV​​=​⎩​⎪​⎨​⎪​⎧​​​​​​​​H=atan2(β,α)​S=range(R,G,B)⋅max(R,G,B)​−1​​​V=max(R,G,B)​​​F​HSI​​=​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​​​​​​H=atan2(β,α)​S={​0,​1−min(R,G,B)⋅avg(R,G,B)​−1​​,  ​​​if I=0​if I≠0​​​I =avg(R,G,B)=​3​​(R+G+B)​​​​​F​HSL​​=​⎩​⎪​⎨​⎪​⎧​​​​​​​​H=atan2(β,α)​S=​2​​1​​⋅range(R,G,B)⋅min(L, 1−L)​−1​​​L=mid(R,G,B)=​2​​(max(R,G,B)+min(R,G,B))​​​​​​ 而从 HSL 到 RGB ，由于色度被作为了传入参数，在转换为 RGB 时就需要处理扇区划分问题。记 ∠RG:H∈[0∘,120∘)\\angle_{RG}: H \\in [0^{\\circ}, 120^{\\circ})∠​RG​​:H∈[0​∘​​,120​∘​​) ， ∠GB:H∈[120∘,240∘)\\angle_{GB}: H \\in [120^{\\circ}, 240^{\\circ})∠​GB​​:H∈[120​∘​​,240​∘​​) ， ∠BR:H∈[240∘,360∘)\\angle_{BR}: H \\in [240^{\\circ}, 360^{\\circ})∠​BR​​:H∈[240​∘​​,360​∘​​) ，其中 H=0∘H = 0^{\\circ}H=0​∘​​ 或 H=360∘H = 360^{\\circ}H=360​∘​​ 时，有 (R,G,B)=(1, 0, 0)(R,G,B) = (1,\\ 0,\\ 0)(R,G,B)=(1, 0, 0) 。则映射 F−1F^{-1}F​−1​​ 为： H, ∠const∈[0∘, 360∘)FHSV−1={k={(∠const+H60∘) mod 6}sector=max(0, min(k, 4−k, 1))f(H,S,V)∠const=f∠consthsv=V−VS⋅sector⇒(R,G,B)=FHSV−1(H,S,V)=(f300∘hsv, f180∘hsv, f60∘hsv)FHSI−1={k={(∠const+H60∘) mod 6}sector=max(0, min(k, 4−k, 1))f(H,S,I)∠const=f∠consthsi=I−IS⋅sector⇒(R,G,B)=FHSI−1(H,S,I)=(f300∘hsi, f180∘hsi, f60∘hsi)FHSL−1={k={(∠const+H60∘) mod 6}sector=max(0, min(k, 4−k, 1))f(H,S,L)∠const=f∠consthsl=L−LS⋅sector⇒(R,G,B)=FHSL−1(H,S,L)=(f300∘hsl, f180∘hsl, f60∘hsl) {\\displaystyle \\begin{aligned} H ,\\ {\\angle_{const}} &\\in [0^ \\circ,\\ 360^ \\circ) \\\\ {F_{HSV}}^{-1} &= { \\begin{cases} & k = \\{(\\tfrac {\\angle_{const} + H}{60^ \\circ})\\ \\bmod\\ 6\\} \\\\ & sector = \\max(0,\\ \\min(k,\\ 4-k,\\ 1)) \\\\ & f(H,S,V)_{\\angle_{const}} = f_{\\angle_{const}} ^{hsv} = V-VS \\cdot sector \\end{cases} } \\\\ &\\Rightarrow (R,G,B) = {F_{HSV}}^{-1}(H,S,V) = (f_{300^ \\circ}^{hsv},\\ f_{180^ \\circ}^{hsv},\\ f_{60^ \\circ}^{hsv}) \\\\ \\\\ {F_{HSI}}^{-1} &= { \\begin{cases} & k = \\{(\\tfrac {\\angle_{const} + H}{60^ \\circ})\\ \\bmod\\ 6\\} \\\\ & sector = \\max(0,\\ \\min(k,\\ 4-k,\\ 1)) \\\\ & f(H,S,I)_{\\angle_{const}} = f_{\\angle_{const}} ^{hsi} = I-IS \\cdot sector \\end{cases} } \\\\ &\\Rightarrow (R,G,B) = {F_{HSI}}^{-1}(H,S,I) = (f_{300^ \\circ}^{hsi},\\ f_{180^ \\circ}^{hsi},\\ f_{60^ \\circ}^{hsi}) \\\\ \\\\ {F_{HSL}}^{-1} &= { \\begin{cases} & k = \\{(\\tfrac {\\angle_{const} + H}{60^ \\circ})\\ \\bmod\\ 6\\} \\\\ & sector = \\max(0,\\ \\min(k,\\ 4-k,\\ 1)) \\\\ & f(H,S,L)_{\\angle_{const}} = f_{\\angle_{const}} ^{hsl} = {L - LS \\cdot sector} \\end{cases} } \\\\ &\\Rightarrow (R,G,B) = {F_{HSL}}^{-1}(H,S,L) = (f_{300^ \\circ}^{hsl},\\ f_{180^ \\circ}^{hsl},\\ f_{60^ \\circ}^{hsl}) \\\\ \\end{aligned} } ​H, ∠​const​​​F​HSV​​​−1​​​​​F​HSI​​​−1​​​​​F​HSL​​​−1​​​​​​​∈[0​∘​​, 360​∘​​)​=​⎩​⎪​⎨​⎪​⎧​​​​​​​​k={(​60​∘​​​​∠​const​​+H​​) mod 6}​sector=max(0, min(k, 4−k, 1))​f(H,S,V)​∠​const​​​​=f​∠​const​​​hsv​​=V−VS⋅sector​​​⇒(R,G,B)=F​HSV​​​−1​​(H,S,V)=(f​300​∘​​​hsv​​, f​180​∘​​​hsv​​, f​60​∘​​​hsv​​)​=​⎩​⎪​⎨​⎪​⎧​​​​​​​​k={(​60​∘​​​​∠​const​​+H​​) mod 6}​sector=max(0, min(k, 4−k, 1))​f(H,S,I)​∠​const​​​​=f​∠​const​​​hsi​​=I−IS⋅sector​​​⇒(R,G,B)=F​HSI​​​−1​​(H,S,I)=(f​300​∘​​​hsi​​, f​180​∘​​​hsi​​, f​60​∘​​​hsi​​)​=​⎩​⎪​⎨​⎪​⎧​​​​​​​​k={(​60​∘​​​​∠​const​​+H​​) mod 6}​sector=max(0, min(k, 4−k, 1))​f(H,S,L)​∠​const​​​​=f​∠​const​​​hsl​​=L−LS⋅sector​​​⇒(R,G,B)=F​HSL​​​−1​​(H,S,L)=(f​300​∘​​​hsl​​, f​180​∘​​​hsl​​, f​60​∘​​​hsl​​)​​ 即： (R,G,B)=F−1(H,S,L)=(f300∘, f180∘, f60∘) (R,G,B) = {F}^{-1}(H,S,L) = (f_{300^ \\circ},\\ f_{180^ \\circ},\\ f_{60^ \\circ}) (R,G,B)=F​−1​​(H,S,L)=(f​300​∘​​​​, f​180​∘​​​​, f​60​∘​​​​) 可以看出，排除 CRGB→CHSLC_{RGB} \\rightarrow C_{HSL}C​RGB​​→C​HSL​​ 后 HSL 代表值的不同外， F−1F^{-1}F​−1​​ 并不存在显著差异。这正是因为 HSV、HSI、HSL（Lightness）三者的色彩空间设定，在本质上是一样的而产生的结果。 差异只存在于几何切面的抽象上。 显然 HSL 模型直观地体现了颜色三要素的两个重要事实，即： 亮度与图像的色彩信息无关，色彩信息体现自其色调和饱和度。这使得 HSL 色彩空间更适合在，对需要偏重于颜色三要素基础，进行色彩基础分析和检测的场景。 所以 HSL 的缺陷也很明显。对比 CIE LAB 和 CIE LUV ，虽然 HSL 具有较好的对色彩生理学感知还原的特点，但 HSL 在 RGB 转换上却没法像 LAB 与 LUV 一样快速。后者在指定白点后，就能一线性关系将色彩转换到 XYZ 色彩空间，而 XYZ 到 RGB 只需要一个固定矩阵即可。这就意味着 HSL 在 RGB 换算上更为复杂 。 另外，HSL 和 LAB 两者，都没有很好的处理到颜色压缩存储和数据传输方面的设计。除了精准调节和对比场景会使用 HSL 外（这种场景 CIE LAB 也能胜任且更精确），HSL 相较于 CIE LAB 和 CIE LUV 色彩空间（尤其是与 LUV 相比）并没有太大的优势。因此，各个组织（包括 CIE、ITU等）至今仍在尝试用更为先进的色彩统一化方案解决“均色问题” 。 虽然存在各种弊端，但 HSL 对数据传输的探索和创造性的色彩空间设定，依旧 为后来 ITU 制定 YUV 色彩格式提供了不少思路上的帮助 。使现代色彩存储体系，在结合 CIE 1976 UCS（即 LAB 与 LUV）的归一化和 HSL 的坐标设定的基础上，得以得到拓展。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_6.html":{"url":"Chapter_2/Language/cn/Docs_2_6.html","title":"2.6 色彩的存储","keywords":"","body":"2.6 色彩的存储 1960年，来自 贝尔实验室（Bell Laboratories） 的 穆罕默德·阿塔拉（Mohamed M. Atalla，1924 - 2009） 和 姜大元（Dawon Kahng，1931 - 1992） ，发现 金属氧化物半导体（MOS [Metal Oxide Semiconductor]） 可以借由场效应进行信息存储的现象，成功开发了 金属氧化物半导体场效应晶体管（MOSFET [Metal Oxide Semiconductor Field Effect Transistor]） 。随后，贝尔实验室（Bell Laboratories）联合喷气推进实验室（Jet Propulsion Laboratory）与其他研究机构，就 “提高图像在计算机处理过程中的效果增强” ，提出了一系列用于数字图像处理（Digital Image Processing）的方法。其中 “关于如何利用有限的物理存储空间来保存图片像素点” 的部分，为图片灰度单色存储的提供了可行方案 [44]。 这一系列理论于 1964年 应用在了徘徊者7号月面探测器（Space Detector Ranger 7）的计算机软硬件设计上，并以此得到了 4300 张高分辨率月面摄影 。 月面壮举极大的鼓舞了计算机图形学的发展，同时也让图片压缩存储需求开始变得至关重要。在此背景下，1979年，首个 单片数字信号处理器（DSP [Digital Signal Processor]） 诞生了。数字信号处理器通过 离散余弦变换（DCT） 技术对图片进行了 数模转换 。该技术使图像像素能够以 0-1 单字节码（1-bit）的形式，存储在计算机晶体管中，形成了最初的 1-bit 灰度单色格式 [45]。 让离散化存储颜色成为了计算机图像像素存储的物理共识。 随着 19世纪 80年代个人电脑的快速发展。灰度图格式也从 单字节码（1-bit） ，经过 IBM 单色显示屏适配器（MDA [Monochrome Display Adapter]） 2-bit 格式 ，Commodore 128 所搭载 8563 显示控制器（VDC [Video Display Controller]） 提供的 4-bit 格式 ，演变到了Apple II 与 IBM 5150 的 8-bit 单色格式 。 1981 年，IBM 结合 CIE 1976 UCS 在 RGB 色彩空间上的补充，开发并发布了携带彩色数据编解码 IBM 彩色图形适配器（CGA [Color Graphics Adapter]） 的 IBM 5153 。 标志着计算机正式进入了彩色时代。自此开启了计算机 现代色彩格式（Modern Color Format） 的大门。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_6_1.html":{"url":"Chapter_2/Language/cn/Docs_2_6_1.html","title":"2.6.1 色彩格式（Color Format）与色彩存储","keywords":"","body":"2.6.1 色彩格式（Color Format） 色彩格式（Color Format） 包含了计算机对颜色的 存储格式（Data Format） 和 色彩格式空间（Color Format Space） 两部分。 同其他工业设备一样，计算机也受自身软硬件的限制，而需要特定的色彩模式。考虑到其本身是一种仅应用于计算机工业体系内（虽然现在计算机无处不在）的 设备相关色彩空间（Device Dependent Color Space），业内将之称为 色彩格式空间（Color Format Space） ，简称为 格式空间（Format Space） 。 正如前文所提，色彩格式根据参考设备无关色彩空间的不同，被分为 RGB 色彩格式和 YUV 色彩格式。两者理论均衍生自 CIE 1976 UCS 的补充色彩空间方案，并在之后被分别设备相关化。 RGB 色彩格式，即 原色格式（Primaries Format） ，属于 CIE RGB 色彩空间体系； YUV 色彩格式，即 传输格式（Transport Format） ，根据 CIE LUV 特性被分属为 CIE XYZ 色彩空间体系。 RGB 与 YUV 共同组成了现代计算机色彩格式的两大分类。 为了更好的进行对比说明，我们用经典的彩色鹦鹉图片，来辅助说明不同色彩格式对图片携带颜色信息的影响。 图 2.6.1-1 模板彩色鹦鹉原色图片 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_6_2.html":{"url":"Chapter_2/Language/cn/Docs_2_6_2.html","title":"2.6.2 RGB 体系色彩格式","keywords":"","body":"2.6.2 RGB 体系色彩格式 原色格式（Primaries Format），或 RGB 体系色彩格式最大的特点就是在于，其对颜色表示的富集程度和存储空间大小密切相关。可以说 RGB 色彩格式中，每个通道能够占用的存储空间越大，则能够表示的颜色越多 。非常的简单粗暴。统一的，RGB 色彩格式的格式空间，即为 归一化的 CIE RGB 色彩空间 。 3-bit RGB 3-bit RGB 色彩格式 采用了红绿蓝各 1-bit 的存储格式。因此，3-bit RGB 最多只能表示 23=82^3 = 82​3​​=8 种颜色： 图 2.6.2-1-1 4-bit RGBI 可表示的所有颜色 以鹦鹉图为例，在 3-bit RGB 格式下的展示效果如下： 图 2.6.2-1-2 3-bit RGB 表示的鹦鹉图 此格式被广泛运用于 Oric 和 NEC 的 PC-8801 与 PC-9801 机型 上。 4-bit RGBI 1981年，IBM 在其 CGA 中，以 4-bit RGBI 格式 对彩色图片进行了存储。在此格式下，颜色被分为 RGBI 4个通道，每个通道各用 1-bit 表示。因此，RGBI 最多只能表示 23×2=162^3 \\times 2 = 162​3​​×2=16 种颜色： 图 2.6.2-2-1 4-bit RGBI 可表示的所有颜色 以鹦鹉图为例，在 4-bit RGBI 格式下的展示效果如下： 图 2.6.2-2-2 4-bit RGBI 表示的鹦鹉图 此格式 只有 IBM 5153 在使用 。 6-bit RGB 6-bit RGB 色彩格式 采用了红绿蓝各 2-bit 的存储格式。因此，6-bit RGB 最多只能表示 (22)3=64(2^2)^3 = 64(2​2​​)​3​​=64 种颜色： 图 2.6.2-3-1 6-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 6-bit RGB 格式下的展示效果如下： 图 2.6.2-3-2 6-bit RGB 表示的鹦鹉图 此格式在 IBM 的增强图形适配器（EGA [Enhanced Graphics Adapter]）上被首次运用 。并在之后伴随了多个 IBM 主机版本。 9-bit RGB 9-bit RGB 色彩格式 采用了红绿蓝各 3-bit 的存储格式。因此，9-bit RGB 最多只能表示 (23)3=512(2^3)^3 = 512(2​3​​)​3​​=512 种颜色： 图 2.6.2-4-1 9-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 9-bit RGBI 格式下的展示效果如下 图 2.6.2-4-2 9-bit RGB 表示的鹦鹉图 此格式最早在 1985年 的土星520ST（Atari 520ST）机型 上被使用。 12-bit RGB 12-bit RGB 色彩格式 采用了红绿蓝各 4-bit 的存储格式。因此，12-bit RGB 最多能表示 (24)3=4096(2^4)^3 = 4096(2​4​​)​3​​=4096 种颜色： 图 2.6.2-5-1 12-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 12-bit RGBI 格式下的展示效果如下 图 2.6.2-5-2 12-bit RGB 表示的鹦鹉图 此格式被运用在 Apple IIGS、土星 STE 系列 和 世嘉（Sega）Game Gear 游戏机 上。 15-bit RGB 15-bit RGB 色彩格式 采用了红绿蓝各 5-bit 的存储格式。因此，15-bit RGB 最多能表示 (25)3=32,768(2^5)^3 = 32,768(2​5​​)​3​​=32,768 种颜色： 图 2.6.2-5-1 15-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 15-bit RGBI 格式下的展示效果如下 图 2.6.2-5-2 15-bit RGB 表示的鹦鹉图 此格式被运用在 索尼的 PS1 游戏机 上。 16-bit RGB（RGB565） 16-bit RGB 色彩格式 采用了红蓝各 5-bit ，而绿色 6-bit 的存储格式。因此，16-bit RGB 最多只能表示 (25)2×(26)=65,536(2^5)^2 \\times (2^6) = 65,536(2​5​​)​2​​×(2​6​​)=65,536 种颜色： 图 2.6.2-6-1 16-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 16-bit RGBI 格式下的展示效果如下 图 2.6.2-6-2 16-bit RGB 表示的鹦鹉图 此格式被运用在 携带有扩展图形阵列（XGA [Extended Graphics Array]）的 IBM 机型 上。 18-bit RGB 18-bit RGB 色彩格式 采用了红绿蓝各 6-bit 的存储格式。因此，18-bit RGB 最多能表示 (26)3=262,144(2^6)^3 = 262,144(2​6​​)​3​​=262,144 种颜色： 图 2.6.2-7-1 18-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 18-bit RGBI 格式下的展示效果如下 图 2.6.2-7-2 18-bit RGB 表示的鹦鹉图 此格式被运用在 IBM 8514 ，以及 IBM 携带视频图像阵列（VGA [Video Graphics Array]） 或 多色图像阵列（MCGA [Multi-Color Graphics Array]）显卡 的设备上。 24-bit RGB & 32-bit RGBA8888 24-bit RGB 色彩格式 采用了红绿蓝各 8-bit 的存储格式。因此，24-bit RGB 最多能表示多达 (28)3=2563=16,777,216(2^8)^3 = 256^3 = 16,777,216(2​8​​)​3​​=256​3​​=16,777,216 种颜色： 图 2.6.2-8-1 24-bit RGB 可表示的所有颜色 以鹦鹉图为例，在 24-bit RGBI 格式下的展示效果如下 图 2.6.2-8-2 24-bit RGB 表示的鹦鹉图 这一格式最早于 1998年，被应用于 IBM 携带超级视频图像阵列（SVGA [Super Video Graphics Array]）显卡 的设备上。由于 24-bit 对应 RGB 三通道各 8-bit 的特性和硬件 RAM 非常契合，使此格式至今仍为最常用的 RGB 色彩格式。配合额外 Alpha 透明度通道，24-bit RGB 色彩格式可以被扩充为 32-bit RGBA8888 色彩格式，进一步提升颜色精细度。 显然，RGB 色彩格式和物理存储空间的扩展紧密相关，其每一次可表示色阶的扩充，都意味着一次存储介质和空间的显著提升。 此特点决定了，当市面上绝大多数显卡的存储及处理能力没有发展的情况下，更细腻的 RGB 色彩格式也不太可能得到推广。同理，广泛应用于图像传输的 YUV 色彩格式则是规格驱动，其更多依赖于传输协议的演变和数据带宽的更新迭代。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/Docs_2_6_3.html":{"url":"Chapter_2/Language/cn/Docs_2_6_3.html","title":"2.6.3 YUV 体系色彩格式","keywords":"","body":"2.6.3 YUV 体系色彩格式 传输格式（Transport Format） ，即当下我们常用的 YUV 色彩格式也被称为 YCbCr、YPbPr、Y′UV 色彩格式 。其中，Y/Y′ 指代光亮度分量，U/Cb/Pb 指代蓝色色度分量，V/Cr/Pr 指代红色色度分量 。YUV 色彩格式受启发自，CIE LUV 中用与 xyY 色度图有线性转换关系的 uv 分量表示平面色彩信息的思想，最初被 国际电信联盟无线电通信部门（ITU-R [International Telecommunication Union Radiocommunication Sector]） 做为 彩色图像编解码流水线（Color Image Pipeline） 的一部分提出，用来 对图片进行压缩传输 。 在之前的讨论中我们知道，CIE LUV 在指定白点情况下，可以直接将其所含色彩经由线性变换转换到 CIE XYZ 色彩空间，再从 CIE XYZ 依托固定转换矩阵，变换到 CIE RGB 色彩空间。将两个过程进行合并可知，存在从 LUV 到 RGB 的固定转换矩阵。因此，做为 CIE LUV 思路衍生下的实践产物，YUV 同样也具有这一特点。不同于 LUV 设备无关，YUV 是设备相关的。其受限于外部因素，对整体色度平面的处理上有一定程度的调整，使 YUV 根据采用规格的不同，有着不同的设备相关化调参。不过设备相关化处理带来的弊端，就是 YUV 相较于 LUV 来说色差变换更为不均匀。 当前 YUV 的常用规格 有三种：BT.601、BT.709、BT.2020 。其中，BT.601 最早于 1982 年提出，最新一次修订于 2011年，适用于 标准画质电视（SDTV [Standard Definition Television]） [46] 。BT.709 最早于 1990 年提出，最新一次修订于 2015年，适用于 高清画质电视（HDTV [High Definition Television]） [47] 。BT.2020 最早于 2012 年提出，最新一次修订于 2015年，适用于 超高清画质电视（UHDTV [Ultra-High Definition Television]） [48] 。 YUV 是目前唯一做到了工程意义上打通图像数据压缩、传输和存储的色彩格式。为了便于说明，我们这里假设 Y、U、V 通道皆以当下主流的 8-bit 形式存放数据。 YUV 的数字电信号特征 YUV 被设计的目的主要就是为了进行数据传输，而数据传输就意味着数模信号转换。所以，根据可用电信号区间，YUV 存在两种有效范围：狭隘区间（Narrow Range）、完整区间（Full Range） 。 狭隘区间 中，Y通道取值范围为 [16, 235][16,\\ 235][16, 235] ，U、V通道取值范围为 [16, 240][16,\\ 240][16, 240] ； 完整区间 中，Y、U、V通道取值范围均为 [0, 255][0,\\ 255][0, 255] ； 大多数应用场景下，YUV 都以狭隘范围表示 ，究其原因是由电讯号传输特性决定的。在广播电视系统中，为了防止过高和过低的信号造成 临界电平过载（Critical Level Overload） 现象，会人为的在信号可用模拟电平区段上，预留出一定的 “保护带”，保护最高位和最低位的电平不被使用 。为了便于指代，电气学上把“保护带”称为 保护范围（Protection Range），被保护的最高位和最低位电平称为 保护电平（Protection Level） ，用于指代零信号量的电平被称为 消隐电平（Blanking Level） ，可用电平区段的上边界称为 白电平（White Level） ，下边界称为 黑电平（Black Level） ，黑白电平之间就是 信号电平（Signal Level） 了。 对于 8-bit 传输信号来说，保护电平为 0 mV0 \\ mV0 mV 和 255 mV255 \\ mV255 mV 。Y通道取 16 mV16 \\ mV16 mV 为消隐电平，可用电平区间上下分别预留了 [236, 254][236,\\ 254][236, 254] 和 [1, 15][1,\\ 15][1, 15] 的保护范围；U、V 通道则以 128 mV128 \\ mV128 mV 为消隐电平，可用电平区间上下分别预留了 [241, 254][241,\\ 254][241, 254] 和 [1, 15][1,\\ 15][1, 15] 的保护电平。所有可用的信号电平，分别组成了 Y、U、V 三通道取值范围的狭隘区间。 图 2.6.3-1 YUV Y通道信号电平分配图 [49] 图 2.6.3-2 YUV U通道信号电平分配图 [49] 图 2.6.3-3 YUV V通道信号电平分配图 [49] 对于不需要进行数据传输的场景，就不再需要保护电平了。 此时 8-bit 信号电平可以取用到 [0, 255][0,\\ 255][0, 255] 的完整范围表示。 解释清楚信号范围划分，接下来就该说明 ITU 对于 YUV 色彩格式下的 RGB YUV 颜色互转的定义了。在 YUV 和 RGB 的转换上，狭隘范围（Narrow）和完整范围（Full）并不影响推算，仅影响最终的转换矩阵结果。 YUV 与 RGB 间的相互转换 从工程角度出发，YUV 需要尽可能简单的处理过程。所以，YUV 在采用 LUV 转换思路的基础上结合了 HSL 的坐标处理思想，以 XYZ 坐标系下 xyY 色度图所在平面，截取色域三角形有效范围构建质心坐标的形式，进行了 YUV 色彩格式的格式空间关键要素定义。 不同于 LUV 和 HSL，YUV 并没有对完整的可见光色域进行拓扑变换，而是需要 手动设定 RGB 三原色的代表点和质心 ，来确定围成的色域范围和坐标系。因此，YUV 的色彩空间天然就是有缺陷的。不过，放弃完整色域换来了 YUV 足够通用的方法论。后续规格上的更新，只用按照工程测定结果来进行色域范围的调整，就能延续同一套计算过程满足新的需求。 这种可根据情况修整的延展性，也是 YUV 被广泛运用的原因之一。 那么，在 YUV 中 RGB 三原色的选取是否就是完全随意的呢？ 答案是否定的。 RGB 三原色代表点的选取，完全依赖于设备本身对三原色的设定。即，设备的 RGB 色彩格式的格式空间决定了设备的三原色。由于不同的设备间差异可能非常大，想要使 YUV 格式通用，就必须在 YUV 体系的色彩格式规格制定时，固定做为标准的 RGB 三色坐标，通过自身格式空间的线性特征，来抹平不同设备间的转换误差。 我们假设 YUV 格式空间中，用于参照的 R点取自 xyY 色度图中坐标 R(xR, yR)R(x_R,\\ y_R)R(x​R​​, y​R​​) ，G点取自 xyY 色度图中坐标 G(xG, yG)G(x_G,\\ y_G)G(x​G​​, y​G​​) ，B点取自 xyY 色度图中坐标 B(xB, yB)B(x_B,\\ y_B)B(x​B​​, y​B​​) 。有下图： 图 2.6.3-4 YUV 格式空间在 xyY 色度图上的色域裁剪说明 根据图示可知，落于 RGB 围成三角形范围内的任意点 CCC ，与三角形顶点存在关系： C=B+(gB+rB)=R+(bR+gR)=G+(bG+rG)⇒C−G=b⋅(B−G)+r⋅(R−G) {\\displaystyle \\begin{aligned} &C = B + (gB + rB) = R + (bR + gR) = G + (bG + rG) &\\Rightarrow \\\\ &C - G = b \\cdot (B - G) + r \\cdot (R - G) \\end{aligned} } ​​​​​C=B+(gB+rB)=R+(bR+gR)=G+(bG+rG)​C−G=b⋅(B−G)+r⋅(R−G)​​​⇒​​ 取质心 WWW 为轴心。指定 YUV 色彩空间下 Y+U+V=1Y + U + V = 1Y+U+V=1 ，选择 U=Cb⋅(B−W)U = C_b \\cdot (B - W)U=C​b​​⋅(B−W) 、 V=Cr⋅(R−W)V = C_r \\cdot (R - W)V=C​r​​⋅(R−W) 为坐标轴， CbC_bC​b​​ 、 CrC_rC​r​​ 为归一化因子。有 YYY 有效区间为 [0, 1][0,\\ 1][0, 1] ， UUU 有效区间为 [−Umax, Umax][-U_{max},\\ U_{max}][−U​max​​, U​max​​] ， VVV 有效区间为 [−Vmax, Vmax][-V_{max},\\ V_{max}][−V​max​​, V​max​​] 。 这里以 YUV 对应规格选定的 RGB 三色电信号，经过 电位差伽马预矫正（Gamma pre-corrected） 得到的归一化电平测量值 (WR ,WG ,WB)(W_R \\ , W_G \\ , W_B )(W​R​​ ,W​G​​ ,W​B​​) 为依据 [46] [47] [48] ，取 YUV 光亮度参数有线性公式 Y=WR⋅R+WG⋅G+WB⋅BY = W_R \\cdot R + W_G \\cdot G + W_B \\cdot BY=W​R​​⋅R+W​G​​⋅G+W​B​​⋅B 。则由点 CCC 与质心 WWW 的向量差 C−W=(C−G)−(W−G)C - W = (C -G)-(W-G)C−W=(C−G)−(W−G) 推得： Y=WR⋅R+WG⋅G+WB⋅BU=Umax1−WB⋅(B−Y)V=Vmax1−WR⋅(R−Y) {\\displaystyle \\begin{aligned} Y &= W_R \\cdot R + W_G \\cdot G + W_B \\cdot B \\\\ U &= {\\tfrac {U_{max}} {1 - W_B}} \\cdot (B - Y) \\\\ V &= {\\tfrac {V_{max}} {1 - W_R}} \\cdot (R - Y) \\\\ \\end{aligned} } ​Y​U​V​​​​=W​R​​⋅R+W​G​​⋅G+W​B​​⋅B​=​1−W​B​​​​U​max​​​​⋅(B−Y)​=​1−W​R​​​​V​max​​​​⋅(R−Y)​​ 上式即为 YUV 格式空间的狭义配色函数 。需要注意的是，测量值 (WR ,WG ,WB)(W_R \\ , W_G \\ , W_B )(W​R​​ ,W​G​​ ,W​B​​) 是规格强相关的。其取值仅取决于规格中指定的 RGB 三色对应电信号电配比。 根据 RGB 与 YUV 归一化后 Y+U+V=R+G+B=1Y + U + V = R + G + B = 1Y+U+V=R+G+B=1 的数理特征，很容易就能证明 YUV 和 RGB 的线性等价关系： Y+U+V=R+G+B=1=1WG(WG⋅R+WG⋅G+WG⋅B)=1WG(Y+(WG−WR)⋅G+(WG−WB)⋅B)=3Y+WG−WRWG⋅(R−Y)+WG−WBWG⋅(B−Y)=3Y+WG−WRWG⋅1−WRVmax⋅V+WG−WBWG⋅1−WBUmax⋅UR+G+B=(Y+1−WRVmax⋅V)+(Y+WRWG⋅1−WRVmax⋅V+WBWG⋅1−WBUmax⋅U)+(Y+1−WBUmax⋅U) {\\displaystyle \\begin{aligned} Y + U + V &= R + G + B = 1 \\\\ &= {\\tfrac {1}{W_G}}\\left( W_G \\cdot R + W_G \\cdot G + W_G \\cdot B \\right) \\\\ &= {\\tfrac {1}{W_G}}\\left( Y + (W_G - W_R) \\cdot G + (W_G - W_B) \\cdot B \\right) \\\\ &=3Y + {\\tfrac {W_G - W_R}{W_G}} \\cdot (R - Y) + {\\tfrac {W_G - W_B}{W_G}} \\cdot (B - Y) \\\\ &=3Y + {\\tfrac {W_G - W_R}{W_G}} \\cdot {\\tfrac {1 - W_R}{V_{max}} \\cdot V} + {\\tfrac {W_G - W_B}{W_G}} \\cdot {\\tfrac {1 - W_B}{U_{max}} \\cdot U} \\\\ R + G + B &=\\left( Y + {\\tfrac {1 - W_R}{V_{max}} \\cdot V} \\right) + \\left( Y + {\\tfrac {W_R}{W_G}} \\cdot {\\tfrac {1 - W_R}{V_{max}} \\cdot V} + {\\tfrac {W_B}{W_G}} \\cdot {\\tfrac {1 - W_B}{U_{max}} \\cdot U} \\right) + \\left( Y + {\\tfrac {1 - W_B}{U_{max}} \\cdot U} \\right) \\end{aligned} } ​Y+U+V​​​​​R+G+B​​​=R+G+B=1​=​W​G​​​​1​​(W​G​​⋅R+W​G​​⋅G+W​G​​⋅B)​=​W​G​​​​1​​(Y+(W​G​​−W​R​​)⋅G+(W​G​​−W​B​​)⋅B)​=3Y+​W​G​​​​W​G​​−W​R​​​​⋅(R−Y)+​W​G​​​​W​G​​−W​B​​​​⋅(B−Y)​=3Y+​W​G​​​​W​G​​−W​R​​​​⋅​V​max​​​​1−W​R​​​​⋅V+​W​G​​​​W​G​​−W​B​​​​⋅​U​max​​​​1−W​B​​​​⋅U​=(Y+​V​max​​​​1−W​R​​​​⋅V)+(Y+​W​G​​​​W​R​​​​⋅​V​max​​​​1−W​R​​​​⋅V+​W​G​​​​W​B​​​​⋅​U​max​​​​1−W​B​​​​⋅U)+(Y+​U​max​​​​1−W​B​​​​⋅U)​​ 线性的变化关系对 YUV 相当重要，这意味着上式可直接以转换矩阵 MRGB2YUVM_{RGB2YUV}M​RGB2YUV​​ 表示 ，有： CRGB=MRGB2YUV−1⋅CYUV=MRGB2YUV−1⋅MRGB2YUV⋅CRGB=E⋅CRGB C_{RGB} = {M_{RGB2YUV}}^{-1} \\cdot C_{YUV} = {M_{RGB2YUV}}^{-1} \\cdot M_{RGB2YUV} \\cdot C_{RGB} = E \\cdot C_{RGB} C​RGB​​=M​RGB2YUV​​​−1​​⋅C​YUV​​=M​RGB2YUV​​​−1​​⋅M​RGB2YUV​​⋅C​RGB​​=E⋅C​RGB​​ 这一点保证了不论何种设备，设备间经过 YUV 色彩格式传递的 RGB 数据，在转换前后都有一致的值 ，维护了数据的准确性。 现在，理论基础得到了佐证。在此条件下，如果已经测得关键参数值，怎样计算转换矩阵 MRGB2YUVM_{RGB2YUV}M​RGB2YUV​​ 呢？ 以 BT.601 的狭隘区间（Narrow Range） 为例。规格中取 D65 作为白点和质心 WWW ，测得 (WR ,WG ,WB)(W_R \\ , W_G \\ , W_B )(W​R​​ ,W​G​​ ,W​B​​) 为 (0.299, 0.587, 0.114)(0.299, \\ 0.587, \\ 0.114)(0.299, 0.587, 0.114) 。经过值域范围平移后，带入狭义配色函数计算，有： (Y−16)⋅255=(+0.299⋅R+0.587⋅G+0.114⋅B)⋅(235−16)(U−128)⋅255=(−0.299⋅R−0.587⋅G+0.886⋅B)⋅(235−16)(V−128)⋅255=(+0.701⋅R−0.587⋅G−0.114⋅B)⋅(235−16) {\\displaystyle \\begin{aligned} (Y-16) \\cdot 255 &= (+0.299 \\cdot R + 0.587 \\cdot G + 0.114 \\cdot B) \\cdot (235 - 16) \\\\ (U-128) \\cdot 255 &= (-0.299 \\cdot R - 0.587 \\cdot G + 0.886 \\cdot B) \\cdot (235 - 16) \\\\ (V-128) \\cdot 255 &= (+0.701 \\cdot R - 0.587 \\cdot G - 0.114 \\cdot B) \\cdot (235 - 16) \\end{aligned} } ​(Y−16)⋅255​(U−128)⋅255​(V−128)⋅255​​​=(+0.299⋅R+0.587⋅G+0.114⋅B)⋅(235−16)​=(−0.299⋅R−0.587⋅G+0.886⋅B)⋅(235−16)​=(+0.701⋅R−0.587⋅G−0.114⋅B)⋅(235−16)​​ 换算一下就能得到 MRGB2YUVM_{RGB2YUV}M​RGB2YUV​​ 的表达式： [YUV]BT.601Narrow=[0.2570.5040.098−0.148−0.2910.4390.439−0.368−0.071]⋅([RGB]−[16128128]) {\\begin{bmatrix} Y \\\\ U \\\\ V \\end{bmatrix}}_{BT.601}^{Narrow}= {\\begin{bmatrix} 0.257 & 0.504 & 0.098 \\\\ -0.148 & -0.291 & 0.439 \\\\ 0.439 & -0.368 & -0.071 \\end{bmatrix}} \\cdot \\left( {\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix}} - {\\begin{bmatrix} 16 \\\\ 128 \\\\ 128 \\end{bmatrix}} \\right) ​⎣​⎡​​​Y​U​V​​​⎦​⎤​​​BT.601​Narrow​​=​⎣​⎡​​​0.257​−0.148​0.439​​​0.504​−0.291​−0.368​​​0.098​0.439​−0.071​​​⎦​⎤​​⋅​⎝​⎛​​​⎣​⎡​​​R​G​B​​​⎦​⎤​​−​⎣​⎡​​​16​128​128​​​⎦​⎤​​​⎠​⎞​​ 可见，转换矩阵 MRGB2YUVM_{RGB2YUV}M​RGB2YUV​​ 的计算结果，只依赖于规格条件所指定的 (WR ,WG ,WB)(W_R \\ , W_G \\ , W_B )(W​R​​ ,W​G​​ ,W​B​​) 测定值和 YUV 的取值范围。 其他规格下的计算方式也是一样，并无差异。这里列出 常用的主流规格带入公式后的结果 ，方便工程参考： 图 2.6.3-5 YUV 常用规格转换矩阵表 关于 YUV 色彩格式的格式空间部分，到这里就说明完毕。接下来我们来看组成 YUV 色彩格式的数据存储部分。 YUV 的数据存储 目前主流的 YUV 色彩格式的 存储格式族（Data Format Family） 主要有三种，分别是 YUV420、YUV422、YUV444 。 YUV420 族 下的存储格式，以 4个Y通道分量共用一组UV分量构成（YYYY U V）； YUV422 族 下的存储格式，以 2个Y通道分量共用一组UV分量构成（YY U V）； YUV444 族 下的存储格式，三通道分量一一对应（Y U V）； 而每一种 YUV 存储格式族，根据 Y通道、U通道、V通道的数据排布，又可以分为：平面（Planar）、半平面（Semi-Planar）、夹层（Interleaved）、打包（Packed） 四种存储的 数据分组类型。 平面（Planar） 类型，Y、U、V 数据独立存放； 半平面（Semi-Planar） 类型，Y通道数据独立存放，UV通道数据交替打包存放； 夹层（Interleaved） 类型，三通道数据以两个Y与一组UV为数据组，封包排列存放； 打包（Packed） 类型，三通道数据以一组YUV为数据组，封包排列存放； 因此，整个 YUV 的存储格式从属关系如下图所示： 图 2.6.3-5 YUV 存储格式（Data Format）谱系图 这些 YUV 存储格式最大的特点在于数据组成上。我们用相同颜色表示位于同一组的 YUV 数据。 假设存在一张包含 36 个像素点的 6x6 的图片（为了避免颜色重复，YUV444 用 12个像素点的 6x2 图片）。 以 Y、U、V 分别代表对应通道的有效数据，所有存储格式数据排布如下： 图 2.6.3-6 YUV 存储格式（Data Format）对比说明 显然，从数据的压缩程度上来说，YUV420 族明显具有较高的压缩比。但由于YUV 格式并不是完全无损的，与之相对的问题就是高压缩比导致的图片细节损失。不过图片的细部信息大都存在于灰度图上，而这部分信息主要由 Y 通道保存，因此人眼难以察觉丢失的颜色细节。相比较高压缩比带来的优势，这部分损失可以忽略不计。所以，在音视频数据传输及图像存储中，工程上常常采用 YUV420 族下的色彩格式进行保存。 至此，有关音视频工程中的图片色彩处理部分，基本讲解完毕。下一章我们将利用目前已掌握的音视频知识，来做针对一段音频和一张图片基本分析的工程实践。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_2/Language/cn/References_2.html":{"url":"Chapter_2/Language/cn/References_2.html","title":"【参考文献】","keywords":"","body":"二、【参考文献】 [1] Isaac Newton, Hypothesis explaining the properties of light, Letter from Newton to Henry Oldenburg, dated 14 December 1675. [2] Moses Harris, The Natural System of Colours and Ignaz Schiffermüller, Versuch eines Farbensystems (Vienna, 1772), plate I - project Gutenberg Ignaz Schiffermüller, Versuch eines Farbensystems (Vienna, 1772), plate I. [3] Young, T. (1802). \"Bakerian Lecture: On the Theory of Light and Colours\". Phil. Trans. R. Soc. Lond. 92: 12–48. doi:10.1098/rstl.1803.0004. [4] Glynn, Ian (2010). Elegance in Science. Oxford: Oxford University Press. pp. 147–150. ISBN 978-0-19-957862-7. [5] Stanley Finger (2001). Origins of Neuroscience: A History of Explorations into Brain Function. p. 100. ISBN 9780195146943. [6] Svaetichin,G. (1956). Spectral response curves from single cones, Actaphysiol. scand. 39, Suppl. 134, 17–46. [7] Schubring, Gert, ed. (1996). Hermann Günther Graßmann (1809–1877): Visionary Mathematician, Scientist and Neohumanist Scholar. Boston Studies in the Philosophy of Science. Vol. 187. Springer. doi:10.1007/978-94-015-8753-2. ISBN 978-94-015-8753-2. ISSN 0068-0346. [8] K-H Schlote, Hermann Günther Grassmann and the theory of hypercomplex number systems, in Hermann Günther Grassmann (1809-1877) : visionary mathematician, scientist and neohumanist scholar (Dordrecht, 1996), 165-173. [9] G Schubring (ed.), Hermann Günther Grassmann (1809-1877) : visionary mathematician, scientist and neohumanist scholar (Dordrecht, 1996). [10] Kirschmann, A., 1896. Color-Saturation and its Quantitative Relations. American Journal of Psychology, 7, 386-404. [11] Schlatter, T., Levinson, D: Visual Usability. Principles and Practices for Designing Digital Applications, 171-211, Morgan Kaufmann, Boston 2013 [12] Smith, Thomas; Guild, John (1931–32). \"The C.I.E. colorimetric standards and their use\". Transactions of the Optical Society. 33 (3): 73–134. [13] CIE (1932). Commission internationale de l'Eclairage proceedings, 1931. Cambridge: Cambridge University Press. [14] FR patent 841335, Valensi, Georges, \"Procédé de télévision en couleurs\", published 1939-05-17, issued 1939-02-06 [15] US patent 2375966, Valensi, Georges, \"System of television in colors\", published 1945-05-15 [16] Smith, Alvy Ray (August 1978). \"Color gamut transform pairs\". Computer Graphics. 12 (3): 12–19. doi:10.1145/965139.807361. [17] Joblove, George H.; Greenberg, Donald (August 1978). \"Color spaces for computer graphics\". Computer Graphics. 12 (3): 20–25. doi:10.1145/965139.807362. [18] Ware Myers (July 1979). \"Interactive Computer Graphics: Flying High-Part I\". Computer. 12 (7): 8–17. doi:10.1109/MC.1979.1658808. S2CID 15344162. [19] Computer Graphics Staff (August 1979). \"Status Report of the Graphics Standards Planning Committee\". ACM SIGGRAPH Computer Graphics. 13 (3): 1–10. doi:10.1145/988497.988498. S2CID 43687764. [20] OpenSource Project, Color-Science, Github, https://github.com/colour-science/colour#32012colour-temperature [21] David L. Fridge, \"Aberration Synthesizer*,\" J. Opt. Soc. Am. 50, 87-87 (1960) [22] Alan J. Werner, \"Luminous Transmittance, and Chromaticity of Colored Filter Glasses in CIE 1964 Uniform Color Space,\" Appl. Opt. 7, 849-855 (1968) [23] Planck, M. (1900a). \"On an Improvement of Wien's Equation for the Spectrum\", Verh. Dtsch. Phys. Ges. Berlin 2, 202 (1900) [24] Planck, M. (1900b). \"On the Theory of the Energy Distribution Law of the Normal Spectrum\", Verh. Dtsch. Phys. Ges. Berlin 2, 237 (1900) [25] Wright, William David (1928). \"A re-determination of the trichromatic coefficients of the spectral colors\". Transactions of the Optical Society. 30 (4): 141–164. doi:10.1088/1475-4878/30/4/301. [26] Guild, J. (1932). \"The colorimetric properties of the spectrum\". Philosophical Transactions of the Royal Society of London. Series A, Containing Papers of a Mathematical or Physical Character. 230 (681–693): 149–187. Bibcode:1932RSPTA.230..149G. doi:10.1098/rsta.1933.0005. JSTOR 91229. [27] Krystek, Michael P. (January 1985). \"An algorithm to calculate correlated colour temperature\". Color Research & Application. 10 (1): 38–40. doi:10.1002/col.5080100109. [28] Borbély, Ákos; Sámson,Árpád; Schanda, János (December 2001). \"The concept of correlated colour temperature revisited\". Color Research & Application. 26 (6): 450–457. doi:10.1002/col.1065. Archived from the original on 2009-02-05. [29] Simons, Ronald Harvey; Bean, Arthur Robert (2001). Lighting Engineering: Applied Calculations. Architectural Press. ISBN 0-7506-5051-6. [30] Robertson, Alan R. (November 1968). \"Computation of Correlated Color Temperature and Distribution Temperature\". JOSA. 58 (11): 1528–1535. Bibcode:1968JOSA...58.1528R. doi:10.1364/JOSA.58.001528. [31] McCamy, Calvin S. (April 1992). \"Correlated Color Temperature as an explicit function of chromaticity coordinates\". Color Research & Application. 17 (2): 142–144. doi:10.1002/col.5080170211. plus erratum doi:10.1002/col.5080180223. [32] Kelly, Kenneth L. (August 1963). \"Lines of Constant Correlated Color Temperature Based on MacAdam's (u,v) Uniform Chromaticity Transformation of the CIE Diagram\". JOSA. 53 (8): 999–1003. Bibcode:1963JOSA...53..999K. doi:10.1364/JOSA.53.000999. [33] Hernández-Andrés, Javier; Lee, RL; Romero, J (September 20, 1999). \"Calculating Correlated Color Temperatures Across the Entire Gamut of Daylight and Skylight Chromaticities\" (PDF). Applied Optics. 38 (27): 5703–5709. Bibcode:1999ApOpt..38.5703H. doi:10.1364/AO.38.005703. PMID 18324081. [34] Bongsoon Kang; Ohak Moon; Changhee Hong; Honam Lee; Bonghwan Cho; Youngsun Kim (December 2002). \"Design of Advanced Color Temperature Control System for HDTV Applications\" (PDF). Journal of the Korean Physical Society. 41 (6): 865–871. Archived from the original (PDF) on 2019-03-03. [35] Kim et al., \"Color Temperature Conversion System and Method Using the Same\", issued 2006-04-04 [36] CIE Publication 15.3, CIE 15:2004, ISBN 3-901-906-33-9 [37] Equivalent White Light Sources, and CIE Illuminants (PDF), archived from the original on 2005-05-23, retrieved 2017-12-11 [38] CIE F-series Spectral Data, CIE 15.2:1986, archived from the original on 2011-07-25, retrieved 2017-12-11 [39] Colorimetry, 4th Edition, vol. CIE 015:2018, doi:10.25039/TR.015.2018, ISBN 978-3-902842-13-8 [40] Sándor, Norbert; Schanda, János (September 1, 2006), \"Visual colour rendering based on colour difference evaluations\", Lighting Research and Technology, 38 (3): 225–239, doi:10.1191/1365782806lrt168oa, S2CID 109858508. [41] Masahura NAKAYAMA and Koichi IKEDA: Comparison of Perceived Colour Differences with Colorimetric Colour Differences in Uniform Colour Spaces and Colour Appearance Model, J. Light & Vis. Env. Vol.28, No.2, 2004. [42] ColorChecker Colorimetric Data (PDF), archived (PDF) from the original on 9 October 2012, retrieved 17 April 2013. [43] Charles Poynton (2008). \"ColorChecker (‘Macbeth’) Chart\". poynton.com [44] Azriel Rosenfeld, Picture Processing by Computer, New York: Academic Press, 1969 [45] Dyer, Stephen A.; Harms, Brian K. (13 August 1993). \"Digital Signal Processing\". In Yovits, Marshall C. (ed.). Advances in Computers. Vol. 37. Academic Press. pp. 59–118. doi:10.1016/S0065-2458(08)60403-9. ISBN 978-0120121373. ISSN 0065-2458. LCCN 59015761. OCLC 858439915. OL 10070096M. [46] ITU-R, Rec. ITU-R BT.601-7, \"BT.601 : Studio encoding parameters of digital television for standard 4:3 and wide screen 16:9 aspect ratios\", Article Number E 70000, archived from the original on 2011-03-08 [47] ITU-R, Rec. ITU-R BT.709-6, \"BT.709 : Parameter values for the HDTV standards for production and international programme exchange\", Article Number E 70000, archived from the original on 2015-06-17 [48] ITU-R, Rec. ITU-R BT.2020-2, \"BT.2020 : Parameter values for ultra-high definition television systems for production and international programme exchange\", Article Number E 70000, archived from the original on 2015-10-14 [49] 雷霄骅, \"Color format conversion: The simplest example of libswscale based on FFmpeg (YUV to RGB)\", archived (Web: https://blog.csdn.net/leixiaohua1020/article/details/42134965) from the original on 2014-12-28 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Apex_3_Introduce.html":{"url":"Chapter_3/Language/cn/Apex_3_Introduce.html","title":"三、音视频常用基础算法","keywords":"","body":"三、音视频常用基础算法 引言 音视频中最为重要的组成部分，即是音频处理和视频处理。 音频处理应用到的基础理论，来源自：数字信号处理（Digital Signal Process）、数字合成音效（Digital Audio Effects）、语音识别（Voice Recognition）等领域。视频处理应用到的基础理论，来源自：数字信号处理（Digital Signal Process）、计算机图形学（Computer Graphics）、计算机视觉（Computer Vision）等领域。 这些学科在工程中或多或少的交叉使用，甚至本身大都为交叉学科，但最为核心的始终只有两个，即数字信号处理（DSP）和计算机图形学（CG）。所以，在正式开始学习音视频工程技术之前，首先需要回顾部分基础算法的工程特征。 本章节主要对此简单梳理（非数理、非推倒），并结合伪码和 C/C++ 工程汇总说明。可以做为最小集合的背景算法知识字典，供开发过程中查阅回顾使用。 关键字：傅立叶变换、滤波算法、区域检测、光流补正、冗余控制 目录 3.1 信号分析的核心算法 - 傅立叶变换 3.1.1 一维傅立叶（1D-FT）与一维离散傅立叶变换（1D-DFT） 3.1.2 二维傅立叶（2D-FT）与二维离散傅立叶变换（2D-DFT） 3.1.3 傅立叶变化的经典 - 快速傅立叶变换（FFT） 3.1.4 傅里叶的硬件优化 - 多常数乘法矩阵逼近（Matrix-MCM Approach） 3.2 频率信息提取 - 常用滤波算法 3.2.1 高斯滤波（Gauss Filter） 3.2.2 双边滤波（Bilateral Filter） 3.2.3 拉普拉斯滤波（Laplacian Filter） 3.2.4 马尔滤波（Marr Filter） 3.2.5 索贝尔滤波（Sobel Filter） 3.2.6 各向异性扩散（Anisotropic Diffusion） 3.3 时间冗余控制 - 常用特征提取与朴素阈值处理 3.3.1 方向梯度直方图（HOG [Histogram of Oriented Gradient]） 3.3.2 朴素目标检测结果度量 - IoU & GIoU 3.3.3 朴素目标检测物体锁定 - 分步滑动窗口（Simple Sliding Window） 3.4 空域冗余控制 - 基础光流算法与色度压缩 3.4.1 传统光流法（Classic Optical Flow Methods） 3.4.2 双向光流预测（BDOF [Bi-Directional Optical Flow]） 3.4.3 光流仿射修正（PROF [Affine Prediction Refinement With Optical Flow]） 3.4.4 色度缩放亮度映射（LMCS [Luma Mapping with Chroma Scaling]） 3.5 频域冗余控制 - 基础变换编码 3.5.1 整数离散正余弦变换（DST/DCT） 3.5.2 哈达玛变换（WHT [Walsh-Hadamard Transform]） 3.5.3 低频不可分变换（LFNST [Low-Frequency Non-Separable Transform]） Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_1.html":{"url":"Chapter_3/Language/cn/Docs_3_1.html","title":"3.1 信号分析的核心算法 - 傅立叶变换","keywords":"","body":"3.1 信号分析的核心算法 - 傅立叶变换 傅立叶变换（FT [Fourier Transform]） [1] 可理解为：任意函数都存在由给定复指数函数空间（Complex Exponential Functions Space）的一组正交基（Orthogonal Bases），使得原函数可以被分解为该复指数函数空间下最大完备解的权重向量形式表示 [2] 。利用原函数与分量函数内积为该方向解分量且正交基内任意两个方向的方向函数内积为 0 的特点，来用解的人为限定有限维度子集逼近函数本身的数学方法 [3] 。这里，描述构成原函数的分量函数集与其所占权重分量（即求得的正交基），共同构成了该函数的傅里叶基（Fourier Basis）[4] [5]。 如果记原函数为 FFF，复指数函数空间为 Fω=[Fω1,Fω2, ... ,Fωn]{\\mathcal {F}}_{\\omega} = [{\\mathcal {F}}_{\\omega_1},{\\mathcal {F}}_{\\omega_2},\\ ...\\ ,{\\mathcal {F}}_{\\omega_{n}}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​, ... ,F​ω​n​​​​]，傅里叶基为 F=[f^1,f^2, ... ,f^n]{\\mathcal {F}} = [\\hat{f}_1,\\hat{f}_2,\\ ...\\ ,\\hat{f}_n]F=[​f​^​​​1​​,​f​^​​​2​​, ... ,​f​^​​​n​​]，且 nmax=Nn_{max} = Nn​max​​=N，则这一关系从空间投影变换角度来看 [6]，可以表示为： N⋅F=FωT⋅F=[Fω1Fω2⋮Fωn]⋅[f^1,f^2, ... ,f^n] {\\displaystyle \\begin{aligned} N \\cdot F = {\\mathcal{F}_{\\omega}}^T \\cdot {\\mathcal {F}} = { \\begin{bmatrix} \\mathcal{F}_{\\omega_1} \\\\ \\mathcal{F}_{\\omega_2} \\\\ \\vdots \\\\ \\mathcal{F}_{\\omega_n} \\end{bmatrix} } \\cdot [\\hat{f}_1,\\hat{f}_2,\\ ...\\ ,\\hat{f}_n] \\end{aligned} } ​N⋅F=F​ω​​​T​​⋅F=​⎣​⎢​⎢​⎡​​​F​ω​1​​​​​F​ω​2​​​​​⋮​F​ω​n​​​​​​​⎦​⎥​⎥​⎤​​⋅[​f​^​​​1​​,​f​^​​​2​​, ... ,​f​^​​​n​​]​​ 傅里叶变换被作为基础原理之一运用在数字信号（广义）的处理过程并处于核心地位。而在数字信号处理（DSP）中，我们把所有类型信号都抽象成，由一系列离散化数据构成的函数模型表示。这些函数并不一定都是周期性、单一维度的。这时我们需要一种手段，使得能够用统一的方式描述所有不同表征的函数，从而一致性的交付系统（不一定是电脑）处理。傅里叶变换正是这种化繁为简的理论工具（Theoretical Tools） ，通过它我们能够将任意信号函数转换为傅里叶级数展开，进而转化为复数平面上一系列构成谐波关系的周期性基础三角函数和表示。傅里叶变化作为对信号进行分解描述的方法论，并不局限于单维声音信号，针对二维图片信号或更高维的数据也能够拓展延伸（即可拓展性）。而这也是我们进行感知数据数字化的理论依据。 因此，理解上式如何被运用是进行学习的关键。那么这在工程上主要体现在哪儿呢？我们需要从最简单的傅里叶变换，即一维傅里叶变换开始了解。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_1_1.html":{"url":"Chapter_3/Language/cn/Docs_3_1_1.html","title":"3.1.1 一维傅立叶（1D-FT）与一维离散傅立叶变换（1D-DFT）","keywords":"","body":"3.1.1 一维傅立叶（1D-FT）与一维离散傅立叶变换（1D-DFT） 信号学中，将沿平面分布的信号称为一维信号（1D Signal），例如音频信号。 一维傅里叶变换，能够将一组满足狄利克雷条件（Dirichlet Theorem）的一维信号分解到周期性复指数波（Complex Exponential Wave）构成的二维向量空间。 从傅里叶级数（FS）到傅里叶变换（FT） 狄利克雷条件 最初被用作傅里叶级数（FS [Fourier Series]）在三角函数域上进行分解的充分不必要条件 [2] [7]。在狄利克雷条件描述中，如果选定分析的周期信号 同时满足： 【单周期内，连续或存在有限个第一类间断点】； 【单周期内，存在有限数目的极大值与极小值】； 【单周期内，绝对可积】； 则，此周期信号就一定存在傅里叶三角级数的分解表示。 如果记周期信号函数 s(t)s(t)s(t) 的波长（周期）为 TTT ，角频率（角速度）为 2πT\\tfrac{2\\pi}{T}​T​​2π​​ 。则以信号函数波长 TTT 做可变 n∈[0, N]n \\in [0, \\ N]n∈[0, N] 等分（即步长 Step=1NStep = \\tfrac{1}{N}Step=​N​​1​​ ）选取分离函数。有分离函数（周期）为 Tn\\tfrac{T}{n}​n​​T​​ ，角频率（角速度）为 ωn=2πnT{\\omega_n} = \\tfrac{2\\pi n}{T}ω​n​​=​T​​2πn​​ 。原周期信号函数 s(t)s(t)s(t) 就可以被分解为： s(t)=1N∑n=0Nan⋅cos(2πnTt)      +     1N∑n=0Nbn⋅sin(2πnTt)an=∫−T2+T2s(t)⋅cos(ωnt) dt     bn=∫−T2+T2s(t)⋅sin(ωnt) dt {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N} \\sum_{n =0}^{N} a_n \\cdot cos(\\tfrac{2\\pi n}{T}t)\\ \\ \\ \\ \\ \\ +\\ \\ \\ \\ \\ \\frac{1}{N} \\sum_{n =0}^{N} b_n \\cdot sin(\\tfrac{2\\pi n}{T}t) \\\\ a_n &= \\int_{-\\tfrac{T}{2}}^{+\\tfrac{T}{2}} s(t) \\cdot cos(\\omega_n t) \\ dt \\ \\ \\ \\ \\ b_n = \\int_{-\\tfrac{T}{2}}^{+\\tfrac{T}{2}} s(t) \\cdot sin(\\omega_n t) \\ dt \\\\ \\end{aligned} } ​s(t)​a​n​​​​​​=​N​​1​​​n=0​∑​N​​a​n​​⋅cos(​T​​2πn​​t)      +     ​N​​1​​​n=0​∑​N​​b​n​​⋅sin(​T​​2πn​​t)​=∫​−​2​​T​​​+​2​​T​​​​s(t)⋅cos(ω​n​​t) dt     b​n​​=∫​−​2​​T​​​+​2​​T​​​​s(t)⋅sin(ω​n​​t) dt​​ 如果我们对函数周期进行平移，将区间从 (−T2, +T2)(-\\tfrac{T}{2},\\ +\\tfrac{T}{2})(−​2​​T​​, +​2​​T​​) 偏移 +T2+\\tfrac{T}{2}+​2​​T​​ ，即变换到 (0, T)(0,\\ T)(0, T) ，使原周期信号函数 s(t)s(t)s(t) 偏移为奇函数（即 s(−t)=−s(t)s(-t) = - s(t)s(−t)=−s(t) ），而奇函数式可证明是不需要余弦函数项的。此时，就可以进一步化简 s(t)s(t)s(t) 为存粹正弦函数表示： s(t)=1N∑n=0Nbn⋅sin(2πnλt)=1N∑n=0Nbn⋅sin(ωnt)bn=∫0Ts(t)⋅sin(ωnt) dt {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N} \\sum_{n =0}^{N} b_n \\cdot sin(\\tfrac{2\\pi n}{\\lambda}t) = \\frac{1}{N} \\sum_{n =0}^{N} b_n \\cdot sin(\\omega_n t) \\\\ b_n &= \\int_{0}^{T} s(t) \\cdot sin(\\omega_n t) \\ dt \\\\ \\end{aligned} } ​s(t)​b​n​​​​​​=​N​​1​​​n=0​∑​N​​b​n​​⋅sin(​λ​​2πn​​t)=​N​​1​​​n=0​∑​N​​b​n​​⋅sin(ω​n​​t)​=∫​0​T​​s(t)⋅sin(ω​n​​t) dt​​ 简化表示 ωn{\\omega_n}ω​n​​ 为 ω{\\omega}ω ，当我们将傅里叶级数从三角函数域，扩展到复变函数域时，基底函数由正余弦函数变为了以 λ=2πω=Tn{\\displaystyle \\begin{aligned} \\lambda = \\tfrac{2 \\pi}{\\omega} = \\tfrac{T}{n}\\\\ \\end{aligned} }​λ=​ω​​2π​​=​n​​T​​​​​ 为周期（波长）的复指数函数 Sω(t)=eiωt{\\displaystyle \\begin{aligned} {\\mathcal {S}}_{\\omega}(t) = e^{i\\omega t}\\\\ \\end{aligned} }​S​ω​​(t)=e​iωt​​​​​ 。信号函数 s(t)s(t)s(t) 的分解函数就可以表示为： s(t)=1N∑n=0Ns^(2πnT)⋅ei2πnTt=1N∑ω=0ωNs^(ω)⋅eiωt=1N∑n=0Ns^(ω)⋅Sω(t)s^(ω)=∫0Ts(t)⋅e−iωt dt {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N} \\sum_{n = 0}^{N} \\hat{s}(\\tfrac{2\\pi n}{T}) \\cdot e^{i \\tfrac{2\\pi n}{T}t} = \\frac{1}{N} \\sum_{\\omega = 0}^{\\omega_N} \\hat{s}(\\omega) \\cdot e^{i \\omega t} \\\\ &= \\frac{1}{N}\\sum_{n = 0}^{N} \\hat{s}(\\omega) \\cdot {\\mathcal {S}}_{\\omega}(t) \\\\ \\hat{s}(\\omega) &= \\int_{0}^{T} s(t) \\cdot e^{-i \\omega t} \\ dt \\\\ \\end{aligned} } ​s(t)​​​s​^​​(ω)​​​​=​N​​1​​​n=0​∑​N​​​s​^​​(​T​​2πn​​)⋅e​i​T​​2πn​​t​​=​N​​1​​​ω=0​∑​ω​N​​​​​s​^​​(ω)⋅e​iωt​​​=​N​​1​​​n=0​∑​N​​​s​^​​(ω)⋅S​ω​​(t)​=∫​0​T​​s(t)⋅e​−iωt​​ dt​​ 根据 欧拉公式（Euler's Formula） 可知 eix=cos(x)+i⋅sin(x){\\displaystyle \\begin{aligned} e^{ix} = cos(x) + i \\cdot sin(x) \\end{aligned} }​e​ix​​=cos(x)+i⋅sin(x)​​ ， 带入上式有： s(t)=1N∑n=0Na^ω⋅cos(ωt)+i⋅b^ω⋅sin(ωt)a^ω=s^(−ω)+s^(ω)b^ω=1i⋅(s^(−ω)−s^(ω)) {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N}\\sum_{n = 0}^{N} \\hat{a}_{\\omega} \\cdot cos(\\omega t) + i \\cdot \\hat{b}_{\\omega} \\cdot sin(\\omega t)\\\\ \\hat{a}_{\\omega} &= \\hat{s}(-\\omega) + \\hat{s}(\\omega) \\quad \\quad \\hat{b}_{\\omega} = \\tfrac{1}{i} \\cdot (\\hat{s}(-\\omega)-\\hat{s}(\\omega)) \\end{aligned} } ​s(t)​​a​^​​​ω​​​​​=​N​​1​​​n=0​∑​N​​​a​^​​​ω​​⋅cos(ωt)+i⋅​b​^​​​ω​​⋅sin(ωt)​=​s​^​​(−ω)+​s​^​​(ω)​b​^​​​ω​​=​i​​1​​⋅(​s​^​​(−ω)−​s​^​​(ω))​​ 转换到欧氏空间下的三角函数表示 Sω(t){\\mathcal {S}}_{\\omega}(t)S​ω​​(t) ，记构成原信号函数 s(t)s(t)s(t) 的复指数函数 Sω(t){\\mathcal {S}}_{\\omega}(t)S​ω​​(t) 的初相为 ∠ϕω\\angle\\phi_{\\omega}∠ϕ​ω​​ ，振幅为 AωA_{\\omega}A​ω​​ ，则： Sω(t):∠ϕω=arctan(a^ωb^ω)Aω=(a^ω)2+(b^ω)2 {\\displaystyle \\begin{aligned} {\\mathcal {S}}_{\\omega}(t) : \\quad \\angle\\phi_{\\omega} = \\arctan(\\tfrac{\\hat{a}_{\\omega}}{\\hat{b}_{\\omega}}) \\quad A_{\\omega} = \\sqrt{ (\\hat{a}_{\\omega}) ^2 + (\\hat{b}_{\\omega}) ^2 } \\\\ \\end{aligned} } ​S​ω​​(t):∠ϕ​ω​​=arctan(​​b​^​​​ω​​​​​a​^​​​ω​​​​)A​ω​​=√​(​a​^​​​ω​​)​2​​+(​b​^​​​ω​​)​2​​​​​​​​ 同三角函数域的情况，复变函数域下的傅里叶级数仍然可以进一步精简。我们仍然需要对原函数 s(t)s(t)s(t) 平移 +λ2+\\tfrac{\\lambda}{2}+​2​​λ​​ 并将周期变换到 (0, λ)(0,\\ \\lambda)(0, λ) ，使 s(t)s(t)s(t) 表现为奇函数。由于原信号函数 s(t)s(t)s(t) 必为实函数的特性，会使得 aωa_{\\omega}a​ω​​ 与 bωb_{\\omega}b​ω​​ 互为共轭复数。因此在奇函数条件下， aωa_{\\omega}a​ω​​ 与 bωb_{\\omega}b​ω​​ 表现为符号相反的纯虚数，此时： a^ω=1⋅[s^(−ω)+s^(ω)]=0     b^ω=1i⋅[s^(−ω)−s^(ω)]=2i⋅s^(−ω)s(t)=1N∑ω=0ωN    0⋅cos(ωt)     +    i⋅(2i⋅s^(−ω))⋅sin(ωt)=                1N∑n=0Ns^(−ω)⋅sin(ωt) {\\displaystyle \\begin{aligned} \\hat{a}_{\\omega} &= 1 \\cdot [\\hat{s}(-\\omega) + \\hat{s}(\\omega)] = 0 \\ \\ \\ \\ \\ \\hat{b}_{\\omega} = \\tfrac{1}{i} \\cdot [\\hat{s}(-\\omega)-\\hat{s}(\\omega)] = \\tfrac{2}{i} \\cdot \\hat{s}(-\\omega) \\\\ s(t) &= \\frac{1}{N} \\sum_{\\omega =0}^{\\omega_N} \\ \\ \\ \\ 0 \\cdot cos(\\omega t) \\ \\ \\ \\ \\ + \\ \\ \\ \\ i \\cdot (\\tfrac{2}{i} \\cdot \\hat{s}(-\\omega)) \\cdot sin(\\omega t) \\\\ &= \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\frac{1}{N}\\sum_{n = 0}^{N} \\hat{s}(-\\omega) \\cdot sin(\\omega t) \\\\ \\end{aligned} } ​​a​^​​​ω​​​s(t)​​​​​=1⋅[​s​^​​(−ω)+​s​^​​(ω)]=0     ​b​^​​​ω​​=​i​​1​​⋅[​s​^​​(−ω)−​s​^​​(ω)]=​i​​2​​⋅​s​^​​(−ω)​=​N​​1​​​ω=0​∑​ω​N​​​​    0⋅cos(ωt)     +    i⋅(​i​​2​​⋅​s​^​​(−ω))⋅sin(ωt)​=                ​N​​1​​​n=0​∑​N​​​s​^​​(−ω)⋅sin(ωt)​​ 如果我们将 s^(−ω)\\hat{s}(-\\omega)​s​^​​(−ω) 的负号划入公式，并将离散级数扩展到原信号函数 s(t)s(t)s(t) 的连续实数空间上以积分形式表示。则 s(t)s(t)s(t) 与 s^(−ω)\\hat{s}(-\\omega)​s​^​​(−ω) 的关系就展现为： s(t)=1N∫0Ns^(ω)⋅sin(ωt) dns^(ω)=∫0Ts(t)⋅sin(−ωt) dt {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N}\\int_{0}^{N} \\hat{s}(\\omega) \\cdot sin(\\omega t) \\ d{n} \\\\ \\hat{s}(\\omega) &= \\int_{0}^{T} s(t) \\cdot sin(-\\omega t) \\ dt \\\\ \\end{aligned} } ​s(t)​​s​^​​(ω)​​​​=​N​​1​​∫​0​N​​​s​^​​(ω)⋅sin(ωt) dn​=∫​0​T​​s(t)⋅sin(−ωt) dt​​ 这就是傅里叶变换的奇函数表达式，也被称为 正弦傅里叶变换（SFT [Sine Fourier Transform]）。 同理，如果我们取偶函数，有 aωa_{\\omega}a​ω​​ 与 bωb_{\\omega}b​ω​​ 表现为符号相同的纯实数。即： a^ω=1⋅[s^(−ω)+s^(ω)]=2⋅s^(ω)     b^ω=1i⋅[s^(−ω)−s^(ω)]=0s(t)=1N∑ω=0ωN    2⋅s^(ω)⋅cos(ωt)     +    i⋅0⋅sin(ωt)=                1N∑n=0Ns^(ω)⋅cos(ωt) {\\displaystyle \\begin{aligned} \\hat{a}_{\\omega} &= 1 \\cdot [\\hat{s}(-\\omega) + \\hat{s}(\\omega)] = 2 \\cdot \\hat{s}(\\omega) \\ \\ \\ \\ \\ \\hat{b}_{\\omega} = \\tfrac{1}{i} \\cdot [\\hat{s}(-\\omega)-\\hat{s}(\\omega)] = 0 \\\\ s(t) &= \\frac{1}{N} \\sum_{\\omega =0}^{\\omega_N} \\ \\ \\ \\ {2 \\cdot \\hat{s}(\\omega)} \\cdot cos(\\omega t) \\ \\ \\ \\ \\ + \\ \\ \\ \\ i \\cdot 0 \\cdot sin(\\omega t) \\\\ &= \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\frac{1}{N}\\sum_{n = 0}^{N} \\hat{s}(\\omega) \\cdot cos(\\omega t) \\\\ \\end{aligned} } ​​a​^​​​ω​​​s(t)​​​​​=1⋅[​s​^​​(−ω)+​s​^​​(ω)]=2⋅​s​^​​(ω)     ​b​^​​​ω​​=​i​​1​​⋅[​s​^​​(−ω)−​s​^​​(ω)]=0​=​N​​1​​​ω=0​∑​ω​N​​​​    2⋅​s​^​​(ω)⋅cos(ωt)     +    i⋅0⋅sin(ωt)​=                ​N​​1​​​n=0​∑​N​​​s​^​​(ω)⋅cos(ωt)​​ 采用相同处理，有余 弦傅里叶变换（CFT [Cosine Fourier Transform]） 结果如下： s(t)=1N∫0Ns^(ω)⋅cos(ωt) dns^(ω)=∫−T2+T2s(t)⋅cos(−ωt) dt {\\displaystyle \\begin{aligned} s(t) &= \\frac{1}{N} \\int_{0}^{N} \\hat{s}(\\omega) \\cdot cos(\\omega t) \\ d{n} \\\\ \\hat{s}(\\omega) &= \\int_{-\\tfrac{T}{2}}^{+\\tfrac{T}{2}} s(t) \\cdot cos(-\\omega t) \\ dt \\\\ \\end{aligned} } ​s(t)​​s​^​​(ω)​​​​=​N​​1​​∫​0​N​​​s​^​​(ω)⋅cos(ωt) dn​=∫​−​2​​T​​​+​2​​T​​​​s(t)⋅cos(−ωt) dt​​ 然而工程中的信号并不存在有限周期且并不都能判定奇偶性，这是否意味着我们无法对其进行分解和化简？ 答案是否定的。首先来看，针对周期性需要进行的操作。 解构一维信号 - 时频分离（Time-Frequency Separation） 如果我们换个角度就会发现，不存在有限周期只不过是因为周期太长，以至函数周期等于信号完整时长或着趋近无穷而导致的。所以我们分解原函数到对应的复指数函数和，所选择基底复指数函数也趋近于无穷，并使其对应频率从 000 到 ∞\\infty∞ 而周期从极大到极小即可。不过在计算上就需要利用傅立叶变化的空间特征了。 结合上文，记被分解的原信号函数为 f(t)f(t)f(t) 。根据傅立叶基的正交特性，如果存在 F(t){\\mathcal {F}}(t)F(t) 为当前 f(t)f(t)f(t) 的解函数空间，则必然有 f(t)⋅Fω−1(t)f(t) \\cdot {\\mathcal {F}}_{\\omega}^{-1}(t)f(t)⋅F​ω​−1​​(t) 内积在时间 ttt 范围为 (0, ∞)(0,\\ \\infty)(0, ∞) 有固定值 f^(ω)\\hat{f}(\\omega)​f​^​​(ω) ，使得： f^(ω)=∫0∞f(t)⋅Fω−1(t) dt=∫0∞f(t)⋅e−iωt dt {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) &= \\int_{0}^{\\infty} f(t) \\cdot {\\mathcal {F}}_{\\omega}^{-1}(t) \\ dt = \\int_{0}^{\\infty} f(t) \\cdot e^{-i \\omega t}\\ dt \\\\ \\end{aligned} } ​​f​^​​(ω)​​​​=∫​0​∞​​f(t)⋅F​ω​−1​​(t) dt=∫​0​∞​​f(t)⋅e​−iωt​​ dt​​ 以函数空间角度排除 f(t)f(t)f(t) 周期干扰。而复指数波的波函数，顾名思义就是复指数函数，有： f^(ω)=∫−∞+∞aω⋅cos(ωt)+i⋅bω⋅sin(ωt) dt {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) &= \\int_{-\\infty}^{+\\infty} a_{\\omega} \\cdot cos(\\omega t) + i \\cdot b_{\\omega} \\cdot sin(\\omega t) \\ dt\\\\ \\end{aligned} } ​​f​^​​(ω)​​​​=∫​−∞​+∞​​a​ω​​⋅cos(ωt)+i⋅b​ω​​⋅sin(ωt) dt​​ 使 bωb_{\\omega}b​ω​​ 可取复数域，就可以转换为： f^(ω)=∫−∞+∞aω⋅cos(ωt)+bω⋅sin(ωt) dt {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) &= \\int_{-\\infty}^{+\\infty} a_{\\omega} \\cdot cos(\\omega t) + b_{\\omega} \\cdot sin(\\omega t) \\ dt\\\\ \\end{aligned} } ​​f​^​​(ω)​​​​=∫​−∞​+∞​​a​ω​​⋅cos(ωt)+b​ω​​⋅sin(ωt) dt​​ 由于实际信号并不能严格确定奇偶性，不过对于小于四维的情况下，大多数条件都能保证其本身为实函数（即函数只有实数域取值），因而构成原信号的分离基底函数是存在不同强度和初项的。我们沿用前文中对初相和振幅的定义，记 Fω(t){\\mathcal {F}}_{\\omega}(t)F​ω​​(t) 初相为 ∠ϕω\\angle\\phi_{\\omega}∠ϕ​ω​​ ，振幅为 AωA_{\\omega}A​ω​​ ，则有： Fω(t):∠ϕω=arctan(a^ωb^ω)    Aω=(a^ω)2+(b^ω)2 {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega}(t) : \\quad \\angle\\phi_{\\omega} = \\arctan(\\tfrac{\\hat{a}_{\\omega}}{\\hat{b}_{\\omega}}) \\ \\ \\ \\ A_{\\omega} = \\sqrt{ (\\hat{a}_{\\omega}) ^2 + (\\hat{b}_{\\omega}) ^2 } \\\\ \\end{aligned} } ​F​ω​​(t):∠ϕ​ω​​=arctan(​​b​^​​​ω​​​​​a​^​​​ω​​​​)    A​ω​​=√​(​a​^​​​ω​​)​2​​+(​b​^​​​ω​​)​2​​​​​​​​ 根据 帕西瓦尔定理（Parseval’s Theorem） 转复数空间，我们会发现 AωA_{\\omega}A​ω​​ 就是 f^(ω)\\hat{f}(\\omega)​f​^​​(ω) 取 222 范数后的结果，而初项其实就是 f^(ω)\\hat{f}(\\omega)​f​^​​(ω) 在 t=0t = 0t=0 时，自身相位在复数空间上与实轴的夹角。即： Fω(t):∠ϕω=∠∣f^(t)∣ =arctan(a^ωb^ω)Aω=  ∥f^(t)∥2=(a^ω)2+(b^ω)2 {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega}(t) &: \\\\ \\angle\\phi_{\\omega} &= \\angle{\\vert \\hat{f}(t) \\vert} \\ = \\arctan(\\tfrac{\\hat{a}_{\\omega}}{\\hat{b}_{\\omega}}) \\\\ A_{\\omega} &=\\ \\ \\Vert \\hat{f}(t) \\Vert _2 =\\sqrt{ (\\hat{a}_{\\omega}) ^2 + (\\hat{b}_{\\omega}) ^2 } \\\\ \\end{aligned} } ​F​ω​​(t)​∠ϕ​ω​​​A​ω​​​​​​:​=∠∣​f​^​​(t)∣ =arctan(​​b​^​​​ω​​​​​a​^​​​ω​​​​)​=  ∥​f​^​​(t)∥​2​​=√​(​a​^​​​ω​​)​2​​+(​b​^​​​ω​​)​2​​​​​​​ 进而有： Fω(t)=Aω⋅sin(ωt−∠ϕω)=Aω⋅cos(ωt+∠ϕω)=∥f^(t)∥2⋅sin(ωt−∠∣f^(t)∣)=∥f^(t)∥2⋅cos(ωt+∠∣f^(t)∣)f^(ω)=∫0∞f(t)⋅e−iωt dt     ⇔     f(t)=1N∫−∞+∞f^(ω)⋅Fω(t) dω {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega}(t) &= A_{\\omega} \\cdot sin(\\omega t -\\angle\\phi_{\\omega}) = A_{\\omega} \\cdot cos(\\omega t +\\angle\\phi_{\\omega}) \\\\ &= {\\Vert \\hat{f}(t) \\Vert _2} \\cdot sin(\\omega t -\\angle{\\vert \\hat{f}(t) \\vert}) = {\\Vert \\hat{f}(t) \\Vert _2} \\cdot cos(\\omega t +\\angle{\\vert \\hat{f}(t) \\vert}) \\\\ \\hat{f}(\\omega) &= \\int_{0}^{\\infty} f(t) \\cdot e^{-i \\omega t}\\ dt \\ \\ \\ \\ \\ \\Leftrightarrow \\ \\ \\ \\ \\ f(t) = \\frac{1}{N} \\int_{-\\infty}^{+\\infty} \\hat{f}(\\omega) \\cdot {\\mathcal {F}}_{\\omega}(t) \\ d \\omega \\\\ \\end{aligned} } ​F​ω​​(t)​​​f​^​​(ω)​​​​=A​ω​​⋅sin(ωt−∠ϕ​ω​​)=A​ω​​⋅cos(ωt+∠ϕ​ω​​)​=∥​f​^​​(t)∥​2​​⋅sin(ωt−∠∣​f​^​​(t)∣)=∥​f​^​​(t)∥​2​​⋅cos(ωt+∠∣​f​^​​(t)∣)​=∫​0​∞​​f(t)⋅e​−iωt​​ dt     ⇔     f(t)=​N​​1​​∫​−∞​+∞​​​f​^​​(ω)⋅F​ω​​(t) dω​​ 显然，大部分信号都是有限时间下的，且基本都能满足无穷区间的狄利克雷条件，也因此可以使用傅里叶变换分解。 如果频率范围在 ω∈[ω0, ω1]\\omega \\in [\\omega_{0},\\ \\omega_{1}]ω∈[ω​0​​, ω​1​​] ，对于选定的时间点 t=tct = t_ct=t​c​​ ，有频率 ω\\omegaω 、原函数 f(t)f(t)f(t) 在 t=tct = t_ct=t​c​​ 时的取值 f(tc)f(t_c)f(t​c​​) 、基底函数族 Fω(t){\\mathcal {F}}_{\\omega}(t)F​ω​​(t) 锁定时间 t=tct = t_ct=t​c​​ 的变体 Ftc(ω){\\mathcal {F}}_{t_c}(\\omega)F​t​c​​​​(ω) ，构成该频率范围的 频域投影（FDP [Frequency Domain Projection]）； 反之，如果时间范围在 t∈[ t0,  t1]t\\in [\\ t_0,\\ \\ t_1]t∈[ t​0​​,  t​1​​] ，对于频率范围 ω∈[ω0, ω1]\\omega \\in [\\omega_{0},\\ \\omega_{1}]ω∈[ω​0​​, ω​1​​] ，有时间 ttt 、原函数 f(t)f(t)f(t) 、基底函数族 Fω(t){\\mathcal {F}}_{\\omega}(t) F​ω​​(t)，就构成了原函数在该时间范围的 时域投影（TDP [Time Domain Projection]）。 两者的区别仅在于观察角度的不同： Frequency Domain Projection:  (  ω ,  f(tc) ,  Ftc(ω)  )Time Domain Projection:  (  t  ,  f(t)  ,  Fω(t)   )ω∈[ω0, ωn]       t ∈[ t0,  tn ] {\\displaystyle \\begin{aligned} {Frequency\\ Domain\\ Projection:} &\\ \\ (\\ \\ \\omega\\ ,\\ \\ f(t_c)\\ ,\\ \\ {\\mathcal {F}}_{t_c}(\\omega) \\ \\ ) \\\\ {Time\\ Domain\\ Projection:} &\\ \\ (\\ \\ t\\ \\ ,\\ \\ f(t)\\ \\ ,\\ \\ {\\mathcal {F}}_{\\omega}(t) \\ \\ \\ ) \\\\ {\\omega \\in [\\omega_0,\\ \\omega_n]} \\ \\ \\ \\ & \\ \\ {\\ t\\ \\in [\\ t_0,\\ \\ t_n\\ ]} \\\\ \\end{aligned} } ​Frequency Domain Projection:​Time Domain Projection:​ω∈[ω​0​​, ω​n​​]    ​​​​  (  ω ,  f(t​c​​) ,  F​t​c​​​​(ω)  )​  (  t  ,  f(t)  ,  F​ω​​(t)   )​   t ∈[ t​0​​,  t​n​​ ]​​ 周期的问题解决了，现在我们能够拿到时频分离（Time-Frequency Separation）的原信号函数信息并可以依此还原信号本身。但积分对于计算机来说任务有些繁重。同时，由于计算机只能处理离散化后的数字信号，因此离散化的算法才能够被计算机有效使用。 所以还需要在此基础上，找到更为便捷的算法实现。 精简运算过程 - 一维离散傅立叶变换（1D-DFT） 如果将积分重新转换为级数形式积化和差表示，并在允许误差范围内取有限子集。那么就能够化解掉大部分运算量，从而得到一个相对理论而言的低时间复杂度算法。这种想法促成了基于计算机运算的一维离散傅立叶（1D-DFT）的诞生。 一维离散傅立叶（1D-DFT [1D-Discrete Fourier Transform]）本质上包含了两部分离散化作业，即对时域的离散化（TDD [Time Domain Discrete]）和对频域的离散化（FDD [Frequency Domain Discrete]）。 时域离散化（TDD） 方面，一维离散傅立叶采用了离散时间傅立叶变化（DTFT [Discrete Time Fourier Transform]）中，对时域信号间隔采样的操作。即将： f^(ω)=∫0∞f(t)⋅e−iωt dt {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) &= \\int_{0}^{\\infty} f(t) \\cdot e^{-i \\omega t}\\ dt \\\\ \\end{aligned} } ​​f​^​​(ω)​​​​=∫​0​∞​​f(t)⋅e​−iωt​​ dt​​ 以时间采样（切片）数量为 n1{n_1}n​1​​ ，转为级数形式： f^(ω)=∑t=t0tn1f(t)⋅e−iωt {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) &= \\sum_{t = t_0}^{t_{n_1}} f(t) \\cdot e^{-i \\omega t} \\\\ \\end{aligned} } ​​f​^​​(ω)​​​​=​t=t​0​​​∑​t​n​1​​​​​​f(t)⋅e​−iωt​​​​ 打破时间上的连续性。需要注意的是，此时频域仍然是连续的。 频域离散化（FDD） 方面，离散傅立叶做的操作就更为直观了。如果在频率采样时就以离散化的方式采样数据，那得到的频域信息天然就是离散的。同样，从某个时刻 t=tct = t_ct=t​c​​ 离散化的频域信息上还原当前实际频率，则也是一个线性求和的过程。因此有： f(t)=1N∫−∞+∞f^(ω)⋅Fω(t) dω {\\displaystyle \\begin{aligned} f(t) = \\frac{1}{N} \\int_{-\\infty}^{+\\infty} \\hat{f}(\\omega) \\cdot {\\mathcal {F}}_{\\omega}(t) \\ d \\omega \\\\ \\end{aligned} } ​f(t)=​N​​1​​∫​−∞​+∞​​​f​^​​(ω)⋅F​ω​​(t) dω​​​ 以频率采样（切片）数量为 n2{n_2}n​2​​ ，转为级数形式： f(t)=1n2∑ω=ω0ωn2f^(ω)⋅Fω(t) {\\displaystyle \\begin{aligned} f(t) = \\frac{1}{n_2} \\sum_{\\omega = \\omega_0}^{\\omega_{n_2}} \\hat{f}(\\omega) \\cdot {\\mathcal {F}}_{\\omega}(t) \\\\ \\end{aligned} } ​f(t)=​n​2​​​​1​​​ω=ω​0​​​∑​ω​n​2​​​​​​​f​^​​(ω)⋅F​ω​​(t)​​​ 而随着有限采样，基底函数族 Fω(t){\\mathcal {F}}_{\\omega}(t) F​ω​​(t)$ 构成的解函数空间也是有限维的，即： Fω=[Fω1,Fω2, ... ,Fωn2] {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega} = [{\\mathcal {F}}_{\\omega_1},{\\mathcal {F}}_{\\omega_2},\\ ...\\ ,{\\mathcal {F}}_{\\omega_{n_2}}] \\\\ \\end{aligned} } ​F​ω​​=[F​ω​1​​​​,F​ω​2​​​​, ... ,F​ω​n​2​​​​​​]​​​ 至此，由时域离散化（TDD）与频域离散化（FDD）共同构成离散傅立叶（DFT）的完整表达如下所示： Fω=[Fω1,Fω2, ... ,Fωn2]f^(ω)=∑t=t0tn1f(t)⋅e−iωt     ⇔     f(t)=1n2∑ω=ω0ωn2f^(ω)⋅Fω(t) {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega} = [{\\mathcal {F}}_{\\omega_1},&{\\mathcal {F}}_{\\omega_2},\\ ...\\ ,{\\mathcal {F}}_{\\omega_{n_2}}] \\\\ \\hat{f}(\\omega) = \\sum_{t = t_0}^{t_{n_1}} f(t) \\cdot e^{-i \\omega t} \\ \\ \\ \\ \\ &\\Leftrightarrow \\ \\ \\ \\ \\ f(t) = \\frac{1}{n_2} \\sum_{\\omega = \\omega_0}^{\\omega_{n_2}} \\hat{f}(\\omega) \\cdot {\\mathcal {F}}_{\\omega}(t) \\\\ \\end{aligned} } ​F​ω​​=[F​ω​1​​​​,​​f​^​​(ω)=​t=t​0​​​∑​t​n​1​​​​​​f(t)⋅e​−iωt​​     ​​​​F​ω​2​​​​, ... ,F​ω​n​2​​​​​​]​⇔     f(t)=​n​2​​​​1​​​ω=ω​0​​​∑​ω​n​2​​​​​​​f​^​​(ω)⋅F​ω​​(t)​​ 经过离散化后的有限采样更适合计算机有限的算力，因此才能被程序化。不过由于并没有保存连续的完整信息，经过离散傅里叶变换后再还原的数据，相对于采样自然源的原始数据终归还是会有一定损失的。但是由于变换与逆变换，并不会导致解构再还原后的数据存在差异。所以离散傅里叶变换被归类为 有损采样（Lossy Sampling）的无损算法（Lossless Algorithm） 。 一维离散傅立叶变换（1D-DFT）的 C 语言实现 既然需要做程序化，那么首先需要将离散傅里叶变换的过程抽象化。理清逻辑思路的同时，方便构造迭代器和代码的处理流水线。这里我们使用伪码表示： /** * 1D-DFT [Discrete Fourier Transform] * [How to Use] * * Fo[T] = {...}; * Fn[N] = {}; * dft_1d(&Fo, &Fn, T, N); * [theorem::definitions] * Fo meanings Original Function * Fn meanings Fourier Basis at [n] * pi meanings π * T meanings Periodic of Fo * N meanings Slice of Frequency * Wn meanings Angular Frequency of Basis Fn is Wn = ((2*pi*n)/T) * [theorem::formula] * Fo[t] = sum_{n=0}^{N-1} x Fn[t] * exp( i * ((2*pi*n)/T) * t), 0 同时，我们还需要提供离散傅里叶变换的逆变换（IDFT [Inverse Discrete Fourier Transform]）来使得电脑能够还原信息： /** * 1D-IDFT [Inverse Discrete Fourier Transform] * [How to Use] * * Fo[T] = {}; * Fn[N] = {...}; * dft_1d(&Fo, &Fn, T, N); * [theorem::definitions] * Fo meanings Original Function * Fn meanings Fourier Basis at [n] * pi meanings π * T meanings Periodic of Fo * N meanings Slice of Frequency * Wn meanings Angular Frequency of Basis Fn is Wn = ((2*pi*n)/T) * [theorem::formula] * Fo[t] = sum_{n=0}^{N-1} x Fn[t], 0 现在思路有了，只需要以代码实现即可： #include \"stdio.h\" #include \"math.h\" #define PI 3.1415926f typedef struct FBasis { double re_; double im_; double w_; } FBasis; void dft_1d(double *Fo, FBasis *Fn, size_t T, size_t N) { for (int n = 0; n 写完后简单测试一下： int main(void) { FBasis Fn[6] = {}; double Fo[6] = {1, 2, 3, 4, 5, 6}; double iFo[6] = {}; size_t T = sizeof(Fo) / sizeof(double); size_t N = sizeof(Fn) / sizeof(FBasis); printf(\"\\n Original_data: \\n\"); for (int t = 0; t 得到结果和标准几近相同： Original data: 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 DFT_result: 21.000000 + i 0.000000 -3.000003 + i -5.196152 -3.000002 + i -1.732048 -3.000000 + i -0.000002 -2.999996 + i 1.732057 -2.999979 + i 5.196158 IDFT_result: 1.000003 2.000000 2.999999 3.999999 4.999999 6.000000 运行结束。 到这里，我们已经基本掌握了傅里叶变换原理和最基础的应用。 如果拓展傅里叶变换到相对复杂的二维情况，那么和一维时有哪些不同呢？ Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_1_2.html":{"url":"Chapter_3/Language/cn/Docs_3_1_2.html","title":"3.1.2 二维傅立叶（2D-FT）与二维离散傅立叶变换（2D-DFT）","keywords":"","body":"3.1.2 二维傅立叶（2D-FT）与二维离散傅立叶变换（2D-DFT） 信号学中，将沿空间分布的信号称为二维信号（2D Signal）。图像信号就是二维信号。 二维傅里叶变换，能够将一组二维信号分解到 周期性复平面波（Complex Plane Wave） 构成的三维向量空间。 什么是平面波呢？延空间传播的选定波，若有任意时刻的相位相同的点连接起来得到的波阵面（同相位面）为互相平行的平面，就可以被称为 平面波（Plane Wave）。如果平面波同时满足简谐振动（即以正余弦规律振动）的特征，则可称为 平面简谐波（Plane Harmonic Waves） 。复平面波则指的是在复数空间下的平面波。 从一维到二维傅里叶变换（2D-FT） 如果说一维信号是由一组数据延单一方向排布组成的数字序列，那么二维信号就是由一组数据延横向和纵向两个方向排布构成的数字平面。在一维信号处理时，我们将复指数函数分解为一系列一维简谐波的组合。同样的处理方式，我们也可以类比应用在二维信号场景，将构成二维信号的相关复平面波分解为在复数空间下的一系列复平面简谐波的聚合，进而把二维信号以相关强度参数，转化为平面简谐波的叠加表示。 一维信号和二维信号仅仅是维度上的差异。因此，结合向量空间，我们引入波的方向矢量，并取其大小等于当前波的角频率来表示波本身，称为波矢 k⃗{\\vec{k}}​k​⃗​​ 。将波矢为 k⃗{\\vec{k}}​k​⃗​​ 的平面简谐波，称为 k⃗{\\vec{k}}​k​⃗​​ 平面波。 对于周期为 TTT 的一维信号，因为时间只能沿着时间轴正向流动，所以此时的 k⃗{\\vec{k}}​k​⃗​​ 不存在方向。其基础波函数的波矢 k⃗{\\vec{k}}​k​⃗​​ 只有大小，即 ω=∣k⃗∣\\omega = \\vert {\\vec{k}} \\vertω=∣​k​⃗​​∣ 。所以在一维傅里叶变换中，我们只考虑了时间与频率的关系，即一维的时频关系。 对于周期为 TTT 的二维信号，以可变 nnn 等分选取作为基础的复平面波，记波函数为 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) ，则波长（周期）λ=Tn\\lambda = \\tfrac{T}{n}λ=​n​​T​​ ，角频率（角速度）为 ω=∣k⃗∣=2πλ\\omega = \\vert {\\vec{k}} \\vert = \\tfrac{2\\pi}{\\lambda}ω=∣​k​⃗​​∣=​λ​​2π​​ 。将 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 的传播方向 (u,v)(u,v)(u,v) 限定 u∈[−U2, +U2]u \\in [-\\tfrac{U}{2}, \\ +\\tfrac{U}{2}]u∈[−​2​​U​​, +​2​​U​​] ，v∈[−V2, +V2]v \\in [-\\tfrac{V}{2}, \\ +\\tfrac{V}{2}]v∈[−​2​​V​​, +​2​​V​​] 的范围。则 (u,v)(u,v)(u,v) 与原点的欧式距离，实际代表的是该方向上的分割强度值 nnn ，有： U2  +  V2 = T   →   (uT)2  +  (vT)2 = n {\\displaystyle \\begin{aligned} \\sqrt{U^2 \\ \\ + \\ \\ V^2} \\ = \\ T \\ \\ \\ \\rightarrow \\ \\ \\ \\sqrt{(\\tfrac{u}{T})^2 \\ \\ + \\ \\ (\\tfrac{v}{T})^2} \\ = \\ n \\\\ \\end{aligned} } ​√​U​2​​  +  V​2​​​​​ = T   →   √​(​T​​u​​)​2​​  +  (​T​​v​​)​2​​​​​ = n​​​ 因此，代表 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 的波矢 k⃗=(2π⋅uU , 2π⋅vV)=(ξ, η){\\vec{k}} = (\\tfrac{2 \\pi \\cdot {u}}{U} \\ , \\ \\tfrac{2 \\pi \\cdot {v}}{V} ) = (\\xi, \\ \\eta)​k​⃗​​=(​U​​2π⋅u​​ , ​V​​2π⋅v​​)=(ξ, η) ，推得： ω=∣k⃗∣=(2π⋅uU)2+(2π⋅vV)2=2πλ→ξ2  +  η2 = ω2 {\\displaystyle \\begin{aligned} &\\omega = \\vert {\\vec{k}} \\vert = \\sqrt{({\\tfrac{2 \\pi \\cdot u}{U}})^2 + ({\\tfrac{2 \\pi \\cdot v}{V}})^2} = \\tfrac{2 \\pi}{\\lambda} \\\\ & \\quad \\rightarrow {\\xi}^2 \\ \\ + \\ \\ {\\eta}^2 \\ = \\ {\\omega}^2 \\\\ \\end{aligned} } ​​​​​​ω=∣​k​⃗​​∣=√​(​U​​2π⋅u​​)​2​​+(​V​​2π⋅v​​)​2​​​​​=​λ​​2π​​​→ξ​2​​  +  η​2​​ = ω​2​​​​ Fω(x,y)=eik⃗⋅(x,y)T=ei⋅2π(uUx+vVy)=Fξ(x)⋅Fη(y) {\\displaystyle {\\mathcal {F}_{\\omega}(x,y)} = e^{i \\vec{k} \\cdot (x,y)^T } = e^{i \\cdot {2 \\pi} (\\tfrac{u}{U}x+\\tfrac{v}{V}y)} = {\\mathcal {F}_{\\xi}(x)} \\cdot {\\mathcal {F}_{\\eta}(y)} } F​ω​​(x,y)=e​i​k​⃗​​⋅(x,y)​T​​​​=e​i⋅2π(​U​​u​​x+​V​​v​​y)​​=F​ξ​​(x)⋅F​η​​(y) 上式对复平面波 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 的拆解，从数理上表明了，Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 是由沿着 xxx 轴方向的一维波 Fξ(x){\\mathcal {F}}_{\\xi}(x)F​ξ​​(x) 和沿着 yyy 轴方向的一维波 Fη(y){\\mathcal {F}}_{\\eta}(y)F​η​​(y) 两部分构成。其中，ξ=2π⋅uU\\xi = \\tfrac{2\\pi \\cdot u}{U}ξ=​U​​2π⋅u​​ 为 Fξ(x){\\mathcal {F}}_{\\xi}(x)F​ξ​​(x) 的角频率，η=2π⋅vV\\eta = \\tfrac{2\\pi \\cdot v}{V}η=​V​​2π⋅v​​ 为 Fη(y){\\mathcal {F}}_{\\eta}(y)F​η​​(y) 的角频率。点位 (x,y)(x,y)(x,y) 在二维信号中代表的是实际像素数据在数字平面上的空间位置信息。所以在处理二维傅里叶变换时，我们需要考虑的是平面空间点 P⃗(x,y)\\vec{P}(x,y)​P​⃗​​(x,y) 与 k⃗{\\vec{k}}​k​⃗​​ 平面波间的关系，即二维的空频关系。 解构二维信号 - 空频分离（Spacial-Frequency Separation） 记原二维信号的函数表达为 f(x,y)f(x,y)f(x,y) ，有任意点 P⃗(x,y)\\vec{P}(x,y)​P​⃗​​(x,y) 可取 x∈[0, W]x \\in [0, \\ W]x∈[0, W] ， y∈[0, H]y \\in [0, \\ H]y∈[0, H] ，那么对于二维信号来说，周期 T=W2+H2T= \\sqrt{W^2+H^2}T=√​W​2​​+H​2​​​​​。保持 u∈[−U2, U2]u \\in [-\\tfrac{U}{2}, \\ \\tfrac{U}{2}]u∈[−​2​​U​​, ​2​​U​​] 、v∈[−V2, V2]v \\in [-\\tfrac{V}{2}, \\ \\tfrac{V}{2}]v∈[−​2​​V​​, ​2​​V​​] 范围，则 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 沿传播方向角频率 (ξ,η)(\\xi, \\eta)(ξ,η) 就有 ξ∈[−π, +π]\\xi \\in [-\\pi, \\ +\\pi]ξ∈[−π, +π] ， η∈[−π, +π]\\eta \\in [-\\pi, \\ +\\pi]η∈[−π, +π] 。则由一维拓展至二维傅里叶级数可知， f(x,y)f(x,y)f(x,y) 与波函数 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 的分量权重系数 a^ω(u,v){\\hat{a}_{\\omega}} (u, v) ​a​^​​​ω​​(u,v) 、 b^ω(u,v){\\hat{b}_{\\omega}} (u, v) ​b​^​​​ω​​(u,v) 存在： f(x,y)=1U⋅V(∑u=0∞∑v=0∞a^ω⋅cos(k⃗⋅P⃗T)   +  ∑u=0∞∑v=0∞b^ω⋅sin(k⃗⋅P⃗T))a^ω(u,v)=∫0H∫0Wf(x,y)⋅cos(2π⋅(uUx+vVy)) dx dyb^ω(u,v)=∫0H∫0Wf(x,y)⋅sin(2π⋅(uUx+vVy)) dx dy {\\displaystyle \\begin{aligned} f(x, y) &= \\frac{1}{U\\cdot V} (\\sum_{u =0}^{\\infty} \\sum_{v =0}^{\\infty} {\\hat{a}_{\\omega}} \\cdot cos(\\vec{k} \\cdot \\vec{P}^T)\\ \\ \\ + \\ \\ \\sum_{u =0}^{\\infty} \\sum_{v =0}^{\\infty} {\\hat{b}_{\\omega}} \\cdot sin(\\vec{k} \\cdot \\vec{P}^T)) \\\\ {\\hat{a}_{\\omega}} (u, v) &= \\int_{0}^{H} \\int_{0}^{W} f(x,y) \\cdot cos({2 \\pi} \\cdot (\\tfrac{u}{U}x+\\tfrac{v}{V}y)) \\ dx \\ dy \\\\ {\\hat{b}_{\\omega}} (u, v) &= \\int_{0}^{H} \\int_{0}^{W} f(x,y) \\cdot sin({2 \\pi} \\cdot (\\tfrac{u}{U}x+\\tfrac{v}{V}y)) \\ dx \\ dy \\\\ \\end{aligned} } ​f(x,y)​​a​^​​​ω​​(u,v)​​b​^​​​ω​​(u,v)​​​​=​U⋅V​​1​​(​u=0​∑​∞​​​v=0​∑​∞​​​a​^​​​ω​​⋅cos(​k​⃗​​⋅​P​⃗​​​T​​)   +  ​u=0​∑​∞​​​v=0​∑​∞​​​b​^​​​ω​​⋅sin(​k​⃗​​⋅​P​⃗​​​T​​))​=∫​0​H​​∫​0​W​​f(x,y)⋅cos(2π⋅(​U​​u​​x+​V​​v​​y)) dx dy​=∫​0​H​​∫​0​W​​f(x,y)⋅sin(2π⋅(​U​​u​​x+​V​​v​​y)) dx dy​​ 取 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 初相为 ∠ϕω\\angle\\phi_{\\omega}∠ϕ​ω​​ ，振幅为 AωA_{\\omega}A​ω​​ ，则仍然有 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) 的简谐波特征表示： Fω(x,y):∠ϕω=∠∣f^(x,y)∣ =arctan(a^ωb^ω)Aω=  ∥f^(x,y)∥2=(a^ω)2+(b^ω)2 {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega}(x,y) &: \\\\ \\angle\\phi_{\\omega} &= \\angle{\\vert \\hat{f}(x,y) \\vert} \\ = \\arctan(\\tfrac{\\hat{a}_{\\omega}}{\\hat{b}_{\\omega}}) \\\\ A_{\\omega} &=\\ \\ \\Vert \\hat{f}(x,y) \\Vert _2 =\\sqrt{ (\\hat{a}_{\\omega}) ^2 + (\\hat{b}_{\\omega}) ^2 } \\\\ \\end{aligned} } ​F​ω​​(x,y)​∠ϕ​ω​​​A​ω​​​​​​:​=∠∣​f​^​​(x,y)∣ =arctan(​​b​^​​​ω​​​​​a​^​​​ω​​​​)​=  ∥​f​^​​(x,y)∥​2​​=√​(​a​^​​​ω​​)​2​​+(​b​^​​​ω​​)​2​​​​​​​ 因此，带入 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y)F​ω​​(x,y) ，有 f(x,y)f(x,y)f(x,y) 的二维傅里叶变换展开为： Fω(x,y)=Fω(P⃗)=Aω⋅sin(k⃗⋅P⃗T−∠ϕω)=Aω⋅cos(k⃗⋅P⃗T+∠ϕω)=∥f^(x,y)∥2⋅sin(ω⋅v⃗T−∠∣f^(x,y)∣)=∥f^(x,y)∥2⋅cos(ω⋅v⃗T+∠∣f^(x,y)∣)f^(u,v)=∫0H∫0Wf(x,y)⋅e−i(ux+vy) dx dy     ⇔     f(x,y)=1U⋅V∫−V2+V2∫−U2+U2f^(u,v)⋅Fω(x,y) du dv {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega}(x,y) &= {\\mathcal {F}}_{\\omega} (\\vec{P}) = A_{\\omega} \\cdot sin(\\vec{k} \\cdot \\vec{P}^T -\\angle\\phi_{\\omega}) = A_{\\omega} \\cdot cos(\\vec{k} \\cdot \\vec{P}^T +\\angle\\phi_{\\omega}) \\\\ &= {\\Vert \\hat{f}(x,y) \\Vert _2} \\cdot sin(\\omega \\cdot \\vec{v}^T -\\angle{\\vert \\hat{f}(x,y) \\vert}) = {\\Vert \\hat{f}(x,y) \\Vert _2} \\cdot cos(\\omega \\cdot \\vec{v}^T +\\angle{\\vert \\hat{f}(x,y) \\vert}) \\\\ \\hat{f}(u,v) &= \\int_{0}^{H} \\int_{0}^{W} f(x,y) \\cdot e^{-i (ux+vy)}\\ dx \\ dy \\ \\ \\ \\ \\ \\Leftrightarrow \\ \\ \\ \\ \\ f(x,y) = \\frac{1}{U\\cdot V} \\int_{-\\tfrac{V}{2}}^{+\\tfrac{V}{2}} \\int_{-\\tfrac{U}{2}}^{+\\tfrac{U}{2}} \\hat{f}(u,v) \\cdot {\\mathcal {F}}_{\\omega}(x, y) \\ du \\ dv \\\\ \\end{aligned} } ​F​ω​​(x,y)​​​f​^​​(u,v)​​​​=F​ω​​(​P​⃗​​)=A​ω​​⋅sin(​k​⃗​​⋅​P​⃗​​​T​​−∠ϕ​ω​​)=A​ω​​⋅cos(​k​⃗​​⋅​P​⃗​​​T​​+∠ϕ​ω​​)​=∥​f​^​​(x,y)∥​2​​⋅sin(ω⋅​v​⃗​​​T​​−∠∣​f​^​​(x,y)∣)=∥​f​^​​(x,y)∥​2​​⋅cos(ω⋅​v​⃗​​​T​​+∠∣​f​^​​(x,y)∣)​=∫​0​H​​∫​0​W​​f(x,y)⋅e​−i(ux+vy)​​ dx dy     ⇔     f(x,y)=​U⋅V​​1​​∫​−​2​​V​​​+​2​​V​​​​∫​−​2​​U​​​+​2​​U​​​​​f​^​​(u,v)⋅F​ω​​(x,y) du dv​​ 一般情况为了方便起见，常取 U=WU = WU=W 、 V=HV = HV=H ，化简分离参数。上式即为二维傅里叶变换的基本形式。 如果波矢范围在 k⃗∈[k0⃗, k1⃗]\\vec{k} \\in [\\vec{k_0},\\ \\vec{k_1}]​k​⃗​​∈[​k​0​​​⃗​​, ​k​1​​​⃗​​] ，对于任意数据平面的像素点 P(x,y)P(x,y)P(x,y) ，有频率 ω=∥k⃗∥2\\omega = \\Vert \\vec{k} \\Vert_2ω=∥​k​⃗​​∥​2​​ 传播方向 (u,v)(u,v)(u,v) 、基底函数族 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y) F​ω​​(x,y) 的强度系数 f^ω(u,v)\\hat{f}_{\\omega}(u,v)​f​^​​​ω​​(u,v) ，构成该波矢范围的 频域投影（FDP [Frequency Domain Projection]）； 反之，如果选定像素点 P(x,y)P(x,y)P(x,y) ，对于波矢范围在 k⃗∈[k0⃗, k1⃗]\\vec{k} \\in [\\vec{k_0},\\ \\vec{k_1}]​k​⃗​​∈[​k​0​​​⃗​​, ​k​1​​​⃗​​] ，有平面位置 P(x,y)P(x,y)P(x,y) 、原函数值 f(x,y)f(x,y)f(x,y) 、基底函数族 Fω(x,y){\\mathcal {F}}_{\\omega}(x,y) F​ω​​(x,y) ，构成原函数在该空间（二维）范围的 空域投影（SDP [Spacial Domain Projection]）。 两者的区别同一维一样，仅在于观察角度的不同： Frequency Domain Projection:  (  u  ,  v  ,  f^ω(u,v)  )Spacial Domain Projection:  (  x  ,  y  ,  f(x,y)  ,  Fω(x,y)  )k⃗∈[k0⃗, k1⃗]       P⃗(x,y) ∈[ (0, 0)  ,  (W, H) ] {\\displaystyle \\begin{aligned} {Frequency\\ Domain\\ Projection:} &\\ \\ (\\ \\ u\\ \\ ,\\ \\ v\\ \\ ,\\ \\ \\hat{f}_{\\omega}(u,v)\\ \\ ) \\\\ {Spacial\\ Domain\\ Projection:} &\\ \\ (\\ \\ x\\ \\ ,\\ \\ y\\ \\ ,\\ \\ f(x,y)\\ \\ ,\\ \\ {\\mathcal {F}}_{\\omega}(x,y) \\ \\ ) \\\\ {\\vec{k} \\in [\\vec{k_0},\\ \\vec{k_1}]} \\ \\ \\ \\ & \\ \\ {\\ \\vec{P}(x,y)\\ \\in [\\ (0,\\ 0)\\ \\ ,\\ \\ (W,\\ H)\\ ]} \\\\ \\end{aligned} } ​Frequency Domain Projection:​Spacial Domain Projection:​​k​⃗​​∈[​k​0​​​⃗​​, ​k​1​​​⃗​​]    ​​​​  (  u  ,  v  ,  ​f​^​​​ω​​(u,v)  )​  (  x  ,  y  ,  f(x,y)  ,  F​ω​​(x,y)  )​   ​P​⃗​​(x,y) ∈[ (0, 0)  ,  (W, H) ]​​ 显然，二维和一维情况的差异很明显且必然：二维傅里叶变换下所获的的分离投影结果位于三维欧式空间，而非一维时的平面（二维）。 精简运算过程 - 二维离散傅立叶变换（2D-DFT） 同一维傅里叶变换需要做时域离散化（TDD）和频域离散化（FDD）来精简运算量。二维傅里叶变换由于引入了新的维度，更需要依赖离散化处理，才能被计算机在有限算力的前提下使用。 二维离散傅里叶变换（2D-DFT）分为 空域离散化（SDD [Spacial Domain Discrete]） 和 频域离散化（FDD [Frequency Domain Discrete]） 。当然，此处的空域为二维空域（平面），是不包含 zzz 轴的。我们将两者结合称为 空频离散化（SFD [Spacial Frequency Discrete]）。 如果取任意点 P⃗(x,y)\\vec{P}(x,y)​P​⃗​​(x,y) 可取 x∈[0, 1,  ... , W]x \\in [0, \\ 1, \\ \\ ...\\ , \\ W]x∈[0, 1,  ... , W] ， y∈[0, 1,  ... , H]y \\in [0, \\ 1, \\ \\ ...\\ , \\ H]y∈[0, 1,  ... , H] ，只取整数位置。同时， u∈[−U2,  ... , +U2]u \\in [-\\tfrac{U}{2}, \\ \\ ...\\ , \\ +\\tfrac{U}{2}]u∈[−​2​​U​​,  ... , +​2​​U​​] 、 v∈[−V2,  ... , +V2]v \\in [-\\tfrac{V}{2}, \\ \\ ...\\ , \\ +\\tfrac{V}{2}]v∈[−​2​​V​​,  ... , +​2​​V​​] ，有离散 k⃗∈[k0⃗, k1⃗,  ... , kn⃗]\\vec{k} \\in [\\vec{k_0}, \\ \\vec{k_1}, \\ \\ ...\\ , \\ \\vec{k_{n}}]​k​⃗​​∈[​k​0​​​⃗​​, ​k​1​​​⃗​​,  ... , ​k​n​​​⃗​​] ， n=UV=HWn = UV = HWn=UV=HW ，则： SDD:  f^(u,v)=∑x=0W∑y=0Hf(x,y)⋅e−i(ux+vy)FDD:  f(x,y)=1U⋅V∑u=−U/2+U/2∑v=−V/2+V/2f^(u,v)⋅Fω(x,y) {\\displaystyle \\begin{aligned} SDD: \\ \\ \\hat{f}(u,v) &= \\sum_{x = 0}^{W} \\sum_{y = 0}^{H} f(x,y) \\cdot e^{-i (ux+vy)} \\\\ FDD: \\ \\ f(x,y) &= \\frac{1}{U\\cdot V} \\sum_{u=-U/2}^{+U/2} \\sum_{v= -V/2}^{+V/2} \\hat{f}(u,v) \\cdot {\\mathcal {F}}_{\\omega}(x, y) \\\\ \\end{aligned} } ​SDD:  ​f​^​​(u,v)​FDD:  f(x,y)​​​​=​x=0​∑​W​​​y=0​∑​H​​f(x,y)⋅e​−i(ux+vy)​​​=​U⋅V​​1​​​u=−U/2​∑​+U/2​​​v=−V/2​∑​+V/2​​​f​^​​(u,v)⋅F​ω​​(x,y)​​ 至此，由空域离散化（SDD）与频域离散化（FDD）共同构成二维离散傅立叶（2D-DFT）的完整表达如下所示： Fω=[Fk0⃗,Fk1⃗, ... ,Fkn⃗]f^(u,v)=∑x=0W∑y=0Hf(x,y)⋅e−i(ux+vy)     ⇔     f(x,y)=1U⋅V∑u=−U/2+U/2∑v=−V/2+V/2f^(u,v)⋅Fω(x,y) {\\displaystyle \\begin{aligned} {\\mathcal {F}}_{\\omega} = [{\\mathcal {F}}_{\\vec{k_0}},&{\\mathcal {F}}_{\\vec{k_1}},\\ ...\\ ,{\\mathcal {F}}_{\\vec{k_n}}] \\\\ \\hat{f}(u,v) = \\sum_{x = 0}^{W} \\sum_{y = 0}^{H} f(x,y) \\cdot e^{-i (ux+vy)} \\ \\ \\ \\ \\ \\Leftrightarrow & \\ \\ \\ \\ \\ f(x,y) = \\frac{1}{U\\cdot V} \\sum_{u=-U/2}^{+U/2} \\sum_{v= -V/2}^{+V/2} \\hat{f}(u,v) \\cdot {\\mathcal {F}}_{\\omega}(x, y) \\\\ \\end{aligned} } ​F​ω​​=[F​​k​0​​​⃗​​​​,​​f​^​​(u,v)=​x=0​∑​W​​​y=0​∑​H​​f(x,y)⋅e​−i(ux+vy)​​     ⇔​​​​F​​k​1​​​⃗​​​​, ... ,F​​k​n​​​⃗​​​​]​     f(x,y)=​U⋅V​​1​​​u=−U/2​∑​+U/2​​​v=−V/2​∑​+V/2​​​f​^​​(u,v)⋅F​ω​​(x,y)​​ 利用上式，既可做算法实现。 二维离散傅立叶变换（1D-DFT）的 C 语言实现 第一步还是将二维离散傅立叶变化的过程抽象化。这里依旧采用伪码表示： /** * 2D-DFT [Discrete Fourier Transform] * [How to Use] * * Fo[W][H] = {...}; * Fn[U][V] = {}; * dft_2d(&Fo, &Fn); * [logistic] * { * result[U][V] = []; // as byte 2D-array * // do SDD: * for u in range(NU-Horizontal_Slices) { * for v in range(NV-Vertical_Slices) { * An = 0; Bn = 0; * // do FDD: * for y in Range(Height) { * for x in Range(Wight) { * Wn = (2 * PI) * Vec; * An = Re += Cos(Wn · VecT) * Fo(t); * Bn = Im += Sin(Wn · VecT) * Fo(t); * }} * result[u][v] = Fn.to_complex_angular_form(An, Bn) * }} * return result; * } * @param original_ Original Function input 2D-array * (image include width & height) * @param analyzed_ Fourier Basis info in 2D */ 同时，二维情况也需要提供离散傅里叶变换的逆变换（IDFT [Inverse Discrete Fourier Transform]）来使得电脑能够还原信息： /** * 2D-IDFT [Inverse Discrete Fourier Transform] * [How to Use] * * Fo[W][H] = {}; * Fn[U][V] = {...}; * idft_2d(&Fo, &Fn); * [logistic] * { * result[W][H] = []; // as byte 2D-array * // do SDD: * for y in Range(Height) { * for x in Range(Wight) { * Re = 0; Im = 0; * // do FDD: * for u in range(NU-Horizontal_Slices) { * for v in range(NV-Vertical_Slices) { * Wn = (2 * PI) * Vec;; * An = Re * (Fn[n] · VecT); * Bn = Im * (Fn[n] · VecT); * result[t] += Fn[n].to_value(Wn, An, Bn) / (U * V); * }} * } * return result; * } * @param original_ Original Function input 2D-array * (image include width & height) * @param analyzed_ Fourier Basis analyzed info in 2D */ 接下来只需要根据思路做代码实现即可： #include \"stdio.h\" #include \"math.h\" #define PI 3.1415926f typedef struct FBasis { double re_; double im_; double w_[2]; } FBasis; typedef struct Signal2DOriginal { int GW_; int GH_; double *Fo_; } Signal2DOriginal; typedef struct Signal2DAnalyzed { int NU_; int NV_; FBasis *Fn_; } Signal2DAnalyzed; void dft_2d(Signal2DOriginal *original_, Signal2DAnalyzed *analyzed_) { for (int u = 0; u NU_; ++u) { for (int v = 0; v NV_; ++v) { double An = 0; double Bn = 0; double Un = (2 * PI / analyzed_->NU_) * u ; double Vn = (2 * PI / analyzed_->NV_) * v ; for (int y = 0; y GH_; ++y) { for (int x = 0; x GW_; ++x) { An += cos(Un * x + Vn * y) * original_->Fo_[y * original_->GW_ + x]; Bn += sin(Un * x + Vn * y) * original_->Fo_[y * original_->GW_ + x]; } } FBasis e_ = {An, Bn, {Un, Vn}}; analyzed_->Fn_[u * analyzed_->NV_ + v] = e_; } } } void idft_2d(Signal2DOriginal *original_, Signal2DAnalyzed *analyzed_) { for (int y = 0; y GH_; ++y) { for (int x = 0; x GW_; ++x) { for (int u = 0; u NU_; ++u) { for (int v = 0; v NV_; ++v) { FBasis e_ = analyzed_->Fn_[u * analyzed_->NV_ + v]; original_->Fo_[y * original_->GW_ + x] += ( e_.re_ * cos(e_.w_[0] * x + e_.w_[1] * y) + e_.im_ * sin(e_.w_[0] * x + e_.w_[1] * y) ) / (analyzed_->NU_ * analyzed_->NV_); } } } } } 写完后还是需要简单测试一下： int main(void) { double input_data_[36] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 1.0f, 3.0f, 4.0f, 5.0f, 6.0f, 1.0f, 2.0f, 4.0f, 5.0f, 6.0f, 1.0f, 2.0f, 3.0f, 5.0f, 6.0f, 1.0f, 2.0f, 3.0f, 4.0f, 6.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f }; FBasis output_data_[36] = {}; double versed_data_[36] = {}; Signal2DOriginal Fo = { 6, 6, input_data_ }; Signal2DAnalyzed Fn = { 6, 6, output_data_ }; Signal2DOriginal iFo = { 6, 6, versed_data_ }; printf(\"\\n Original_data: \\n\"); for (int y = 0; y 得到结果和标准几近相同： Original_data: 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 2.000000 3.000000 4.000000 5.000000 6.000000 1.000000 3.000000 4.000000 5.000000 6.000000 1.000000 2.000000 4.000000 5.000000 6.000000 1.000000 2.000000 3.000000 5.000000 6.000000 1.000000 2.000000 3.000000 4.000000 6.000000 1.000000 2.000000 3.000000 4.000000 5.000000 DFT_result: 126.000 + i 0.000 -0.000 + i 0.000 -0.000 + i 0.000 0.000 + i 0.000 0.000 + i 0.000 0.000 + i 0.000 -0.000 + i 0.000 -18.000 + i -31.177 0.000 + i 0.000 0.000 + i -0.000 0.000 + i -0.000 0.000 + i -0.000 -0.000 + i 0.000 0.000 + i 0.000 -18.000 + i -10.392 0.000 + i -0.000 0.000 + i -0.000 0.000 + i -0.000 0.000 + i 0.000 0.000 + i -0.000 0.000 + i -0.000 -18.000 + i 0.000 0.000 + i -0.000 -0.000 + i -0.000 0.000 + i 0.000 0.000 + i -0.000 0.000 + i -0.000 0.000 + i -0.000 -18.000 + i 10.392 -0.000 + i -0.000 0.000 + i 0.000 0.000 + i -0.000 0.000 + i -0.000 -0.000 + i -0.000 -0.000 + i -0.000 -18.000 + i 31.177 IDFT_result: 1.000007 2.000001 2.999999 3.999999 5.000001 6.000003 2.000001 2.999998 3.999998 4.999998 5.999999 1.000000 2.999999 3.999998 4.999997 5.999998 0.999998 2.000000 3.999999 4.999998 5.999998 0.999997 1.999999 3.000001 5.000001 5.999999 0.999998 1.999999 3.000000 4.000003 6.000003 1.000000 2.000000 3.000001 4.000003 5.000005 运行结束。 二维离散傅里叶变换到此结束，那么更多维度的傅里叶变换该怎么处理呢？我们只需要拓展波矢 k⃗{\\vec{k}}​k​⃗​​ 的维度即可。而多维和一维、二维情况，在离散傅里叶变换的逻辑流程上并没有不同。但是，随着波矢 k⃗{\\vec{k}}​k​⃗​​ 的参数维度扩展，我们发现现有的直接计算法实现的离散傅里叶变换，其算法时间复杂度 O{n2}O\\{ n^2\\}O{n​2​​} 已不足以支撑超过二维参数量后的敏捷计算。因此，我们迫切需要一种更快的代替算法。 这就是促成快速傅立叶蝴蝶法工程化的要素。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_1_3.html":{"url":"Chapter_3/Language/cn/Docs_3_1_3.html","title":"3.1.3 傅立叶变化的经典 - 快速傅立叶变换（FFT）","keywords":"","body":"3.1.3 快速傅立叶（FFT [Fast Fourier Transform]） 快速傅立叶是对离散傅立叶的数学逼近。其旨在通过有限点的分布拟合，快速逼近离散傅立叶变换结果。 快速傅立叶变换最早由 高斯（Carl Friedrich Gauss，1777 - 1855） 为了解决天文学中有关于智神星（Pallas）和婚神星（Juno）的位姿计算问题，而在 1805 年提出的 [8] [9] 。不过由于种种意料之外的因素，让该论文并没有被及时的发表。因此，论文在当时也没有获得太多的关注。直到计算机开始兴起，有关傅里叶变换等算法的更为低时间复杂度的要求变的迫切，才让后续研究者们又一次察觉到了这一篇文献（以及包括 19 世纪中叶和 20 世纪初的旁类研究）的贡献 [9] 。 1965 年，来自 IBM 普林斯通实验室的 詹姆士·库利（James Cooley） 和来自普林斯通大学的 约翰·图奇（John Tukey） 教授，联合发表了基于快速傅里叶变换的机器实现 [10] ，首次将该算法迁移到了计算机上。他们的研究提出了，通过采用分治法的思想来减少变换所需步数。这成功的使得，多维信号分析所用的傅立叶算法的时间复杂度算法，降至 。促进了数字信号处理（DSP）和计算机图形学的技术更新 [11] 。所以，为纪念两位的贡献，这套程序化的快速傅里叶变换（FFT [Fast Fourier Transform]）方法论 ，被称为 库利-图奇算法（Cooley-Tukey Algorithm） 。库利-图奇算法目标是一维信号，不过高维信号是可以被拆解为低维信号的向量积的，因此 并不影响其泛化 。 在库利-图奇算法提出的时候，分治法已经被广泛的用来做计算机数组求最大值（Max）和排序（Sort）的处理当中。虽然离散的数组和周期信号之间，在信息密度和特征上存在较大差异。但如果考虑到周期信号沿传播维度重复，和傅里叶变换傅里叶基的特征，会发现： 如果将一维信号离散傅里叶变换的有限基底函数族 Fω\\mathcal {F}_{\\omega}F​ω​​ 构成的傅里叶基看作最小元，那么对其在时域上进行分组重排，也是可行的。从而使信号的一组基底函数基，能够以树状结构分类，并拆解特征表示原信号函数。 这就是库利-图奇算法的关键，在后续的算法的演进过程中逐步被提炼，形成了时域抽取这一核心概念 [11] 。 时域抽取（DIT [Decimation-in-Time]） 时域抽取（DIT [Decimation-in-Time]）是从时域（TD [Time Domain]）对一维信号进行可逆解构的一种数学工具。 它的工作流包含有两个阶段： 分组离散傅立叶（Grouped DFT） 和 旋转因子转换（Rotation Factor Convert） 时域抽取 - 分组离散傅立叶（Grouped DFT） 分组离散傅立叶（Grouped DFT） 是指，在信号的单个周期 TTT 内，以等间距有限次取 个原始离散采样后。将周期内所有采样点信息以 step=TK=Nstep =\\tfrac {T}{K} = Nstep=​K​​T​​=N 的步长等分，得到 KKK 组顺序连续的子采样分组，依照组别记为样本子集 [S1,S2, ... ,SK][S_1,S_2,\\ ...\\ , S_K][S​1​​,S​2​​, ... ,S​K​​] 。每组子集都有 Sk∈[fk((k−1)⋅N), fk(k⋅N))S_k \\in [f_k((k-1) \\cdot N),\\ f_k(k \\cdot N))S​k​​∈[f​k​​((k−1)⋅N), f​k​​(k⋅N)) 的样本取样区间。 此时，记组内索引为 nnn ，有 n∈[1, N]n \\in [1,\\ N]n∈[1, N] 。按照顺序从各组中，取组内索引位置为 nnn 的元素，组成包含数据量为 Fωn\\mathcal {F}_{\\omega_n}F​ω​n​​​​ 的基底函数 Fωn\\mathcal {F}_{\\omega_n}F​ω​n​​​​ 的波峰数组。可以逐个拟合，得到一组当前一维信号的有限基底函数族 Fω=[Fω1,Fω2, ... ,FωN]\\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2},\\ ...\\ ,\\mathcal {F}_{\\omega_N}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​, ... ,F​ω​N​​​​] ，记为当前解的最小傅立叶基。根据一维离散傅立叶变换有： Fω=[Fω1,Fω2, ... ,FωN]T=NKf^(ω)=∑t=0Tf(t)⋅e−iωt     ⇔     f(t)=1K∑ω0ωNf^(ω)⋅Fω(t) {\\displaystyle \\begin{aligned} \\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1},\\mathcal {F}_{\\omega_2},& \\ ...\\ ,\\mathcal {F}_{\\omega_N}] \\quad \\quad T = NK \\\\ \\hat{f}(\\omega) = \\sum_{t = 0}^{T} f(t) \\cdot e^{-i \\omega t} \\ \\ \\ \\ \\ &\\Leftrightarrow \\ \\ \\ \\ \\ f(t) = \\frac{1}{K} \\sum_{\\omega_0}^{\\omega_N} \\hat{f}(\\omega) \\cdot \\mathcal {F}_{\\omega}(t) \\\\ \\end{aligned} } ​F​ω​​=[F​ω​1​​​​,F​ω​2​​​​,​​f​^​​(ω)=​t=0​∑​T​​f(t)⋅e​−iωt​​     ​​​​ ... ,F​ω​N​​​​]T=NK​⇔     f(t)=​K​​1​​​ω​0​​​∑​ω​N​​​​​f​^​​(ω)⋅F​ω​​(t)​​ 又因 ωn=2πnT{\\omega_n} = \\tfrac{2\\pi n}{T}ω​n​​=​T​​2πn​​ ，强度系数 f^(ω)\\hat{f}(\\omega)​f​^​​(ω) 与 f(t)f(t)f(t) 的关系，可以被转换为 f^(n)\\hat{f}(n)​f​^​​(n) 与 f(t)f(t)f(t) 的关系： f^(ω)=∑t=0Tf(t)⋅e−iωt→f^(n)=∑t=0Tf(t)⋅e−i2πnTtf(t)=1N∑ω0ωNf^(ω)⋅Fω(t)→f(t)=1N∑n=1Nf^(n)⋅Fω(t)f^(n)=∑t=0Tf(t)⋅e−i2πnTt⇔f(t)=1N∑n=1Nf^(n)⋅Fω(t) {\\displaystyle \\begin{aligned} \\hat{f}(\\omega) = \\sum_{t = 0}^{T} f(t) \\cdot e^{-i \\omega t} &\\rightarrow \\hat{f}(n) =\\sum_{t = 0}^{T} f(t) \\cdot e^{-i \\tfrac{2\\pi n}{T} t } \\\\ f(t) = \\frac{1}{N} \\sum_{\\omega_0}^{\\omega_{N}} \\hat{f}(\\omega) \\cdot \\mathcal {F}_{\\omega}(t) &\\rightarrow f(t) = \\frac{1}{N} \\sum_{n=1}^{N} \\hat{f}(n) \\cdot \\mathcal {F}_{\\omega}(t) \\\\ \\hat{f}(n) =\\sum_{t = 0}^{T} f(t) \\cdot e^{-i \\tfrac{2\\pi n}{T} t } \\quad \\quad &\\Leftrightarrow \\quad \\quad f(t) = \\frac{1}{N} \\sum_{n=1}^{N} \\hat{f}(n) \\cdot \\mathcal {F}_{\\omega}(t) \\end{aligned} } ​​f​^​​(ω)=​t=0​∑​T​​f(t)⋅e​−iωt​​​f(t)=​N​​1​​​ω​0​​​∑​ω​N​​​​​f​^​​(ω)⋅F​ω​​(t)​​f​^​​(n)=​t=0​∑​T​​f(t)⋅e​−i​T​​2πn​​t​​​​​→​f​^​​(n)=​t=0​∑​T​​f(t)⋅e​−i​T​​2πn​​t​​​→f(t)=​N​​1​​​n=1​∑​N​​​f​^​​(n)⋅F​ω​​(t)​⇔f(t)=​N​​1​​​n=1​∑​N​​​f​^​​(n)⋅F​ω​​(t)​​ 带入 KKK 分组情况（ T=NKT = NKT=NK ），上式可化为： f^(n)=∑k=1K∑(k−1)Nt=kN−1f(t)⋅e−i2πnTt⇔f(t)=1N∑n=1Nf^(n)⋅Fω(t) {\\displaystyle \\begin{aligned} \\hat{f}(n) =\\sum_{k=1}^{K}\\sum_{(k-1)N}^{t = kN-1} f(t) \\cdot e^{-i \\tfrac{2\\pi n}{T} t } \\quad \\quad &\\Leftrightarrow \\quad \\quad f(t) = \\frac{1}{N} \\sum_{n=1}^{N} \\hat{f}(n) \\cdot \\mathcal {F}_{\\omega}(t) \\end{aligned} } ​​f​^​​(n)=​k=1​∑​K​​​(k−1)N​∑​t=kN−1​​f(t)⋅e​−i​T​​2πn​​t​​​​​⇔f(t)=​N​​1​​​n=1​∑​N​​​f​^​​(n)⋅F​ω​​(t)​​ 即强度系数 f^(n)\\hat{f}(n)​f​^​​(n) 存在展开式： f^(n)=∑k=1K∑(k−1)Nt=kN−1f(t)⋅e−i2πnTt=∑t=0N−1f(t)⋅e−i2πtT⋅n+∑t=N2N−1f(t)⋅e−i2πtT⋅n+ ... +∑(K−1)Nt=KN−1f(t)⋅e−i2πtT⋅n=∑t=0N−1f(t)⋅e−i2πtT⋅n+∑t=0N−1f(t+N)⋅e−i2π(t+N)T⋅n+ ... +∑t=0N−1f(t+(K−1)N)⋅e−i2π(t+(K−1)N)T⋅n=∑k=1K∑t=0N−1f(t+(k−1)N)⋅e−i2πtTn⋅e−i2π(k−1)Kn {\\displaystyle \\begin{aligned} \\hat{f}(n) &= \\sum_{k=1}^{K}\\sum_{(k-1)N}^{t = kN-1} f(t) \\cdot e^{-i \\tfrac{2\\pi n}{T} t } \\\\ &= \\sum_{t=0}^{N-1} f(t) \\cdot e^{-i \\tfrac{2\\pi t}{T} \\cdot n } + \\sum_{t=N}^{2N-1} f(t) \\cdot e^{-i \\tfrac{2\\pi t}{T} \\cdot n } + \\ ...\\ + \\sum_{(K-1)N}^{t=KN-1} f(t) \\cdot e^{-i \\tfrac{2\\pi t}{T} \\cdot n } \\\\ &= \\sum_{t=0}^{N-1} f(t) \\cdot e^{-i \\tfrac{2\\pi t}{T} \\cdot n } + \\sum_{t=0}^{N-1} f(t+N) \\cdot e^{-i \\tfrac{2\\pi (t+N)}{T} \\cdot n } + \\ ...\\ + \\sum_{t=0}^{N-1} f(t + (K-1)N) \\cdot e^{-i \\tfrac{2\\pi (t + (K-1)N)}{T} \\cdot n } \\\\ &= \\sum_{k=1}^{K} \\sum_{t=0}^{N-1} f(t+ (k-1)N) \\cdot e^{-i \\tfrac{2\\pi t}{T} n } \\cdot e^{-i \\tfrac{2\\pi (k-1)}{K} n } \\\\ \\end{aligned} } ​​f​^​​(n)​​​​​​​=​k=1​∑​K​​​(k−1)N​∑​t=kN−1​​f(t)⋅e​−i​T​​2πn​​t​​​=​t=0​∑​N−1​​f(t)⋅e​−i​T​​2πt​​⋅n​​+​t=N​∑​2N−1​​f(t)⋅e​−i​T​​2πt​​⋅n​​+ ... +​(K−1)N​∑​t=KN−1​​f(t)⋅e​−i​T​​2πt​​⋅n​​​=​t=0​∑​N−1​​f(t)⋅e​−i​T​​2πt​​⋅n​​+​t=0​∑​N−1​​f(t+N)⋅e​−i​T​​2π(t+N)​​⋅n​​+ ... +​t=0​∑​N−1​​f(t+(K−1)N)⋅e​−i​T​​2π(t+(K−1)N)​​⋅n​​​=​k=1​∑​K​​​t=0​∑​N−1​​f(t+(k−1)N)⋅e​−i​T​​2πt​​n​​⋅e​−i​K​​2π(k−1)​​n​​​​ 要点就出现在这里，此时，由于有限基底函数族 Fω=[Fω1,Fω2, ... ,FωN]\\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2},\\ ...\\ ,\\mathcal {F}_{\\omega_N}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​, ... ,F​ω​N​​​​] 的拟合样本选取自各个分组的对应角标数据，则显然任意 Fωi\\mathcal {F}_{\\omega_i}F​ω​i​​​​ 的周期都有 Ti=2πnωi≥NT_i = \\tfrac{2\\pi n}{\\omega_i} \\geq NT​i​​=​ω​i​​​​2πn​​≥N 且必然有 TimodN=0T_i \\mod N = 0T​i​​modN=0 。因此，强度系数 f^(n)\\hat{f}(n)​f​^​​(n) 关于 kkk 的展开式能进一步精简为： f^(n)=∑k=1K(∑t=0N−1f(t+(k−1)N)⋅e−i2πtTn)⋅e−i2π(k−1)Kn=∑k=1Ke−i2π(k−1)Kn⋅[∑(k−1)NkN−1∣t f(t)⋅Fω−1(tn)] {\\displaystyle \\begin{aligned} \\hat{f}(n) &= \\sum_{k=1}^{K} (\\sum_{t=0}^{N-1} f(t+ (k-1)N) \\cdot e^{-i \\tfrac{2\\pi t}{T} n }) \\cdot e^{-i \\tfrac{2\\pi (k-1)}{K} n } \\\\ &= \\sum_{k=1}^{K} e^{-i \\tfrac{2\\pi (k-1)}{K} n } \\cdot [\\sum_{(k-1)N}^{kN-1} \\vert_t \\ f(t) \\cdot \\mathcal {F}_{\\omega}^{-1}(tn) \\quad ] \\\\ \\end{aligned} } ​​f​^​​(n)​​​​​=​k=1​∑​K​​(​t=0​∑​N−1​​f(t+(k−1)N)⋅e​−i​T​​2πt​​n​​)⋅e​−i​K​​2π(k−1)​​n​​​=​k=1​∑​K​​e​−i​K​​2π(k−1)​​n​​⋅[​(k−1)N​∑​kN−1​​∣​t​​ f(t)⋅F​ω​−1​​(tn)]​​ 记 f^k(n)=∑(k−1)NkN−1∣t f(t)⋅Fω−1(tn)\\hat{f}_k(n) =\\sum_{(k-1)N}^{kN-1} \\vert_t \\ f(t) \\cdot \\mathcal {F}_{\\omega}^{-1}(tn)​f​^​​​k​​(n)=∑​(k−1)N​kN−1​​∣​t​​ f(t)⋅F​ω​−1​​(tn) ，则 f^k(n)\\hat{f}_k(n)​f​^​​​k​​(n) 即为分组样本子集 [S1,S2, ... ,SK][S_1,S_2,\\ ...\\ , S_K][S​1​​,S​2​​, ... ,S​K​​] 在自己的分组样本区间 Sk∈[fk((k−1)⋅N), fk(k⋅N))S_k \\in [f_k((k-1) \\cdot N),\\ f_k(k \\cdot N))S​k​​∈[f​k​​((k−1)⋅N), f​k​​(k⋅N)) 内，进行离散傅里叶变换的分组强度系数结果。而 e−i2π(k−1)Kne^{-i \\tfrac{2\\pi (k-1)}{K} n }e​−i​K​​2π(k−1)​​n​​ 在样本顺序 nnn 给定时，只与所处分组的组序 kkk 有关，且本身在三角函数空间表现为 n(k−1)n(k-1)n(k−1) 的角度固定值，所以我们记其为旋转因子（Rotation Factor） Rk(n)=e−i2π(k−1)KnR_k(n) = e^{-i \\tfrac{2\\pi (k-1)}{K} n }R​k​​(n)=e​−i​K​​2π(k−1)​​n​​ 。 将 f^k(n)\\hat{f}_k(n)​f​^​​​k​​(n) 、 Rk(n)R_k(n)R​k​​(n) 带入 f^(n)\\hat{f}(n)​f​^​​(n) ，则 f^(n)\\hat{f}(n)​f​^​​(n) 最终表现为： R1(n)=1f^(n)=∑k=1KRk(n)⋅f^k(n)=R1(n)⋅f^1(n)+R2(n)⋅f^2(n)+ ... +RK(n)⋅f^K(n)f^(n)=f^1(n)+R2(n)⋅f^2(n)+ ... +RK(n)⋅f^K(n) {\\displaystyle \\begin{aligned} R_1(n) & = 1 \\\\ \\hat{f}(n) &= \\sum_{k=1}^{K} R_k(n) \\cdot \\hat{f}_k(n) = R_1(n) \\cdot \\hat{f}_1(n) + R_2(n) \\cdot \\hat{f}_2(n) + \\ ...\\ + R_K(n) \\cdot \\hat{f}_K(n) \\\\ \\hat{f}(n) &= \\hat{f}_1(n) + R_2(n) \\cdot \\hat{f}_2(n) + \\ ...\\ + R_K(n) \\cdot \\hat{f}_K(n) \\\\ \\end{aligned} } ​R​1​​(n)​​f​^​​(n)​​f​^​​(n)​​​​=1​=​k=1​∑​K​​R​k​​(n)⋅​f​^​​​k​​(n)=R​1​​(n)⋅​f​^​​​1​​(n)+R​2​​(n)⋅​f​^​​​2​​(n)+ ... +R​K​​(n)⋅​f​^​​​K​​(n)​=​f​^​​​1​​(n)+R​2​​(n)⋅​f​^​​​2​​(n)+ ... +R​K​​(n)⋅​f​^​​​K​​(n)​​ 上式就是时域抽取（DIT）有关分组离散傅立叶（Grouped DFT）的通用完整过程。单从公式来看，由于切割了样本集，我们只能通过分组离散傅立叶（Grouped DFT）直接求得原一维信号前 NNN 个信号量的傅里叶解。反而因为样本不足的问题，无法直接求得剩余的 (K−1)N(K-1)N(K−1)N 个信号量。 那么我们大费周章的这么做有什么用处呢？原因就在于旋转因子间是存在关系的。 时域抽取 - 旋转因子转换（Rotation Factor Convert） 这个问题，需要从复变函数的三角函数特性来回答。记 Rk(n)R_k(n)R​k​​(n) 变换到三角函数域，其实部为 aka_ka​k​​ ，虚部为 bkb_kb​k​​ 。则 Rk(n)R_k(n)R​k​​(n) 可以表示为： Rk(n)=e−i2π(k−1)Kn=ak⋅cos(2π(k−1)Kn)+i⋅bk⋅sin(2π(k−1)Kn) dt {\\displaystyle \\begin{aligned} R_k(n) &= e^{-i \\tfrac{2\\pi (k-1)}{K} n } \\\\ &= a_k \\cdot cos(\\tfrac{2\\pi (k-1)}{K} n) + i \\cdot b_k \\cdot sin(\\tfrac{2\\pi (k-1)}{K} n) \\ dt \\\\ \\end{aligned} } ​R​k​​(n)​​​​​=e​−i​K​​2π(k−1)​​n​​​=a​k​​⋅cos(​K​​2π(k−1)​​n)+i⋅b​k​​⋅sin(​K​​2π(k−1)​​n) dt​​ 依此，取 aka_ka​k​​ 为 yyy 轴、 bkb_kb​k​​ 为 xxx 轴。我们假设分组 K=2mK = 2^mK=2​m​​ ，信号周期 T=2π⋅MT = 2 \\pi \\cdot MT=2π⋅M 且 Tmod2π=0T \\mod 2\\pi = 0Tmod2π=0 ，有此时步长 N=π2m−1⋅MN = \\tfrac{\\pi}{2^{m-1}} \\cdot MN=​2​m−1​​​​π​​⋅M 。为便于说明，我们取 M=1M = 1M=1 ， m=1m = 1m=1 ，且 n=π6=∠30∘n = \\tfrac{\\pi}{6} = \\angle 30^\\circn=​6​​π​​=∠30​∘​​ 来进行绘制。实际上 nnn 只能取 [1, N][1, \\ N][1, N] 的整数，但那样会不便于图示，这里取固定角并不影响后续结论。则 Rk(n)R_k(n)R​k​​(n) 在 akbka_kb_ka​k​​b​k​​ 构成的平面坐标系上有如下取值范围： 图 3.1.3-1 旋转因子的三角函数系取值演示 在图像表示下 Rk(n)R_k(n)R​k​​(n) 的特性更易察觉，当分组 K=2mK = 2^mK=2​m​​ 且 m≥1m \\geq 1m≥1 取整时, 单个 2π2\\pi2π 周期内，以 N=2πKN = \\tfrac{2\\pi}{K}N=​K​​2π​​ 可以分为 2m−12^{m-1}2​m−1​​ 组。每组分组都包涵两个子样本集 [Sk ,Sk+2m−1][S_k\\ ,S_{k+2^{m-1}}][S​k​​ ,S​k+2​m−1​​​​] ，此时，这两个字样本集旋转因子原点对称，有 Rk(n)=−Rk(n+π)n∈[2π(k−1)K, 2πkK]R_k(n) = -R_k(n+\\pi) \\quad n \\in [\\tfrac{2\\pi (k-1)}{K}, \\ \\tfrac{2\\pi k}{K}]R​k​​(n)=−R​k​​(n+π)n∈[​K​​2π(k−1)​​, ​K​​2πk​​] 。而对于信号 M>1M > 1M>1 时，间隔为 2π2\\pi2π 的分组有 2M2^M2​M​​ 组，且旋转因子取值相同，即 Rk(n)=Rk+2π⋅M(n)R_k(n) = R_{k+2\\pi \\cdot M}(n)R​k​​(n)=R​k+2π⋅M​​(n) 。 如果我们取 K=2K = 2K=2 ，即 m=1m = 1m=1 ，对整体信号的 TTT 个样本分为两组，两组原点对称有： f^(n)=f^1(n)+e−iπn⋅f^2(n) =f^1(n)+R2(n)⋅f^2(n)f^(n+π)=f^1(n)+e−iπ(n+π)⋅f^2(n)=f^1(n)−R2(n)⋅f^2(n) {\\displaystyle \\begin{aligned} \\hat{f}(n) &= \\hat{f}_1(n) + e^{-i \\pi n} \\cdot \\hat{f}_2(n) \\quad \\ = \\hat{f}_1(n) + R_2(n) \\cdot \\hat{f}_2(n) \\\\ \\hat{f}(n+\\pi) &= \\hat{f}_1(n) + e^{-i \\pi (n+\\pi)} \\cdot \\hat{f}_2(n) = \\hat{f}_1(n) - R_2(n) \\cdot \\hat{f}_2(n) \\\\ \\end{aligned} } ​​f​^​​(n)​​f​^​​(n+π)​​​​=​f​^​​​1​​(n)+e​−iπn​​⋅​f​^​​​2​​(n) =​f​^​​​1​​(n)+R​2​​(n)⋅​f​^​​​2​​(n)​=​f​^​​​1​​(n)+e​−iπ(n+π)​​⋅​f​^​​​2​​(n)=​f​^​​​1​​(n)−R​2​​(n)⋅​f​^​​​2​​(n)​​ 如果我们取 K=4K = 4K=4 ，即 m=2m = 2m=2 ，对整体信号的 TTT 个样本分为四组，间隔两两原点对称，即相邻组间实虚轴反转，有： Rk(n+π2)=[(k−1)%2]⋅(−1)k−1⋅Rk(n)+[(k−1)%2+1]⋅(−i)k−1⋅Rk(n) {\\displaystyle \\begin{aligned} R_k(n+\\tfrac{\\pi}{2}) = [(k-1)\\%2] \\cdot (-1)^{k-1} \\cdot R_k(n) + [(k-1)\\%2 + 1] \\cdot(-i)^{k-1} \\cdot R_k(n) \\\\ \\end{aligned} } ​R​k​​(n+​2​​π​​)=[(k−1)%2]⋅(−1)​k−1​​⋅R​k​​(n)+[(k−1)%2+1]⋅(−i)​k−1​​⋅R​k​​(n)​​​ 则 f^(n)\\hat{f}(n)​f​^​​(n) 有 n∈[0, π2]n \\in [0, \\ \\tfrac{\\pi}{2}]n∈[0, ​2​​π​​] 范围的表达式： f^(n)=f^1(n)+ R2(n)⋅f^2(n)+ R3(n)⋅f^3(n)+ R4(n)⋅f^4(n)f^(n+π2)=f^1(n)−iR2(n)⋅f^2(n)− R3(n)⋅f^3(n)+iR4(n)⋅f^4(n)f^(n+π)=f^1(n)− R2(n)⋅f^2(n)+ R3(n)⋅f^3(n)− R4(n)⋅f^4(n)f^(n+3π2)=f^1(n)+iR2(n)⋅f^2(n)− R3(n)⋅f^3(n)−iR4(n)⋅f^4(n) {\\displaystyle \\begin{aligned} \\hat{f}(n) &= \\hat{f}_1(n) + \\ R_2(n) \\cdot \\hat{f}_2(n) + \\ R_3(n) \\cdot \\hat{f}_3(n) + \\ R_4(n) \\cdot \\hat{f}_4(n) \\\\ \\hat{f}(n+\\tfrac{\\pi}{2}) &= \\hat{f}_1(n) - i R_2(n) \\cdot \\hat{f}_2(n) - \\ R_3(n) \\cdot \\hat{f}_3(n) + i R_4(n) \\cdot \\hat{f}_4(n) \\\\ \\hat{f}(n+\\pi) &= \\hat{f}_1(n) - \\ R_2(n) \\cdot \\hat{f}_2(n) + \\ R_3(n) \\cdot \\hat{f}_3(n) - \\ R_4(n) \\cdot \\hat{f}_4(n) \\\\ \\hat{f}(n+\\tfrac{3\\pi}{2})&= \\hat{f}_1(n) + i R_2(n) \\cdot \\hat{f}_2(n) - \\ R_3(n) \\cdot \\hat{f}_3(n) - i R_4(n) \\cdot \\hat{f}_4(n) \\\\ \\end{aligned} } ​​f​^​​(n)​​f​^​​(n+​2​​π​​)​​f​^​​(n+π)​​f​^​​(n+​2​​3π​​)​​​​=​f​^​​​1​​(n)+ R​2​​(n)⋅​f​^​​​2​​(n)+ R​3​​(n)⋅​f​^​​​3​​(n)+ R​4​​(n)⋅​f​^​​​4​​(n)​=​f​^​​​1​​(n)−iR​2​​(n)⋅​f​^​​​2​​(n)− R​3​​(n)⋅​f​^​​​3​​(n)+iR​4​​(n)⋅​f​^​​​4​​(n)​=​f​^​​​1​​(n)− R​2​​(n)⋅​f​^​​​2​​(n)+ R​3​​(n)⋅​f​^​​​3​​(n)− R​4​​(n)⋅​f​^​​​4​​(n)​=​f​^​​​1​​(n)+iR​2​​(n)⋅​f​^​​​2​​(n)− R​3​​(n)⋅​f​^​​​3​​(n)−iR​4​​(n)⋅​f​^​​​4​​(n)​​ 不论上述哪一种分组方法，我们都可以将求解范围从有限子集 SkS_kS​k​​ 中 n∈[2π(k−1)K, 2πkK]n \\in [\\tfrac{2\\pi (k-1)}{K}, \\ \\tfrac{2\\pi k}{K}]n∈[​K​​2π(k−1)​​, ​K​​2πk​​] 的离散傅立叶结果，拓展到完整信号周期 TTT 。而只需要求任意一有限子集 SkS_kS​k​​ 的傅立叶基即可。 根据 K=2mK = 2^mK=2​m​​ 的不同取值，时域抽取（DIT）过程的时间复杂度，通过计算分片耗时，能够简单得到为 O(K−1Kn⋅log2mn)=O(K−1K⋅2m−1n⋅log2n)O(\\tfrac{K-1}{K}n \\cdot log_{2^m}n) = O(\\tfrac{K-1}{K \\cdot 2^{m-1} }n \\cdot log_2n)O(​K​​K−1​​n⋅log​2​m​​​​n)=O(​K⋅2​m−1​​​​K−1​​n⋅log​2​​n) 。 显然，O∣K=2=O(12n⋅log2n)O|_{K=2} =O(\\tfrac{1}{2}n \\cdot log_2n)O∣​K=2​​=O(​2​​1​​n⋅log​2​​n) 、 O∣K=4=O(38n⋅log2n)O|_{K=4} =O(\\tfrac{3}{8}n \\cdot log_2n)O∣​K=4​​=O(​8​​3​​n⋅log​2​​n) 虽然分组间耗时差异不大，但相较于直接对一维信号使用离散傅里叶变换（DFT）的 O(n2)O(n^2)O(n​2​​) 耗时来说，直接减少了一个数量级。这即是快速傅立叶的 “快”。 对于 KKK 取不同值时的时域抽取（DIT），为了做区分，根据 KKK 值的不同被分别称为 双模时域抽取（Radix-2 DIT） 和 四模时域抽取（Radix-4 DIT） 。同理，我们将 K=2K = 2K=2 时的库利-图奇算法称为 双模快速傅里叶变换（Radix-2 FFT），将 K=4K = 4K=4 时的库利-图奇算法称为 四模快速傅里叶变换（Radix-4 FFT）。两者差异如上，主要即是在划分导致推算上的不同。 至于为什么快速傅里叶变换又被称为蝴蝶法这点。则和经过时域抽取（DIT）处理后，有限基底函数族 Fω=[Fω1,Fω2, ... ,FωN]\\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2},\\ ...\\ ,\\mathcal {F}_{\\omega_N}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​, ... ,F​ω​N​​​​] 的对应强度系数 f^(ω)\\hat{f}(\\omega)​f​^​​(ω) 与分组 f^k(n)\\hat{f}_k(n)​f​^​​​k​​(n) 的换算方式有关。 处理单元最小化 - 交叉求值与“蝴蝶”的由来 以 双模快速傅里叶变换（Radix-2 FFT） 为例。在最简情况下，当样本取 T=2T = 2T=2 ，有 K=2K = 2K=2 且 N=1N = 1N=1 ，基底函数族 Fω=[Fω1,Fω2]\\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​] ，此时： ∵f^k(n)=∑(k−1)NkN−1∣t f(t)⋅Fω−1(tn)∴f^(n)=f^1(n) + (−1)n⋅R2(n)⋅f^2(n)=Fω1−1(n)⋅f(0)+ Fω2−1(n)⋅f(1)= f(0) + (−1)n⋅Fω2−1(n)⋅f(1) {\\displaystyle \\begin{aligned} \\because \\hat{f}_k(n) &=\\sum_{(k-1)N}^{kN-1} \\vert_t \\ f(t) \\cdot \\mathcal {F}_{\\omega}^{-1}(tn) \\\\ \\therefore \\hat{f}(n) &=\\quad \\quad \\hat{f}_1(n)\\quad \\ +\\ (-1)^n \\cdot R_2(n) \\cdot \\hat{f}_2(n) \\\\ &= \\mathcal {F}_{\\omega_1}^{-1}(n) \\cdot f(0) + \\quad \\ \\mathcal {F}_{\\omega_2}^{-1}(n) \\cdot f(1) \\\\ &= \\quad \\quad \\ f(0) \\ \\quad +\\ (-1)^n \\cdot \\mathcal {F}_{\\omega_2}^{-1}(n) \\cdot f(1) \\\\ \\end{aligned} } ​∵​f​^​​​k​​(n)​∴​f​^​​(n)​​​​​​=​(k−1)N​∑​kN−1​​∣​t​​ f(t)⋅F​ω​−1​​(tn)​=​f​^​​​1​​(n) + (−1)​n​​⋅R​2​​(n)⋅​f​^​​​2​​(n)​=F​ω​1​​​−1​​(n)⋅f(0)+ F​ω​2​​​−1​​(n)⋅f(1)​= f(0) + (−1)​n​​⋅F​ω​2​​​−1​​(n)⋅f(1)​​ 显然，对于足够小的样本，其库利-图奇解的旋转因子 Rk(n)R_k(n)R​k​​(n) ，就是它所对应的傅里叶基函数与转置因子的乘机，即： Rk(n)=(−1)n⋅Fω2−1(n),k∣n∈int[0,1] R_k(n) = (-1)^n \\cdot \\mathcal {F}_{\\omega_2}^{-1}(n) \\quad , k|n \\in int[0,1] R​k​​(n)=(−1)​n​​⋅F​ω​2​​​−1​​(n),k∣n∈int[0,1] 我们在傅里叶变换章节开始时提到过，傅里叶变换从空间投影变换角度，可以表示为： N⋅F=FωT⋅F=[Fω1Fω2⋮Fωn]⋅[f^1,f^2, ... ,f^n] {\\displaystyle \\begin{aligned} N \\cdot F = {\\mathcal {F}_{\\omega}}^T \\cdot \\mathcal {F} = {\\begin{bmatrix} \\mathcal {F}_{\\omega_1} \\\\ \\mathcal {F}_{\\omega_2} \\\\ \\vdots \\\\ \\mathcal {F}_{\\omega_n} \\end{bmatrix}} \\cdot [\\hat{f}_1,\\hat{f}_2,\\ ...\\ ,\\hat{f}_n] \\\\ \\end{aligned} } ​N⋅F=F​ω​​​T​​⋅F=​⎣​⎢​⎢​⎡​​​F​ω​1​​​​​F​ω​2​​​​​⋮​F​ω​n​​​​​​​⎦​⎥​⎥​⎤​​⋅[​f​^​​​1​​,​f​^​​​2​​, ... ,​f​^​​​n​​]​​​ 那么，在引入了转置因子的情况下，原信号 f(n)f(n)f(n) 与 f^(n)\\hat{f}(n)​f​^​​(n) 的关系就可以被写为： [f(0)f(1)]=[1,+Fω21,−Fω2]⋅[f^(0)f^(1)]=[1,+11,−1]⋅[Fω1,Fω2]⋅[f^(0)f^(1)] {\\displaystyle \\begin{aligned} { \\begin{bmatrix} f(0) \\\\ f(1) \\end{bmatrix} } = { \\begin{bmatrix} 1 \\quad , +\\mathcal{F}_{\\omega_2} \\\\ 1 \\quad , -\\mathcal{F}_{\\omega_2} \\end{bmatrix} } \\cdot { \\begin{bmatrix} \\hat{f}(0) \\\\ \\hat{f}(1) \\end{bmatrix} } = { \\begin{bmatrix} 1 \\quad , & +1 \\\\ 1 \\quad , & -1 \\end{bmatrix} } \\cdot [\\mathcal{F}_{\\omega_1}, \\mathcal{F}_{\\omega_2}] \\cdot { \\begin{bmatrix} \\hat{f}(0) \\\\ \\hat{f}(1) \\end{bmatrix} } \\\\ \\end{aligned} } ​[​f(0)​f(1)​​]=[​1,+F​ω​2​​​​​1,−F​ω​2​​​​​​]⋅[​​f​^​​(0)​​f​^​​(1)​​]=[​1,​1,​​​+1​−1​​]⋅[F​ω​1​​​​,F​ω​2​​​​]⋅[​​f​^​​(0)​​f​^​​(1)​​]​​​ 而这个过程如果换到拓扑图表示，就是大名鼎鼎的 “蝴蝶” 流造型了 （注意，颜色表示转子输出方向） ： 同理，当采用 四模快速傅里叶变换（Radix-4 FFT） 时，有在最简情况下样本取 T=4T = 4T=4 。有 K=4K = 4K=4 且 N=1N = 1N=1 ，基底函数族 Fω=[Fω1,Fω2,Fω3,Fω4]\\mathcal {F}_{\\omega} = [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2}, \\mathcal {F}_{\\omega_3}, \\mathcal {F}_{\\omega_4}]F​ω​​=[F​ω​1​​​​,F​ω​2​​​​,F​ω​3​​​​,F​ω​4​​​​] 。省略同质的推导过程，有原信号 f(n)f(n)f(n) 与 f^(n)\\hat{f}(n)​f​^​​(n) 的关系： [f(0)f(1)f(2)f(3)]=[1,1,1,11,−i,−1,i1,−1,1,−11,i,−1,−i]⋅[Fω1,Fω2,Fω3,Fω4]⋅[f^(0)f^(1)f^(2)f^(3)] {\\displaystyle \\begin{aligned} { \\begin{bmatrix} f(0) \\\\ f(1) \\\\ f(2) \\\\ f(3) \\end{bmatrix} } = { \\begin{bmatrix} 1 ,& &1,& &1,& &1 \\\\ 1 ,& -&i,& -&1,& &i \\\\ 1 ,& -&1,& &1,& -&1 \\\\ 1 ,& &i,& -&1,& -&i \\end{bmatrix} } \\cdot [\\mathcal {F}_{\\omega_1}, \\mathcal {F}_{\\omega_2}, \\mathcal {F}_{\\omega_3}, \\mathcal {F}_{\\omega_4}] \\cdot { \\begin{bmatrix} \\hat{f}(0) \\\\ \\hat{f}(1) \\\\ \\hat{f}(2) \\\\ \\hat{f}(3) \\end{bmatrix} } \\\\ \\end{aligned} } ​​⎣​⎢​⎢​⎡​​​f(0)​f(1)​f(2)​f(3)​​​⎦​⎥​⎥​⎤​​=​⎣​⎢​⎢​⎡​​​1,​1,​1,​1,​​​​−​−​​​​1,​i,​1,​i,​​​​−​​−​​​1,​1,​1,​1,​​​​​−​−​​​1​i​1​i​​​⎦​⎥​⎥​⎤​​⋅[F​ω​1​​​​,F​ω​2​​​​,F​ω​3​​​​,F​ω​4​​​​]⋅​⎣​⎢​⎢​⎡​​​​f​^​​(0)​​f​^​​(1)​​f​^​​(2)​​f​^​​(3)​​​⎦​⎥​⎥​⎤​​​​​ 四模的 “蝴蝶” 流造型如下 （注意，颜色表示前级数据来源） ： 可见，单元的最小化抽象是通用的方法论。 对于多样本情况，只需要层层分解组装即可完成整体的快速处理。由于时间差异并不明显，但转置矩阵复杂度差异较大，因此我们一般选择 双模（Radix-2） 简化整体处理过程。 分批处理层级树 - 单元组装与完整流水线 和简单情况不一样的是，更多的样本采样使得我们没办法通过一次计算就得到最终结果。而在之前的推导过程中我们提到，对于不同子样本集抽参求解 f^k(n)\\hat{f}_k(n)​f​^​​​k​​(n) 的过程，其本质也是一个傅里叶变换，只不过在解构过程中被我们以整体进行了代指换元。因此，随着 T=2lT = 2^lT=2​l​​ 与 K=2mK = 2^mK=2​m​​ 的变化，对信号处理的层数 LayerLayerLayer 也会产生变更有： Layer=logK(T)=lm Layer = \\log_{K}(T) = \\frac{l}{m} Layer=log​K​​(T)=​m​​l​​ 假设样本取 T=4T = 4T=4 ，有 K=2K = 2K=2 ，则 N=2N = 2N=2 ，此时所需层数为 Layer=2Layer = 2Layer=2 。根据其上我们的分析可知，存在整合后的基底函数族为： Fω=[Fω1,Fω2]=[Fω11,Fω12,Fω21,Fω22] \\mathcal{F}_{\\omega} = [\\mathcal{F}_{\\omega_1}, \\mathcal{F}_{\\omega_2}] = [\\mathcal{F}_{\\omega_{11}}, \\mathcal{F}_{\\omega_{12}}, \\mathcal{F}_{\\omega_{21}}, \\mathcal{F}_{\\omega_{22}}] F​ω​​=[F​ω​1​​​​,F​ω​2​​​​]=[F​ω​11​​​​,F​ω​12​​​​,F​ω​21​​​​,F​ω​22​​​​] 使得原信号 f(n)f(n)f(n) 与 f^(n)\\hat{f}(n)​f​^​​(n) 的关系为： ∵f^k(n)=∑(k−1)NkN−1∣t f(t)⋅Fω−1(tn)mark:Ri(n)⋅Fωij−1(n)=Rij(n)∣(T=4,K=2)∴f^1(n)= Fω11−1(n)⋅f1(0)+ (−1)n⋅Fω12−1(n)⋅f1(1)=f(0) + (−1)n⋅Fω12−1(n)⋅f(2)=DFT(f1(n))f^2(n)= Fω21−1(n)⋅f2(0)+ (−1)n⋅Fω22−1(n)⋅f2(1)=f(1) + (−1)n⋅Fω22−1(n)⋅f(3)=DFT(f2(n))∴f^(n)=[f^1(n)+ (−1)n⋅R2(n)⋅f^2(n) ]∣(T=8,K=2)= R1(n)⋅DFT(f1(n)) + (−1)n⋅R2(n)⋅DFT(f2(n))= R1(n)⋅Fω11−1(n)⋅f(0) + (−1)n⋅R1(n)⋅Fω12−1(n)⋅f(2) + (−1)n⋅R2(n)⋅f(1) + R2(n)⋅Fω22−1(n)⋅f(3)= R11(n)⋅f(0)+ (−1)n⋅R12(n)⋅f(2)+ (−1)n⋅R21(n)⋅f(1)+ R22(n)⋅f(3) {\\displaystyle \\begin{aligned} \\because \\hat{f}_k(n) &=\\sum_{(k-1)N}^{kN-1} \\vert_t \\ f(t) \\cdot \\mathcal{F}_{\\omega}^{-1}(tn) \\quad \\quad \\quad \\quad \\quad \\quad mark: R_i(n) \\cdot \\mathcal{F}_{\\omega_{ij}}^{-1}(n) = R_{ij}(n) \\vert_{(T=4,K=2)} \\\\ \\therefore \\hat{f}_1(n) &= \\ \\mathcal{F}_{\\omega_{11}}^{-1}(n) \\cdot f_1(0) \\quad +\\ (-1)^n \\cdot \\mathcal{F}_{\\omega_{12}}^{-1}(n) \\cdot f_1(1) \\\\ &= \\quad \\quad \\quad f(0) \\quad \\quad \\ +\\ (-1)^n \\cdot \\mathcal{F}_{\\omega_{12}}^{-1}(n) \\cdot f(2) =\\quad DFT(f_1(n)) \\\\ \\hat{f}_2(n) &= \\ \\mathcal{F}_{\\omega_{21}}^{-1}(n) \\cdot f_2(0) \\quad +\\ (-1)^n \\cdot \\mathcal{F}_{\\omega_{22}}^{-1}(n) \\cdot f_2(1) \\\\ &= \\quad \\quad \\quad f(1) \\quad \\quad \\ +\\ (-1)^n \\cdot \\mathcal{F}_{\\omega_{22}}^{-1}(n) \\cdot f(3) =\\quad DFT(f_2(n)) \\\\ \\therefore \\hat{f}(n) &= [\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\hat{f}_1(n) \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad + \\quad \\quad \\quad \\quad \\ (-1)^n \\cdot R_2(n) \\cdot \\hat{f}_2(n)\\quad \\quad \\quad \\quad \\ ]\\vert_{(T=8,K=2)} \\\\ &= \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\ R_1(n) \\cdot DFT(f_1(n))\\ \\quad \\quad \\quad \\quad \\quad \\quad \\quad + \\quad \\quad \\quad \\quad \\ (-1)^n \\cdot R_2(n) \\cdot DFT(f_2(n)) \\\\ &= \\ R_1(n) \\cdot \\mathcal{F}_{\\omega_{11}}^{-1}(n) \\cdot f(0) \\ + \\ (-1)^n \\cdot R_1(n) \\cdot \\mathcal{F}_{\\omega_{12}}^{-1}(n) \\cdot f(2) \\ + \\ (-1)^n \\cdot R_2(n) \\cdot f(1) \\ + \\ R_2(n) \\cdot \\mathcal{F}_{\\omega_{22}}^{-1}(n) \\cdot f(3) \\\\ &= \\quad \\quad \\ R_{11}(n) \\cdot f(0)\\quad \\quad + \\quad \\quad \\ (-1)^n \\cdot R_{12}(n)\\cdot f(2) \\quad \\quad + \\ (-1)^n \\cdot R_{21}(n) \\cdot f(1) + \\quad \\quad \\ R_{22}(n)\\cdot f(3) \\\\ \\end{aligned} } ​∵​f​^​​​k​​(n)​∴​f​^​​​1​​(n)​​​f​^​​​2​​(n)​​∴​f​^​​(n)​​​​​​​=​(k−1)N​∑​kN−1​​∣​t​​ f(t)⋅F​ω​−1​​(tn)mark:R​i​​(n)⋅F​ω​ij​​​−1​​(n)=R​ij​​(n)∣​(T=4,K=2)​​​= F​ω​11​​​−1​​(n)⋅f​1​​(0)+ (−1)​n​​⋅F​ω​12​​​−1​​(n)⋅f​1​​(1)​=f(0) + (−1)​n​​⋅F​ω​12​​​−1​​(n)⋅f(2)=DFT(f​1​​(n))​= F​ω​21​​​−1​​(n)⋅f​2​​(0)+ (−1)​n​​⋅F​ω​22​​​−1​​(n)⋅f​2​​(1)​=f(1) + (−1)​n​​⋅F​ω​22​​​−1​​(n)⋅f(3)=DFT(f​2​​(n))​=[​f​^​​​1​​(n)+ (−1)​n​​⋅R​2​​(n)⋅​f​^​​​2​​(n) ]∣​(T=8,K=2)​​​= R​1​​(n)⋅DFT(f​1​​(n)) + (−1)​n​​⋅R​2​​(n)⋅DFT(f​2​​(n))​= R​1​​(n)⋅F​ω​11​​​−1​​(n)⋅f(0) + (−1)​n​​⋅R​1​​(n)⋅F​ω​12​​​−1​​(n)⋅f(2) + (−1)​n​​⋅R​2​​(n)⋅f(1) + R​2​​(n)⋅F​ω​22​​​−1​​(n)⋅f(3)​= R​11​​(n)⋅f(0)+ (−1)​n​​⋅R​12​​(n)⋅f(2)+ (−1)​n​​⋅R​21​​(n)⋅f(1)+ R​22​​(n)⋅f(3)​​ 同理，当 T=8T = 8T=8 ，有 K=2K = 2K=2 ，则 N=4N = 4N=4 ，此时所需层数为 Layer=3Layer = 3Layer=3 。存在整合后的基底函数族： Fω=[Fω1,Fω2]=[Fω11,Fω12,Fω21,Fω22]=[Fω111,Fω112,Fω121,Fω122,Fω211,Fω212,Fω221,Fω222] {\\displaystyle \\begin{aligned} \\mathcal{F}_{\\omega} &= [\\mathcal{F}_{\\omega_1}, \\mathcal{F}_{\\omega_2}] \\\\ &= [\\mathcal{F}_{\\omega_{11}}, \\mathcal{F}_{\\omega_{12}}, \\mathcal{F}_{\\omega_{21}}, \\mathcal{F}_{\\omega_{22}}] \\\\ &= [\\mathcal{F}_{\\omega_{111}}, \\mathcal{F}_{\\omega_{112}}, \\mathcal{F}_{\\omega_{121}}, \\mathcal{F}_{\\omega_{122}}, \\mathcal{F}_{\\omega_{211}}, \\mathcal{F}_{\\omega_{212}}, \\mathcal{F}_{\\omega_{221}}, \\mathcal{F}_{\\omega_{222}}] \\\\ \\end{aligned} } ​F​ω​​​​​​​​=[F​ω​1​​​​,F​ω​2​​​​]​=[F​ω​11​​​​,F​ω​12​​​​,F​ω​21​​​​,F​ω​22​​​​]​=[F​ω​111​​​​,F​ω​112​​​​,F​ω​121​​​​,F​ω​122​​​​,F​ω​211​​​​,F​ω​212​​​​,F​ω​221​​​​,F​ω​222​​​​]​​ 使得原信号 f(n)f(n)f(n) 与 f^(n)\\hat{f}(n)​f​^​​(n) 的关系为 （省略同质化过程） ： f^(n)= R11(n)⋅f^11(n)∣0,4+ (−1)n⋅R12(n)⋅f^12(n)∣1,5+ (−1)n⋅R21(n)⋅f^21(1)∣2,6+ R22(n)⋅f^22(3)∣3,7=[R111(n)⋅f(0) + (−1)n⋅R112(n)⋅f(4)+ R221(n)⋅f(2)+ (−1)n⋅R222(n)⋅f(6)]feven+[R121(n)⋅f(1) + (−1)n⋅R122(n)⋅f(5)+ R321(n)⋅f(3)+ (−1)n⋅R322(n)⋅f(7)]fodds {\\displaystyle \\begin{aligned} \\hat{f}(n) =& \\ R_{11}(n) \\cdot \\hat{f}_{11}(n) \\vert_{0,4} \\quad \\quad + \\quad \\quad \\ (-1)^n \\cdot R_{12}(n)\\cdot \\hat{f}_{12}(n) \\vert_{1,5} \\quad \\quad + \\ (-1)^n \\cdot R_{21}(n) \\cdot \\hat{f}_{21}(1) \\vert_{2,6} + \\quad \\quad \\ R_{22}(n)\\cdot \\hat{f}_{22}(3) \\vert_{3,7} \\\\ =& [ R_{111}(n) \\cdot f(0)\\ + \\ (-1)^n \\cdot R_{112}(n) \\cdot f(4) + \\ R_{221}(n) \\cdot f(2) + \\ (-1)^n \\cdot R_{222}(n) \\cdot f(6) ]_{f_{even}} \\quad + \\\\ & [ R_{121}(n) \\cdot f(1)\\ + \\ (-1)^n \\cdot R_{122}(n) \\cdot f(5) + \\ R_{321}(n) \\cdot f(3) + \\ (-1)^n \\cdot R_{322}(n) \\cdot f(7) ]_{f_{odds}} \\\\ \\end{aligned} } ​​f​^​​(n)=​=​​​​​ R​11​​(n)⋅​f​^​​​11​​(n)∣​0,4​​+ (−1)​n​​⋅R​12​​(n)⋅​f​^​​​12​​(n)∣​1,5​​+ (−1)​n​​⋅R​21​​(n)⋅​f​^​​​21​​(1)∣​2,6​​+ R​22​​(n)⋅​f​^​​​22​​(3)∣​3,7​​​[R​111​​(n)⋅f(0) + (−1)​n​​⋅R​112​​(n)⋅f(4)+ R​221​​(n)⋅f(2)+ (−1)​n​​⋅R​222​​(n)⋅f(6)]​f​even​​​​+​[R​121​​(n)⋅f(1) + (−1)​n​​⋅R​122​​(n)⋅f(5)+ R​321​​(n)⋅f(3)+ (−1)​n​​⋅R​322​​(n)⋅f(7)]​f​odds​​​​​​ 此时的“蝴蝶”流造型，就要复杂一些了 ： 从图上可知，每层都可以被分割为 2la−12^{l_a - 1}2​l​a​​−1​​ 个蝶形单元，其中 lal_al​a​​ 为当前层级。而完整的计算，则需要历经共计 2l/m−12^{l/m} - 12​l/m​​−1 个单元才能完成。 如果我们开始就对总样本集 SSS ，按照奇偶样本分为 S1′=[f(0), f(2), f(4), f(6)]S_1^{\\prime} = [f(0),\\ f(2),\\ f(4) ,\\ f(6)]S​1​′​​=[f(0), f(2), f(4), f(6)] 和 S2′=[f(1), f(3), f(5), f(7)]S_2^{\\prime} = [f(1),\\ f(3),\\ f(5) ,\\ f(7)]S​2​′​​=[f(1), f(3), f(5), f(7)] 这两个子集。使单一分组求单一解，来方便分离的离散傅里叶变换调用。那么整个蝴蝶图就变成如下样子了 （同色线表示相同流向） ： 结果同样一致，可见奇偶分割实质上是一个以 K=2K = 2K=2 为步长的抽样再迭代计算的过程。这点也能够从 K=4K = 4K=4 时，四模对原数据取样 T=8T = 8T=8 会使 f(n)f(n)f(n) 被分为： f^(n)=[R11(n)⋅f(0) + (−1)n⋅R12(n)⋅f(4)]f1/4+[R21(n)⋅f(1) + (−1)n⋅R22(n)⋅f(5)]f2/4+[R31(n)⋅f(2) + (−1)n⋅R32(n)⋅f(6)]f3/4+[R41(n)⋅f(3) + (−1)n⋅R42(n)⋅f(7)]f4/4 {\\displaystyle \\begin{aligned} \\hat{f}(n) =& [ R_{11}(n) \\cdot f(0)\\ + \\ (-1)^n \\cdot R_{12}(n) \\cdot f(4) ]_{f_{1/4}} \\quad + \\\\ & [ R_{21}(n) \\cdot f(1)\\ + \\ (-1)^n \\cdot R_{22}(n) \\cdot f(5) ]_{f_{2/4}} \\quad + \\\\ & [ R_{31}(n) \\cdot f(2)\\ + \\ (-1)^n \\cdot R_{32}(n) \\cdot f(6) ]_{f_{3/4}} \\quad + \\\\ & [ R_{41}(n) \\cdot f(3)\\ + \\ (-1)^n \\cdot R_{42}(n) \\cdot f(7) ]_{f_{4/4}} \\\\ \\end{aligned} } ​​f​^​​(n)=​​​​​​​[R​11​​(n)⋅f(0) + (−1)​n​​⋅R​12​​(n)⋅f(4)]​f​1/4​​​​+​[R​21​​(n)⋅f(1) + (−1)​n​​⋅R​22​​(n)⋅f(5)]​f​2/4​​​​+​[R​31​​(n)⋅f(2) + (−1)​n​​⋅R​32​​(n)⋅f(6)]​f​3/4​​​​+​[R​41​​(n)⋅f(3) + (−1)​n​​⋅R​42​​(n)⋅f(7)]​f​4/4​​​​​​ 的情况，得到间接的阐明。 因此，我们可以通过封装固定 KKK 时的最小蝶形单元，采用递归的方式来计算 f(n)f(n)f(n) 与 f^(n)\\hat{f}(n)​f​^​​(n) 的相互转换。分组的产生，是由顺序输入在算法作用下经过每层的蝶形单元处理后，导致的必然结果。是一个自然而然的过程而并非强行去做的设定，切勿本末倒置。 而我们期望的是有序的输出，这也就产生了对输入进行排序的要求。 基于数据的优化 - 位反转（Bit Reversal）输入索引重排 经过前面的一系列分析，不难归纳得到：最终算法的输出顺序，是原序列经过 Layer−1Layer - 1Layer−1 层反转的结果。即每个蝶形单元，会反转当前对应字样本周期跨度的一半。 还是采用当 T=8T = 8T=8 ，有 K=2K = 2K=2 时的情形。我们将所有的处理过程排除，以原样本数据序列角标的传递过程来标记处理流，则有： 当代计算机采用的二进制计数，我们将上述样本角标 采用二进制表示 ，有： 这一现象即被称为 位反转（Bit Reversal）。我们可以利用这一特点，在工程运算过程中每个蝶形单元的数据装配处，以顺序序列对应位反转的角标来取用输入数据，从而保证迭代运算结果的顺序。 一维快速傅立叶变换（1D-FFT）的 C 语言实现 现在，万事俱备。可以进行代码实现了。先用伪码缕清算法程序化思路： /** * 1D-FFT [Fast Fourier Transform] * [How to Use] * * Fo[T] = {...}; * Fn[T] = {}; * fft_1d(&Fo, &Fn, T); * [logistic] * { * result = []; // as byte array * // do Bit-Reversal * Fo_sorted = bit_reversal(Fn, Fn, T); * // do DIT: * for (int layer_at_ = 0; layer_at_ 依然，快速傅立叶变换也需要有逆变换（IDFT [Inverse Fast Fourier Transform]），来帮我们进行数据还原： /** * 1D-IFFT [Inverse Fast Fourier Transform] * [How to Use] * * Fo[T] = {}; * Fn[T] = {...}; * fft_1d(&Fo, &Fn, T); * [logistic] * { * result = []; // as byte array * // do Bit-Reversal * Fo_sorted = bit_reversal(Fn, Fn, T) / T; dont forget divide N(num equal T) [ 到此，快速傅里叶变换的 工程优势 就体现出来了。从上面的工作流可以看出，FFT 和 IFFT 唯一的实现上的不同的地方，就在于两点： 分片计算均值 ，这个是傅里叶变换的通性； 旋转因子互逆 ，转换三角函数时的对称性； 这正是我们在之前推倒时，双模快速傅里叶变换（Radix-2 FFT）所利用的最为显著的特征。而其他部分的计算，则可以用相同的流水线进行统一。 所以，一维双模快速傅里叶变换（1D Radix-2 FFT）的工程化 ，并没有想象中的复杂： #include \"stdio.h\" #include \"math.h\" #define PI 3.1415926f typedef struct Complex { double re_; double im_; Complex operator+(const Complex &b_) const { Complex result_; result_.re_ = re_ + b_.re_; result_.im_ = im_ + b_.im_; return result_; } Complex operator-(const Complex &b_) const { Complex result_; result_.re_ = re_ - b_.re_; result_.im_ = im_ - b_.im_; return result_; } Complex operator*(const Complex &b_) const { Complex result_; result_.re_ = re_ * b_.re_ - im_ * b_.im_; result_.im_ = re_ * b_.im_ + im_ * b_.re_; return result_; } } Rotator, FBasis; void digital_convert(double *digital_, Complex *complex_, size_t size_, bool inverse = false) { if (!inverse) { for (int i = 0; i 0) { j = j > 1; } if (j > i) { Complex temp = input_[i]; result_[i] = input_[j]; result_[j] = temp; } } } void butterfly(Complex *target_, int step_, int slice_idx_, bool inverse = false) { int start_at_ = slice_idx_ * 2 * step_; for (int inner_idx_ = 0; inner_idx_ 写完后简单测试一下： int main(void) { FBasis Fn[8] = {}; double Fo[8] = {0, 1, 2, 3, 4, 5, 6, 7}; double iFo[8] = {}; size_t T = sizeof(Fo) / sizeof(double); size_t N = sizeof(Fn) / sizeof(FBasis); printf(\"\\n Original_data: \\n\"); for (int t = 0; t 得到结果和标准基本相同： Original_data: 0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 FFT_result: 28.000000 + i 0.000000 -4.000001 + i -9.656855 -4.000000 + i -4.000000 -4.000000 + i -1.656854 -4.000000 + i 0.000000 -4.000000 + i 1.656855 -4.000000 + i 4.000000 -3.999999 + i 9.656854 IFFT_result: 0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 运行结束。 至此，快速傅立叶变换的简单工程化基本完毕。二维情况，可以类比二维离散傅里叶变换的拓展思想，来进行改造。 另外，快速傅立叶变换 并不只有 时域抽取（DIT）、 双模（Radix-2）、四模（Radix-4）等这些处理手段。通用的其他类型，包括并不限于 频域抽取（FIT）、八模（Radix-8）、多模混合（Mixed-Radix）等 。但亦可触类旁通。 这些方法共同构成了当今快速傅立叶变换的高性能函数库，甚至 配合硬件的特殊门电路设计，还能够进一步压缩过程中非理论因素的处理耗时 。而在工作中，除特殊情况外，通常会在项目允许范畴内引入一些由研究机构校准的快速傅立叶变换函数库，这里按量级列举 三个经典库 ，以供参考使用之便： 小：Ooura's Mathematical Software Packages. by Takuya Ooura. 中：FXT: a library of algorithms. by Jörg Arndt. 大：FFTW: Fastest Fourier Transform in the West. by Matteo Frigo and Steven G. Johnson. at MIT. Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_1_4.html":{"url":"Chapter_3/Language/cn/Docs_3_1_4.html","title":"3.1.4 傅里叶的硬件优化 - 多常数乘法矩阵逼近（Matrix-MCM Approach）","keywords":"","body":"3.1.4 傅里叶的硬件优化 - 多常数乘法矩阵逼近（Matrix-MCM Approach） 2011 年， [12]。 【申请 IEEE 授权中】 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_2.html":{"url":"Chapter_3/Language/cn/Docs_3_2.html","title":"3.2 频率信息提取 - 常用滤波算法","keywords":"","body":"3.2 频率信息提取 - 常用滤波算法 上一节中，我们就数字信号处理（DSP）的核心算法，傅里叶变换，进行了详细的说明。而在对二维傅里叶变换进行讲解的时候。细心的读者可能已经发现了 图像在空频分布上的一些特点。在分布的频率（波矢 k⃗{\\vec{k}}​k​⃗​​ 的频率 ∣k⃗∣=ω\\vert {\\vec{k}} \\vert = \\omega∣​k​⃗​​∣=ω ）的占比（强度系数 f^ω(u,v)\\hat{f}_{\\omega}(u,v)​f​^​​​ω​​(u,v) ）中，低频信号的占比高，而高频信号的占比低。 这一现象产生的原因在于： 当一张图片处于色彩变化大且明显的区域时， k⃗{\\vec{k}}​k​⃗​​ 平面波在 uvuvuv 平面上的相邻点，单次数值变化的跨度就越大，直观体现就是波矢 k⃗{\\vec{k}}​k​⃗​​ 更长，即频率 ω\\omegaω 更高，波长 λ\\lambdaλ 更短。相反，当图片处于色彩变化相对平稳的区域时，相邻两个像素点的色彩差异就越小，单次数值变化的跨度就越小，对应的波矢 k⃗{\\vec{k}}​k​⃗​​ 更短，即频率 ω\\omegaω 更低，波长 λ\\lambdaλ 更长。这种变化明显处，往往是图片中的噪点或物体的轮廓位置。显然，色彩差异较小的相邻像素区域，才是占有图片空间较多的部分。 传统的图像处理，即是对图像频率的处理。其本质上是根据不同的目标，提炼出图像中被认为有用的信息，这一步被称为滤波（Filter）。滤波是对信号已有频率的过滤，通过增强（阻塞/增强阻塞）一部分频段，来达到筛选的效果。 因此，由于信息量的关系，滤波算法更多的使用场景是被运用在已得图像的结果上。相较于一维信号，二维信号明显对算法敏捷程度有更低的容忍度。而直接以傅里叶空频分离（SFS）进行科学处理，依旧会有些臃肿。毕竟非分析场景一般不需要特别高的精度，通常只在意一定范围内的频率特征，且并不会对细部有过多的要求。那么有没有满足条件下，针对目标频段的，更实用的变体呢？ 考虑到简易的滤波手段多为均值与阈限共同作用。从算法层面，优化均值与阈限的求与取，就是切入点。如果可以将算法抽象为足够小的有限参数单元，我们就能够以 卷积核（Convolution Nucleus / Convolution Kernel / Sliding Window / Filter） 数学工具，封装整个运算过程。从而充分的利用现代 GPU 设备进行并行计算，批量处理并降低耗时。 欲期望达成此要求，被抽象的有限参数单元必然不能太复杂。 为了便于演示说明，本节采用 OpenGL 的 GLSL 程序片脚本语言 ，并使用 WebGL 环境预览 ，来进行算法的演示工作。其他驱动，如 DirectX 的 HLSL 或 Metal 的 MLSL，皆可参照 GLSL 逻辑达到相同效果。 在线演示 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_2_1.html":{"url":"Chapter_3/Language/cn/Docs_3_2_1.html","title":"3.2.1 高斯滤波（Gauss Filter）","keywords":"","body":"3.2.1 高斯滤波（Gauss Filter） 高斯滤波是我们最常用的一种滤波器。 想要理解高斯滤波的作用，首先需要回顾一下 高斯分布（Gaussian Distribution） ，即 正态分布（Normal Distribution） 的数学特征。高斯分布公式 ： f(x,μ)=12π⋅δe−(x−μ)22⋅δ2 f(x,\\mu) = \\frac{1}{\\sqrt{2\\pi} \\cdot \\delta} e ^{-\\tfrac{(x-\\mu)^2}{2 \\cdot \\delta^2}} f(x,μ)=​√​2π​​​⋅δ​​1​​e​−​2⋅δ​2​​​​(x−μ)​2​​​​​​ 其在 xxx 为一维时的平面的对应分布如下： 图 3.2.1-1 一维正态分布示意图 从图像可见，高斯分布的 μ\\muμ 决定了分部的中心，而 δ\\deltaδ 决定了形变的剧烈程度。而线下曲线面积，则代表了对应区间段内的取值发生概率。从离散角度则指 x∈int[xc−n2,xc+n2]x \\in int[x_c-\\tfrac{n}2, x_c+\\tfrac{n}2]x∈int[x​c​​−​2​​n​​,x​c​​+​2​​n​​] 范围内，有 x=xcx = x_cx=x​c​​ 的取值概率为 f(xc)f(x_c)f(x​c​​) 。 记原信号为 S(x)S(x)S(x) 。以 ∣target∣1\\vert target \\vert_1∣target∣​1​​ 表示归一化操作，则 ∣∑xc−n/2xc+n/2(f(x)⋅S(x))∣1\\vert {\\sum}_{x_c -n/2}^{x_c+n/2}(f(x) \\cdot S(x)) \\vert_1∣∑​x​c​​−n/2​x​c​​+n/2​​(f(x)⋅S(x))∣​1​​ 代表在当前给定 (δ,μ)(\\delta, \\mu)(δ,μ) 的高斯分布 f(x,μ)f(x, \\mu)f(x,μ) 下，考虑 x=xcx = x_cx=x​c​​ 时左右相邻含 xcx_cx​c​​ 在内共 nnn 个节点取值情况的 S(xc)S(x_c)S(x​c​​) 的概率均值。我们记 xcx_cx​c​​ 为中心点，数据采样数为 TTT ，有： xc∈int[n2,T−n2],n∈intoddsFn(xc)=∣∑xc−n/2xc+n/2(f(x,xc)⋅S(x))∣1 {\\displaystyle \\begin{aligned} x_c \\in &int [\\tfrac{n}{2}, T-\\tfrac{n}{2}], \\quad n \\in int_{odds} \\\\ \\\\ F_n(x_c) &= \\vert {\\sum}_{x_c -n/2}^{x_c+n/2}(f(x, x_c) \\cdot S(x)) \\vert_1 \\\\ \\end{aligned} } ​x​c​​∈​​F​n​​(x​c​​)​​​​int[​2​​n​​,T−​2​​n​​],n∈int​odds​​​=∣∑​x​c​​−n/2​x​c​​+n/2​​(f(x,x​c​​)⋅S(x))∣​1​​​​ 上式中，Fn(xc)F_n(x_c)F​n​​(x​c​​) 即为一维情况下的 nnn 步滑动窗口，也可以称为 n×1n \\times 1n×1 卷积核。通过沿信号的数据顺序，滑动 Fn(xc)F_n(x_c)F​n​​(x​c​​) 求取原值 xcx_cx​c​​ 替换值的操作。我们可以在一定程度上利用分布的概率关系，以调整 δ\\deltaδ 取值的方式来影响核内相邻数据的波动性，进而影响整体波动性达到滤波目的。 取 δ\\deltaδ 越小，波动性越强越激烈，图片越尖锐；反之 δ\\deltaδ 越大，波动性越弱越平缓，图片越模糊。 一维信号早期常用这种手段来一定程度的进行降噪（现今已被优秀和复杂的多的算法替换了）。而二维信号，即图片，在我们之前讲解傅里叶变化时以提到过，和一维主要差别是在维度上。所以当我们记数据采样数为 (W×H)(W \\times H)(W×H) ，有将 xxx 换为向量 x⃗=(x,y)\\vec{x} = (x,y)​x​⃗​​=(x,y) 表示： xc∈int[n2,W−n2],yc∈int[n2,H−n2]n∈intoddsFn(xc⃗)=Fn(xc,yc)=∣∑yc−n/2yc+n/2∑xc−n/2xc+n/2(f(x⃗,xc⃗)⋅S(x⃗))∣1 {\\displaystyle \\begin{aligned} x_c \\in &int [\\tfrac{n}{2}, W-\\tfrac{n}{2}], \\quad y_c \\in int [\\tfrac{n}{2}, H-\\tfrac{n}{2}] \\quad n \\in int_{odds} \\\\ \\\\ F_n(\\vec{x_c}) &= F_n(x_c, y_c) =\\vert {\\sum}_{y_c -n/2}^{y_c+n/2}{\\sum}_{x_c -n/2}^{x_c+n/2}(f(\\vec{x}, \\vec{x_c}) \\cdot S(\\vec{x})) \\vert_1 \\\\ \\end{aligned} } ​x​c​​∈​​F​n​​(​x​c​​​⃗​​)​​​​int[​2​​n​​,W−​2​​n​​],y​c​​∈int[​2​​n​​,H−​2​​n​​]n∈int​odds​​​=F​n​​(x​c​​,y​c​​)=∣∑​y​c​​−n/2​y​c​​+n/2​​∑​x​c​​−n/2​x​c​​+n/2​​(f(​x​⃗​​,​x​c​​​⃗​​)⋅S(​x​⃗​​))∣​1​​​​ 则 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 即为二维情况下的 n×nn \\times nn×n 高斯滤波卷积核。同理，更多维情况只需要扩展参数 x⃗\\vec{x}​x​⃗​​ 的向量空间即可。 可是看上去，目前的公式算不上简单。但真的是这样吗？ 假设 n=3n = 3n=3 那么 3×33 \\times 33×3 高斯滤波卷积核，实际描述的是 xc⃗\\vec{x_c}​x​c​​​⃗​​ 点周围单位距离内，相邻含 xc⃗\\vec{x_c}​x​c​​​⃗​​ 在内共 999 个节点的波动关系，有： Fn(xc⃗)=∣∑xySxy⋅f((xc,yc)−[(−1,−1),(0,−1),(1,−1)(−1,0),(0,0),(1,0)(−1,1),(0,1),(1,1)])∣1=∣∑xySxy⋅f(xc⃗−N3×3⃗)∣1 {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) &= \\vert \\sum_{xy} S_{xy} \\cdot f ( (x_c,y_c) - { \\begin{bmatrix} (-1, -1) ,& \\quad (\\quad 0, -1) ,& \\quad (\\quad 1, -1) \\\\ (-1,\\quad 0) ,& \\quad (\\quad 0,\\quad 0) ,& \\quad (\\quad 1,\\quad 0) \\\\ (-1,\\quad 1) ,& \\quad (\\quad 0,\\quad 1) ,& \\quad (\\quad 1,\\quad 1) \\end{bmatrix} }) \\vert_1 \\\\ &= \\vert \\sum_{xy}S_{xy} \\cdot f ( \\vec{x_c} - \\vec{N_{3 \\times 3}} ) \\vert_1 \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)​​​​​=∣​xy​∑​​S​xy​​⋅f((x​c​​,y​c​​)−​⎣​⎡​​​(−1,−1),​(−1,0),​(−1,1),​​​(0,−1),​(0,0),​(0,1),​​​(1,−1)​(1,0)​(1,1)​​​⎦​⎤​​)∣​1​​​=∣​xy​∑​​S​xy​​⋅f(​x​c​​​⃗​​−​N​3×3​​​⃗​​)∣​1​​​​ 一般情况，我们不会在单批（single batch）数据处理时，改变 δ\\deltaδ 的取值。假设 δ\\deltaδ 为标准正态分布取值 δ=1\\delta=1δ=1 ，那么 f(x⃗,μ⃗)f(\\vec{x},\\vec{\\mu})f(​x​⃗​​,​μ​⃗​​) 有： f(x⃗,μ⃗)=12πe−12(x⃗−μ⃗)2 f(\\vec{x},\\vec{\\mu}) = \\frac{1}{\\sqrt{2\\pi}} e ^{-\\tfrac{1}{2}(\\vec{x}-\\vec{\\mu})^2} f(​x​⃗​​,​μ​⃗​​)=​√​2π​​​​​1​​e​−​2​​1​​(​x​⃗​​−​μ​⃗​​)​2​​​​ 显然， f(x⃗,μ⃗)f(\\vec{x},\\vec{\\mu})f(​x​⃗​​,​μ​⃗​​) 在 δ\\deltaδ 取固定值的情况下，只和 (x⃗−μ⃗)(\\vec{x}-\\vec{\\mu})(​x​⃗​​−​μ​⃗​​) 的计算有关。而由于我们取 μ⃗=xc⃗\\vec{\\mu} = \\vec{x_c}​μ​⃗​​=​x​c​​​⃗​​ ，在 (x⃗−μ⃗)(\\vec{x}-\\vec{\\mu})(​x​⃗​​−​μ​⃗​​) 的计算中： ∑(x⃗−μ⃗)=∑(x⃗−xc⃗)=N3×3⃗ \\sum(\\vec{x}-\\vec{\\mu}) = \\sum(\\vec{x}-\\vec{x_c}) = \\vec{N_{3 \\times 3}} ∑(​x​⃗​​−​μ​⃗​​)=∑(​x​⃗​​−​x​c​​​⃗​​)=​N​3×3​​​⃗​​ 正好消除了变化的 x⃗\\vec{x}​x​⃗​​ 的部分，因此 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 可以被化简为： Fn(xc⃗)=∣∑xySxy⋅f(xc⃗−N3×3⃗)∣1=∣∑xySxy⋅f(N3×3⃗)∣1=∑xySxy⋅∣(12πe−12(Δx2+Δy2))xy∣1=∑xySxy⋅∣[0.075,0.124,0.0750.124,1.000,0.1240.075,0.124,0.075]∣1 {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) &= \\vert \\sum_{xy}S_{xy} \\cdot f ( \\vec{x_c} - \\vec{N_{3 \\times 3}} ) \\vert_1 = \\vert \\sum_{xy}S_{xy} \\cdot f (\\vec{N_{3 \\times 3}} ) \\vert_1 \\\\ &= \\sum_{xy}S_{xy} \\cdot \\vert ( \\frac{1}{\\sqrt{2\\pi}} e ^{-\\tfrac{1}{2}(\\Delta x^2+\\Delta y^2)} )_{xy} \\vert_1 \\\\ &= \\sum_{xy}S_{xy} \\cdot \\vert { \\begin{bmatrix} 0.075 ,& \\quad 0.124 ,& \\quad 0.075 \\\\ 0.124 ,& \\quad 1.000 ,& \\quad 0.124 \\\\ 0.075 ,& \\quad 0.124 ,& \\quad 0.075 \\end{bmatrix} } \\vert_1 \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)​​​​​​=∣​xy​∑​​S​xy​​⋅f(​x​c​​​⃗​​−​N​3×3​​​⃗​​)∣​1​​=∣​xy​∑​​S​xy​​⋅f(​N​3×3​​​⃗​​)∣​1​​​=​xy​∑​​S​xy​​⋅∣(​√​2π​​​​​1​​e​−​2​​1​​(Δx​2​​+Δy​2​​)​​)​xy​​∣​1​​​=​xy​∑​​S​xy​​⋅∣​⎣​⎡​​​0.075,​0.124,​0.075,​​​0.124,​1.000,​0.124,​​​0.075​0.124​0.075​​​⎦​⎤​​∣​1​​​​ 我们只需要依次计算卷积核范围内的点，对应信号值与概率相乘之和即可，即： Fn(xc⃗)=∣0.075⋅S(xc−1,yc−1)+0.124⋅S(xc,yc−1) +0.075⋅S(xc+1,yc−1) +0.124⋅S(xc−1,yc)+1.000⋅S(xc,yc)+0.124⋅S(xc+1,yc) +0.075⋅S(xc−1,yc−1)+0.124⋅S(xc,yc+1) +0.075⋅S(xc+1,yc+1)∣1 {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) = \\vert & 0.075 \\cdot S_{(x_c-1,y_c-1)} + 0.124 \\cdot S_{(x_c,y_c-1)}\\ + 0.075 \\cdot S_{(x_c+1,y_c-1)} \\ + \\\\ & 0.124 \\cdot S_{(x_c-1,y_c )}\\quad + 1.000 \\cdot S_{(x_c,y_c)}\\quad + 0.124 \\cdot S_{(x_c+1,y_c)} \\quad \\ + \\\\ & 0.075 \\cdot S_{(x_c-1,y_c-1)} + 0.124 \\cdot S_{(x_c,y_c+1)}\\ + 0.075 \\cdot S_{(x_c+1,y_c+1)} \\vert_1 \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)=∣​​​​​​0.075⋅S​(x​c​​−1,y​c​​−1)​​+0.124⋅S​(x​c​​,y​c​​−1)​​ +0.075⋅S​(x​c​​+1,y​c​​−1)​​ +​0.124⋅S​(x​c​​−1,y​c​​)​​+1.000⋅S​(x​c​​,y​c​​)​​+0.124⋅S​(x​c​​+1,y​c​​)​​ +​0.075⋅S​(x​c​​−1,y​c​​−1)​​+0.124⋅S​(x​c​​,y​c​​+1)​​ +0.075⋅S​(x​c​​+1,y​c​​+1)​​∣​1​​​​ 为了保证输入输出数据一致。根据卷积核的大小，我们还需要在数据的外围补充一圈空值，以保证感受野等大数据源。如果当前需要处理的数据为 (W×H)=(5×5)(W \\times H) = (5 \\times 5)(W×H)=(5×5) ，即总共 252525 个像素的单通道灰度图。经过 n×n=3×3n \\times n = 3 \\times 3n×n=3×3 大小的高斯卷积核处理后，有如下结果： 不难发现上面的 求值过大 ，这是因为我们 并没有 使用 δ=1.0\\delta = 1.0δ=1.0 时归一化后的高斯算子： f(N3×3⃗)=∣[0.075,0.124,0.0750.124,1.000,0.1240.075,0.124,0.075]∣1=[0.042,0.069,0.0420.069,0.557,0.0690.042,0.069,0.042] {\\displaystyle \\begin{aligned} f(\\vec{N_{3 \\times 3}}) &= \\vert { \\begin{bmatrix} 0.075 ,& \\quad 0.124 ,& \\quad 0.075 \\\\ 0.124 ,& \\quad 1.000 ,& \\quad 0.124 \\\\ 0.075 ,& \\quad 0.124 ,& \\quad 0.075 \\end{bmatrix} } \\vert_1 = { \\begin{bmatrix} 0.042 ,& \\quad 0.069 ,& \\quad 0.042 \\\\ 0.069 ,& \\quad 0.557 ,& \\quad 0.069 \\\\ 0.042 ,& \\quad 0.069 ,& \\quad 0.042 \\end{bmatrix} } \\\\ \\end{aligned} } ​f(​N​3×3​​​⃗​​)​​​​=∣​⎣​⎡​​​0.075,​0.124,​0.075,​​​0.124,​1.000,​0.124,​​​0.075​0.124​0.075​​​⎦​⎤​​∣​1​​=​⎣​⎡​​​0.042,​0.069,​0.042,​​​0.069,​0.557,​0.069,​​​0.042​0.069​0.042​​​⎦​⎤​​​​ 当然，也可以直接除以 f(N3×3⃗)f(\\vec{N_{3 \\times 3}})f(​N​3×3​​​⃗​​) 矩阵的秩，即 ∣f(N3×3⃗)∣δ=1.0=1.796\\vert f(\\vec{N_{3 \\times 3}}) \\vert_{\\delta = 1.0} = 1.796∣f(​N​3×3​​​⃗​​)∣​δ=1.0​​=1.796 ，作用在最终结果上。完成这一步后，整个高斯滤波单元才真正封装完毕。 对一张 (W×H)(W \\times H)(W×H) 的图片，单次标准高斯滤波需要经过 O(N)=((W−(n−2))×(H−(n−2))×8)O(N) =((W-(n-2)) \\times (H-(n-2)) \\times 8) O(N)=((W−(n−2))×(H−(n−2))×8) 次加法运算，外加单独进行的一次 n×nn \\times nn×n 卷积核大小的 f(x⃗,μ⃗)f(\\vec{x},\\vec{\\mu})f(​x​⃗​​,​μ​⃗​​) 归一化概率计算。而通过计算 f(x⃗,μ⃗)f(\\vec{x},\\vec{\\mu})f(​x​⃗​​,​μ​⃗​​) 得到的 f(N3×3⃗)f(\\vec{N_{3 \\times 3}})f(​N​3×3​​​⃗​​) ，在 δ\\deltaδ 发生改变前都可以无限复用。因此，算法非常快捷。 高斯滤波的简易 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装了。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 没有太多操作，因为关键的部分在 像素程序片（Pixel Shader/Fragment Shader） 上： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform vec2 pixel_bias; uniform mat3 gaussian_matrix; uniform sampler2D target_texture; void main() { vec3 output_; for (int i = 0; i 完成对算法求和过程的迁移。传入的 高斯算子 gaussian_matrix 和 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。由于采用 Web 展示，此处方法以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_gaussian_kernel(step, delta) { let n = step * 2 + 1; let kernel = new Float32Array(n * n); let factor_1 = 1.0 / (Math.sqrt(2.0 * Math.PI) * delta); let factor_2 = 1.0 / (2.0 * delta * delta); let normalize_div = 0; for (let i = 0; i 至此，一个简单但实用的高斯滤波器就完成了。除了上述这种使用卷积核大小一对一采样的方式外，采用单一方向的高斯滤波滑动窗口，如 v⃗n×1=(vx,vy)orient\\vec{v}_{n \\times 1} = (v_x, v_y)_{orient}​v​⃗​​​n×1​​=(v​x​​,v​y​​)​orient​​ ，也是一种减少采样数量，从而提高运算效率的方式。但由于只有指定方向的颜色关系参与了运算，单一方向高斯滤波，或者说更为通用的是近乎所有单一方向的滤波器，对数据处理后的结果，都只会表现为固定方向的过滤效果。这会使画面显得有些割裂，因此建议慎重使用。 而如果要求在保证滤波效果的同时，还能精简运算。那么我们就需更为快捷且采样更少的高斯单元了。 高斯滤波的线性插值采加速 一种通用的方式，就是在采样时引入 线性插值（Linear Sampling） ，减少采样次数。我们用 WWW 代表高斯算子，用 Wij=w(x⃗)W_{ij} =w(\\vec{x})W​ij​​=w(​x​⃗​​) 代表高斯算子在 x⃗\\vec{x}​x​⃗​​ 所处 N3×3⃗\\vec{N_{3 \\times 3}}​N​3×3​​​⃗​​ 中位置的对应 fij(N3×3⃗)f_{ij} ( \\vec{N_{3 \\times 3}})f​ij​​(​N​3×3​​​⃗​​) 值，用 s(x⃗)s(\\vec{x})s(​x​⃗​​) 代表 x⃗\\vec{x}​x​⃗​​ 在图片中的像素值。则对于采样 3×33 \\times 33×3 的 N3×3⃗\\vec{N_{3 \\times 3}}​N​3×3​​​⃗​​ 来说，由差值公式： sdst(x1⃗,x2⃗)=ssrc(x1⃗)⋅wsrc(x1⃗)+ssrc(x2⃗)⋅wsrc(x2⃗)wsrc(x1⃗)+wsrc(x2⃗) {\\displaystyle \\begin{aligned} s_{dst}(\\vec{x_1},\\vec{x_2}) &= \\frac{s_{src}(\\vec{x_1}) \\cdot w_{src}(\\vec{x_1}) + s_{src}(\\vec{x_2}) \\cdot w_{src}(\\vec{x_2})}{w_{src}(\\vec{x_1}) + w_{src}(\\vec{x_2})} \\\\ \\end{aligned} } ​s​dst​​(​x​1​​​⃗​​,​x​2​​​⃗​​)​​​​=​w​src​​(​x​1​​​⃗​​)+w​src​​(​x​2​​​⃗​​)​​s​src​​(​x​1​​​⃗​​)⋅w​src​​(​x​1​​​⃗​​)+s​src​​(​x​2​​​⃗​​)⋅w​src​​(​x​2​​​⃗​​)​​​​ 可知，999 次采样能够两两差值，从而减少到只需 555 次实际的纹理数据读。卷积核的采样位置，取四角记为 [C1,C2,C3,C4]=[S(xc−1,yc−1),S(xc−1,yc+1),S(xc+1,yc−1),S(xc+1,yc+1)][C_1, C_2, C_3, C_4] =[S_{(x_c-1,y_c-1)} , S_{(x_c-1,y_c+1)}, S_{(x_c+1,y_c-1)}, S_{(x_c+1,y_c+1)}][C​1​​,C​2​​,C​3​​,C​4​​]=[S​(x​c​​−1,y​c​​−1)​​,S​(x​c​​−1,y​c​​+1)​​,S​(x​c​​+1,y​c​​−1)​​,S​(x​c​​+1,y​c​​+1)​​] 和中心 C0=S(xc,yc)C_0 = S_{(x_c,y_c)}C​0​​=S​(x​c​​,y​c​​)​​ ，如下： Samplexy⋅[1,0,10,1,01,0,1]=[C1C2C0C3C4] {\\displaystyle \\begin{aligned} Sample_{xy} \\cdot { \\begin{bmatrix} 1 ,& \\quad 0 ,& \\quad 1 \\\\ 0 ,& \\quad 1 ,& \\quad 0 \\\\ 1 ,& \\quad 0 ,& \\quad 1 \\end{bmatrix} } = { \\begin{bmatrix} C_1 & \\quad & \\quad C_2 \\\\ & \\quad C_0 \\\\ C_3 & \\quad & \\quad C_4 \\end{bmatrix} } \\\\ \\end{aligned} } ​Sample​xy​​⋅​⎣​⎡​​​1,​0,​1,​​​0,​1,​0,​​​1​0​1​​​⎦​⎤​​=​⎣​⎡​​​C​1​​​​C​3​​​​​​C​0​​​​​​C​2​​​C​4​​​​​⎦​⎤​​​​​ 则 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 就可以表示为： Fn(xc⃗)=W00⋅C1 +W01⋅C12 +W02⋅C2  +W10⋅C13+W11⋅C0  +W12⋅C24 +W20⋅C3 +W21⋅C34 +W22⋅C4=W00⋅C1 +W01⋅W00⋅C1+W02⋅C2W00+W02  +W02⋅C2 +W10⋅W00⋅C1+W20⋅C3W00+W20  +W11⋅C0 +W12⋅W02⋅C2+W22⋅C4W02+W22  +W20⋅C3 +W21⋅W20⋅C3+W22⋅C4W20+W22  +W22⋅C4=(W00 + W00⋅W01W00 + W02+W00⋅W10W00 + W20)⋅C1 +(W02 + W02⋅W01W00 + W02+W02⋅W12W02 + W22)⋅C2 +(W20 + W20⋅W10W00 + W20+W20⋅W21W20 + W22)⋅C3 +(W22 + W22⋅W12W02 + W22+W22⋅W21W20 + W22)⋅C4 +W11⋅C0 {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) =& W_{00} \\cdot C_1 \\ + W_{01} \\cdot C_{12} \\ + W_{02} \\cdot C_{2} \\ \\ + \\\\ & W_{10} \\cdot C_{13} + W_{11} \\cdot C_{0} \\ \\ + W_{12} \\cdot C_{24} \\ + \\\\ & W_{20} \\cdot C_3 \\ + W_{21} \\cdot C_{34} \\ + W_{22} \\cdot C_{4} \\\\ =& W_{00} \\cdot C_1 \\ + W_{01} \\cdot \\tfrac{W_{00} \\cdot C_1 + W_{02} \\cdot C_2}{W_{00} + W_{02} } \\ \\ + \\\\ & W_{02} \\cdot C_{2} \\ + W_{10} \\cdot \\tfrac{W_{00} \\cdot C_1 + W_{20} \\cdot C_3}{W_{00} + W_{20} } \\ \\ + \\\\ & W_{11} \\cdot C_{0} \\ + W_{12} \\cdot \\tfrac{W_{02} \\cdot C_2 + W_{22} \\cdot C_4}{W_{02} + W_{22} } \\ \\ + \\\\ & W_{20} \\cdot C_{3} \\ + W_{21} \\cdot \\tfrac{W_{20} \\cdot C_3 + W_{22} \\cdot C_4}{W_{20} + W_{22} } \\ \\ + \\\\ & W_{22} \\cdot C_{4} \\\\ =& (W_{00}\\ +\\ \\tfrac{W_{00} \\cdot W_{01}}{W_{00}\\ +\\ W_{02}} + \\tfrac{W_{00} \\cdot W_{10}}{W_{00}\\ +\\ W_{20}})\\cdot C_1 \\ + \\\\ & (W_{02}\\ +\\ \\tfrac{W_{02} \\cdot W_{01}}{W_{00}\\ +\\ W_{02}} + \\tfrac{W_{02} \\cdot W_{12}}{W_{02}\\ +\\ W_{22}})\\cdot C_2 \\ + \\\\ & (W_{20}\\ +\\ \\tfrac{W_{20} \\cdot W_{10}}{W_{00}\\ +\\ W_{20}} + \\tfrac{W_{20} \\cdot W_{21}}{W_{20}\\ +\\ W_{22}})\\cdot C_3 \\ + \\\\ & (W_{22}\\ +\\ \\tfrac{W_{22} \\cdot W_{12}}{W_{02}\\ +\\ W_{22}} + \\tfrac{W_{22} \\cdot W_{21}}{W_{20}\\ +\\ W_{22}})\\cdot C_4 \\ + \\\\ & W_{11} \\cdot C_{0} \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)=​​​=​​​​​=​​​​​​​​W​00​​⋅C​1​​ +W​01​​⋅C​12​​ +W​02​​⋅C​2​​  +​W​10​​⋅C​13​​+W​11​​⋅C​0​​  +W​12​​⋅C​24​​ +​W​20​​⋅C​3​​ +W​21​​⋅C​34​​ +W​22​​⋅C​4​​​W​00​​⋅C​1​​ +W​01​​⋅​W​00​​+W​02​​​​W​00​​⋅C​1​​+W​02​​⋅C​2​​​​  +​W​02​​⋅C​2​​ +W​10​​⋅​W​00​​+W​20​​​​W​00​​⋅C​1​​+W​20​​⋅C​3​​​​  +​W​11​​⋅C​0​​ +W​12​​⋅​W​02​​+W​22​​​​W​02​​⋅C​2​​+W​22​​⋅C​4​​​​  +​W​20​​⋅C​3​​ +W​21​​⋅​W​20​​+W​22​​​​W​20​​⋅C​3​​+W​22​​⋅C​4​​​​  +​W​22​​⋅C​4​​​(W​00​​ + ​W​00​​ + W​02​​​​W​00​​⋅W​01​​​​+​W​00​​ + W​20​​​​W​00​​⋅W​10​​​​)⋅C​1​​ +​(W​02​​ + ​W​00​​ + W​02​​​​W​02​​⋅W​01​​​​+​W​02​​ + W​22​​​​W​02​​⋅W​12​​​​)⋅C​2​​ +​(W​20​​ + ​W​00​​ + W​20​​​​W​20​​⋅W​10​​​​+​W​20​​ + W​22​​​​W​20​​⋅W​21​​​​)⋅C​3​​ +​(W​22​​ + ​W​02​​ + W​22​​​​W​22​​⋅W​12​​​​+​W​20​​ + W​22​​​​W​22​​⋅W​21​​​​)⋅C​4​​ +​W​11​​⋅C​0​​​​ 看上去很复杂，但取中心点的二维高斯分布，其 fij(N3×3⃗)f_{ij} (\\vec{N_{3 \\times 3}} )f​ij​​(​N​3×3​​​⃗​​) 的值是随 xc⃗\\vec{x_c}​x​c​​​⃗​​ 中心对称的，有： W0=[W11]W1=[W01=W10=W12=W21]W2=[W00=W02=W20=W22] {\\displaystyle \\begin{aligned} W_0 &= [W_{11}] \\\\ W_1 &= [W_{01} = W_{10} = W_{12} = W_{21}] \\\\ W_2 &= [W_{00} = W_{02} = W_{20} = W_{22}] \\\\ \\end{aligned} } ​W​0​​​W​1​​​W​2​​​​​​=[W​11​​]​=[W​01​​=W​10​​=W​12​​=W​21​​]​=[W​00​​=W​02​​=W​20​​=W​22​​]​​ 带入到线性插值 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 表达式，则： Fn(xc⃗)=W0⋅C0+[(W1 + W2)⋅(C1 +C2 +C3 +C4 )] {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) =& W_0 \\cdot C_0 +[(W_1\\ +\\ W_2)\\cdot (C_1 \\ + C_2 \\ + C_3 \\ + C_4 \\ )] \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)=​​​​W​0​​⋅C​0​​+[(W​1​​ + W​2​​)⋅(C​1​​ +C​2​​ +C​3​​ +C​4​​ )]​​ 当取 δ=1.0\\delta = 1.0δ=1.0 时，三值得到固定的归一化取值 [W0,W1,W2]=[0.557, 0.069, 0.042][W_0,W_1,W_2] = [0.557,\\ 0.069,\\ 0.042][W​0​​,W​1​​,W​2​​]=[0.557, 0.069, 0.042] ，而 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 的表达式就只和采样相关了： Fn(xc⃗)=0.557⋅C0 + 0.111⋅(C1 +C2 +C3 +C4 ) {\\displaystyle \\begin{aligned} F_n(\\vec{x_c}) = 0.557 \\cdot C_0\\ +\\ 0.111 \\cdot (C_1 \\ + C_2 \\ + C_3 \\ + C_4 \\ ) \\\\ \\end{aligned} } ​F​n​​(​x​c​​​⃗​​)=0.557⋅C​0​​ + 0.111⋅(C​1​​ +C​2​​ +C​3​​ +C​4​​ )​​​ 所以，插值采样的高斯滤波非常精简。只需要略微调整像素程序片（Pixel Shader/Fragment Shader）的实现，而不需要对其他处理进行改动，就能完成改造： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform vec2 pixel_bias; uniform mat3 gaussian_matrix; uniform sampler2D target_texture; void main() { float gauss_factor = gaussian_matrix[0][0]+gaussian_matrix[0][1]; vec3 output_; output_ += texture2D(target_texture, fs_texcoord.xy ).rgb * gaussian_matrix[1][1]; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(-1, -1) * pixel_bias).rgb * gauss_factor; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(-1, +1) * pixel_bias).rgb * gauss_factor; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(+1, -1) * pixel_bias).rgb * gauss_factor; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(+1, +1) * pixel_bias).rgb * gauss_factor; gl_FragColor = vec4(output_, 1.0); } 加速后的高斯滤波单元，对一张 (W×H)(W \\times H)(W×H) 图片的处理的理论耗时，减少到了原耗时的 0.625⋅O(N)0.625 \\cdot O(N)0.625⋅O(N) 。采样数也同比减少了 37.5%37.5\\%37.5% 。效果上和直算相比，几乎无差别。 高斯滤波的局限性 由于高斯滤波的通用卷积核是 各向同性（Isotropic） 的，在核范围内的各方向向量与中心点的方差，仅和向量终点与核中心点的相对距离有关。因此，高斯滤波并不是没有弊端的。 我们仍然选择 μ=xc⃗\\mu = \\vec{x_c}μ=​x​c​​​⃗​​ 为核中心，假设核范围内有不包含 xc⃗\\vec{x_c}​x​c​​​⃗​​ 在内的，总计为 NNN 的 nnn 维向量 x⃗=(x1,x2, ... ,xn)∈Rn\\vec{x} = (x_1,x_2,\\ ...\\ ,x_n) \\in \\mathbb{R}^n​x​⃗​​=(x​1​​,x​2​​, ... ,x​n​​)∈R​n​​ 的采样数据 SN={Sx1⃗,Sx2⃗, ... ,SxN⃗}S_N = \\{ S_{\\vec{x_1}} , S_{\\vec{x_2}},\\ ...\\ , S_{\\vec{x_N}} \\}S​N​​={S​​x​1​​​⃗​​​​,S​​x​2​​​⃗​​​​, ... ,S​​x​N​​​⃗​​​​} 。将高斯滤波卷积核的离散程度，以非概率密度 协方差矩阵（Covariance Matrix） 的 Mcov(x⃗)M_{cov}(\\vec{x})M​cov​​(​x​⃗​​) 形式表示，记 III 为单位对角矩阵，有： Mcov(x⃗)=1N∑i=1NSxi⃗⋅[(x1−xc1)2(x2−xc2)2...(xn−xcn)2]=∑Δx2⋅I∈Rn×n {\\displaystyle \\begin{aligned} M_{cov}(\\vec{x}) &= \\tfrac{1}{N} \\sum_{i = 1}^{N} S_{\\vec{x_i}} \\cdot { \\begin{bmatrix} (x_1-x_{c1})^2 & \\quad & \\quad & \\quad \\\\ & \\quad (x_2-x_{c2})^2 & \\quad & \\quad \\\\ & \\quad & \\quad ... & \\quad\\\\ & \\quad & \\quad & \\quad (x_n-x_{cn})^2 \\end{bmatrix} } \\\\ &= \\sum \\Delta x^2 \\cdot I \\in \\mathbb{R}^{n \\times n} \\\\ \\end{aligned} } ​M​cov​​(​x​⃗​​)​​​​​=​N​​1​​​i=1​∑​N​​S​​x​i​​​⃗​​​​⋅​⎣​⎢​⎢​⎡​​​(x​1​​−x​c1​​)​2​​​​​​​​​(x​2​​−x​c2​​)​2​​​​​​​​​...​​​​​​​(x​n​​−x​cn​​)​2​​​​​⎦​⎥​⎥​⎤​​​=∑Δx​2​​⋅I∈R​n×n​​​​ 多维高斯的协方差矩阵，只有对角线的 方差（Variance）存在非 000 取值 ，而衡量参数交叠影响的 协方差（Covariance）皆为 000 值 。所以，高斯滤波没有考虑维度方位信息带来的数据间的差异，每一个维度仅对自身属性产生影响。因此，高斯核总是中心对称 。 这一特征体现在二维信号的处理上时，就表现为经过高斯滤波处理的图片，轮廓细节会有所丢失（物体更不容易分辨，而非单纯颜色变得规整）。同时，也更容易因为算法导致的频率扰动，产生高频变化规律缺失，像素朝核的外边缘等量的分散运动而出现摩尔纹（Moire Pattern） 。毕竟图片的高频部分，才是保存轮廓信息的关键。但高斯滤波本质上却是全通量的概率权重控制。 那么有没有能够在一定程度上，既保留高频细节的同时，又能够相对独立的处理低频波动的算法呢？ 考虑问题主要出现在高斯滤波的各向同性，或许可以通过引入高低频差异修饰滤波器，来达成要求。这种做法被称为 边缘保存（Edge Preserving） 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:12 "},"Chapter_3/Language/cn/Docs_3_2_2.html":{"url":"Chapter_3/Language/cn/Docs_3_2_2.html","title":"3.2.2 双边滤波（Bilateral Filter）","keywords":"","body":"3.2.2 双边滤波（Bilateral Filter） 双边滤波（Bilateral Filter） 是在高斯滤波基础上，基于 边缘保存（Edge Preserving） 滤波思想，通过一个 空间域（Spatial Domain/Domain）标准高斯滤波 和 灰度值（Gray Range/Range）朴素高斯分布 的共同作用，形成的 高斯滤波变体 。 由于二维信号的高频部分，在灰度通道上体现的更为明确（本质起作用的是物理意义上的光亮度信息，人眼主要通过光亮度差异来感知物体轮廓 。光亮度的多种衍生抽象，和相关概念是如何迁移数据化到计算机视觉体系内的，会在本书第三章详细讲解）。所以，双边滤波引入对灰度值的高斯，是期望提取核内灰度变化特征，来得到各频率波的核内密度分布情况。 进而对核内标准高斯滤波像素值概率密度结果进行修饰，得到 带有截面的单向滤波卷积核（Single Orientation Filter） 。 图 3.2.2-1 双边滤波经过灰度裁剪后，在轮廓边缘处的卷积核示意图 [13] 因此，双边滤波属于 混合高斯卷积核（Combined Gaussian Kernel） 滤波器的一种。我们需要分别计算 空间高斯权重（SGW [Spatial Gaussian Weight]） 和 灰度高斯权重（GGW [Gray Gaussian Weight]） 两部分，并混合权重得到最终的双边滤波矩阵。 双边滤波的混合高斯权重 空间高斯权重（SGW） ，也被称为 领域权重（Domain Weight） ，记为 Gs(x⃗,μ⃗)G_s(\\vec{x},\\vec{\\mu})G​s​​(​x​⃗​​,​μ​⃗​​) ，有波动参数 δs\\delta_sδ​s​​ 。其本身代表，以选定中心点 μ⃗=xc⃗\\vec{\\mu} = \\vec{x_c}​μ​⃗​​=​x​c​​​⃗​​ 与卷积核内相邻点的欧式距离，求得的 二维高斯概率分布 结果。即： Gs(x⃗,xc⃗)=12π⋅δse−(x⃗−xc⃗)22⋅δs2=12π⋅δse−(Δx2+Δy2)2⋅δs2 {\\displaystyle \\begin{aligned} G_s(\\vec{x},\\vec{x_c}) = \\frac{1}{\\sqrt{2\\pi} \\cdot \\delta_s} e ^{-\\tfrac{(\\vec{x}-\\vec{x_c})^2}{2 \\cdot {\\delta_s}^2}} = \\frac{1}{\\sqrt{2\\pi} \\cdot \\delta_s} e ^{-\\tfrac{(\\Delta x^2+\\Delta y^2)}{2 \\cdot {\\delta_s}^2}} \\\\ \\end{aligned} } ​G​s​​(​x​⃗​​,​x​c​​​⃗​​)=​√​2π​​​⋅δ​s​​​​1​​e​−​2⋅δ​s​​​2​​​​(​x​⃗​​−​x​c​​​⃗​​)​2​​​​​​=​√​2π​​​⋅δ​s​​​​1​​e​−​2⋅δ​s​​​2​​​​(Δx​2​​+Δy​2​​)​​​​​​​ 灰度高斯权重（GGW） ，也被称为 尺度权重（Range Weight） ，记为 Gr(x⃗,μ⃗)G_r(\\vec{x},\\vec{\\mu})G​r​​(​x​⃗​​,​μ​⃗​​) ，有波动参数 δr\\delta_rδ​r​​ 。其本身代表，以选定中心点 μ⃗=xc⃗\\vec{\\mu} = \\vec{x_c}​μ​⃗​​=​x​c​​​⃗​​ 灰度 gray(xc⃗)gray(\\vec{x_c})gray(​x​c​​​⃗​​) 与卷积核内相邻点灰度 gray(x⃗)gray(\\vec{x})gray(​x​⃗​​) 的方差，求得的 一维高斯概率分布 结果。记 S(x)={r,g,b}S(x) = \\{r,g,b \\}S(x)={r,g,b} 有： Gr(x⃗,xc⃗)=12π⋅δre−(gray(x⃗)−gray(xc⃗))22⋅δr2=12π⋅δre−(Δr2+Δg2+Δb2)2⋅δr2 {\\displaystyle \\begin{aligned} G_r(\\vec{x},\\vec{x_c}) = \\frac{1}{\\sqrt{2\\pi} \\cdot \\delta_r} e ^{-\\tfrac{(gray(\\vec{x})-gray(\\vec{x_c}))^2}{2 \\cdot {\\delta_r}^2}} = \\frac{1}{\\sqrt{2\\pi} \\cdot \\delta_r} e ^{-\\tfrac{(\\Delta r^2+\\Delta g^2 +\\Delta b^2)}{2 \\cdot {\\delta_r}^2}} \\\\ \\end{aligned} } ​G​r​​(​x​⃗​​,​x​c​​​⃗​​)=​√​2π​​​⋅δ​r​​​​1​​e​−​2⋅δ​r​​​2​​​​(gray(​x​⃗​​)−gray(​x​c​​​⃗​​))​2​​​​​​=​√​2π​​​⋅δ​r​​​​1​​e​−​2⋅δ​r​​​2​​​​(Δr​2​​+Δg​2​​+Δb​2​​)​​​​​​​ 以 ∣target∣1\\vert target \\vert_1∣target∣​1​​ 表示归一化操作，记混合高斯权重为 W(x⃗,μ⃗)W(\\vec{x},\\vec{\\mu})W(​x​⃗​​,​μ​⃗​​) ，则： W(x⃗,xc⃗)=∣Gs(x⃗,xc⃗)⋅Gr(x⃗,xc⃗)∣1 {\\displaystyle \\begin{aligned} W(\\vec{x},\\vec{x_c}) &= \\vert G_s(\\vec{x},\\vec{x_c}) \\cdot G_r(\\vec{x},\\vec{x_c}) \\vert_1 \\\\ \\end{aligned} } ​W(​x​⃗​​,​x​c​​​⃗​​)​​​​=∣G​s​​(​x​⃗​​,​x​c​​​⃗​​)⋅G​r​​(​x​⃗​​,​x​c​​​⃗​​)∣​1​​​​ 由于，空间高斯权重其实就是标准高斯滤波权重 ，因此 ∣Gs(x⃗,μ⃗)∣1=f(Nn×n⃗)\\vert G_s(\\vec{x},\\vec{\\mu}) \\vert_1 = f( \\vec{N_{n \\times n}} )∣G​s​​(​x​⃗​​,​μ​⃗​​)∣​1​​=f(​N​n×n​​​⃗​​) 。我们沿用上节高斯滤波的设定，取用 n×n=3×3n \\times n = 3 \\times 3n×n=3×3 大小卷积核，滤波函数记为 Bn(xc⃗)B_n(\\vec{x_c})B​n​​(​x​c​​​⃗​​) ，则： Bn(xc⃗)=∣∑xySxy⋅W(xc⃗−N3×3⃗)∣1=∣∑xySxy⋅W(N3×3⃗)∣1=∣∑xySxyGs(x⃗,xc⃗)⋅Gr(x⃗,xc⃗)∣1=∣∑xySxyf(x⃗,xc⃗)∣1⋅[Gr(x⃗,xc⃗)∑Gr(xc⃗)]∈R3×3Bn(xc⃗)=Fn(xc⃗)⋅∣Gr(xc⃗)∣1∈R3×3 {\\displaystyle \\begin{aligned} B_n(\\vec{x_c}) &= \\vert \\sum_{xy}S_{xy} \\cdot W( \\vec{x_c} - \\vec{N_{3 \\times 3}} ) \\vert_1 = \\vert \\sum_{xy}S_{xy} \\cdot W( \\vec{N_{3 \\times 3}} ) \\vert_1 \\\\ &= \\vert \\sum_{xy}S_{xy} G_s(\\vec{x},\\vec{x_c}) \\cdot G_r(\\vec{x},\\vec{x_c}) \\vert_1 \\\\ &= \\vert \\sum_{xy}S_{xy} f(\\vec{x},\\vec{x_c}) \\vert_1 \\cdot [\\frac{ G_r(\\vec{x},\\vec{x_c}) }{\\sum G_r(\\vec{x_c})}] \\in \\mathbb{R}^{3 \\times 3} \\\\ B_n(\\vec{x_c}) &= F_n(\\vec{x_c}) \\cdot \\vert G_r(\\vec{x_c}) \\vert_1 \\in \\mathbb{R}^{3 \\times 3} \\\\ \\end{aligned} } ​B​n​​(​x​c​​​⃗​​)​​​B​n​​(​x​c​​​⃗​​)​​​​=∣​xy​∑​​S​xy​​⋅W(​x​c​​​⃗​​−​N​3×3​​​⃗​​)∣​1​​=∣​xy​∑​​S​xy​​⋅W(​N​3×3​​​⃗​​)∣​1​​​=∣​xy​∑​​S​xy​​G​s​​(​x​⃗​​,​x​c​​​⃗​​)⋅G​r​​(​x​⃗​​,​x​c​​​⃗​​)∣​1​​​=∣​xy​∑​​S​xy​​f(​x​⃗​​,​x​c​​​⃗​​)∣​1​​⋅[​∑G​r​​(​x​c​​​⃗​​)​​G​r​​(​x​⃗​​,​x​c​​​⃗​​)​​]∈R​3×3​​​=F​n​​(​x​c​​​⃗​​)⋅∣G​r​​(​x​c​​​⃗​​)∣​1​​∈R​3×3​​​​ 而 ∑Gr(xc⃗)\\sum G_r(\\vec{x_c})∑G​r​​(​x​c​​​⃗​​) 就是一维高斯曲线的线下面积，有 ∑Gr(xc⃗)=1\\sum G_r(\\vec{x_c}) = 1∑G​r​​(​x​c​​​⃗​​)=1 ，所以： Bn(xc⃗)=Fn(xc⃗)⋅Gr(xc⃗)∈R3×3 {\\displaystyle \\begin{aligned} B_n(\\vec{x_c}) &= F_n(\\vec{x_c}) \\cdot G_r(\\vec{x_c}) \\in \\mathbb{R}^{3 \\times 3} \\\\ \\end{aligned} } ​B​n​​(​x​c​​​⃗​​)​​​​=F​n​​(​x​c​​​⃗​​)⋅G​r​​(​x​c​​​⃗​​)∈R​3×3​​​​ 上式中 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 即为高斯滤波核函数 。 可见，适用于高斯滤波 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) 的快速算法，同样也适用于双边滤波 Bn(xc⃗)B_n(\\vec{x_c})B​n​​(​x​c​​​⃗​​) 。 为什么通过核内频率采用朴素高斯分布，能够达到裁切的目的呢？这是因为，当卷积核目标中心点处于图像中物体的轮廓位置附近时，卷积核内的频率分布会出现相对非轮廓区域更为强烈的波动 。 而高斯分布，即正态分布，恰恰是一种常用的放缩范围内数据波动的手段。 在标准高斯滤波中，我们通过多维高斯，粗浅的处理了整体数据上的波动性。这种处理方式，相当于将图像经过二维傅里叶变换得到的空域（SD）数据和频域（FD）数据，统一按照全通道空域的像素均值分布情况进行了概率平均。忽略了频域本身所具有的实际意义。而灰度值高斯的作用，就是 间接 的达成抽象频域数据波动特征的目的。 通过降低 δr\\delta_rδ​r​​ 取值，放大核内频率差异情况。增强高频部分的权重，衰减低频占比。因此，对于双边滤波来说：在满足取 δd\\delta_dδ​d​​ 越小，波动性越强越激烈，图片越尖锐；反之 δd\\delta_dδ​d​​ 越大，波动性越弱越平缓，图片越模糊的同时；取 δr\\delta_rδ​r​​ 越大，高低频差异缩减，边缘越模糊；反之 δr\\delta_rδ​r​​ 越小，高低频差异被放大，边缘越清晰。 双边滤波的 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装了。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 没有太多操作，因为关键的部分在 像素程序片（Pixel Shader/Fragment Shader） 上： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform vec2 pixel_bias; uniform mat3 gaussian_matrix; uniform float gaussian_range; uniform sampler2D target_texture; float variance(vec3 c1, vec3 c2){ vec3 temp = c2 - c1; return temp[0] * temp[0] + temp[1] * temp[1] + temp[2] * temp[2]; } void main() { vec3 output_; vec4 color_center = texture2D(target_texture, fs_texcoord.xy); for (int i = 0; i 完成对算法求和过程的迁移。传入的 高斯算子 gaussian_matrix 和 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。而 灰度高斯权重 gaussian_range 涉及到实际采样，需要直接传入。由于采用 Web 展示，此处方法以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_gaussian_kernel(step, delta) { let n = step * 2 + 1; let kernel = new Float32Array(n * n); let factor_1 = 1.0 / (Math.sqrt(2.0 * Math.PI) * delta); let factor_2 = 1.0 / (2.0 * delta * delta); let normalize_div = 0; for (let i = 0; i 如上，双边滤波需要固定计算的部分，和标准高斯滤波并无不同。工程中，仅在像素程序片的实现上存在差异。 同理，双边滤波也是可以使用 线性插值（Linear Sampling） 代替部分采样，来进行加速。和标准高斯滤波一样，只需要略微调整像素程序片（Pixel Shader/Fragment Shader）的实现： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform vec2 pixel_bias; uniform mat3 gaussian_matrix; uniform float gaussian_range; uniform sampler2D target_texture; float variance(vec3 c1, vec3 c2){ vec3 temp = c2 - c1; return temp[0] * temp[0] + temp[1] * temp[1] + temp[2] * temp[2]; } void main() { vec4 color_center = texture2D(target_texture, fs_texcoord.xy); float gauss_factor = gaussian_matrix[0][0]+gaussian_matrix[0][1]; vec3 output_ = texture2D(target_texture, fs_texcoord.xy ).rgb * gaussian_matrix[1][1]; for (int i = 0; i 至此，一个标准双边滤波器，和它的线性采样快速版就完成了。 双边滤波的局限性 双边滤波是否彻底的解决了高斯滤波的局限性问题呢？答案是解决了 一部分 。 引入高低频分布密度权重，虽然能够处理图像中物体轮廓边缘模糊现象，达到强度可控的 边缘保存（Edge Preserving） 。但由于灰度高斯权重，单一维度单一方向梯度的特点。在利用双边滤波增强高频波权重的同时，也会 增大由标准高斯滤波高频分散运动带来的干扰 。这反而会让增强边缘细节过程中产生的 摩尔纹（Moire Pattern）更加显著 。 为处理这个问题，我们相对放松对算力的限制。一个可行的方案是在标准高斯滤波的基础上，通过使用多个方向梯度共同作用，重新构造一个满足 非各向同性（Not Isotropic） 条件的滤波单元 （毕竟非全方位的梯度差异，还无法满足各向异性条件） ，来保存和引入核内像素移动和频率波传导关系。使我们能够对核内像素所占均值比重进行更为合理的分配，起到缓解效果。 这种多梯度的方式，会增强算法对图像边缘的处理能力，保存边缘的同时增强细节。因此也被称为 边缘锐化（Edge Sharpening） 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_2_3.html":{"url":"Chapter_3/Language/cn/Docs_3_2_3.html","title":"3.2.3 拉普拉斯滤波（Laplacian Filter）","keywords":"","body":"3.2.3 拉普拉斯滤波（Laplacian Filter） 拉普拉斯滤波（Laplacian Filter） 是一种基于二阶微分方程的差异扩大化算子（Operator）。其不仅可以从灰度出发用于物体的 边缘锐化（Edge Sharpening） ，也可以应用于全通道的色彩变化增强，即 广义锐化（Sharpening）。 数学上，一阶微分能够突出原函数连续变化的幅度特征（即原函数斜率），二阶微分则进一步扩大了对这种变化趋势（即导数的斜率）的描述。而基于多参数的二阶偏导数方程，在展示参数本身对趋势影响的同时，也能够说明两两参数间的影响关系。 由于是对趋势的求导，以离散数据逼近信号的二阶微分方程，只需要使用目标相邻采样做差值计算即可，且并不会影响周边点各自的趋势判断。正好符合目标情况卷积核，对核内关系闭环和抗干扰的要求。所以，拉普拉斯滤波以卷积核中心点构建包含全部方向参数（Orient Axis）的平面坐标系，核内采样求得中心点突变权重的二阶导数展式。用它增强核内数据中心的突变特征。 二维拉普拉斯滤波核 对于二维信号，即图片信号，来说。拉普拉斯卷积核只有 xyxyxy 两个方向参数。记原信号为 S(x)S(x)S(x) ，原信号的二阶导数为 ∇2S(x)\\nabla^2 S(x)∇​2​​S(x) 。仍然取用大小 n×n=3×3n \\times n = 3 \\times 3n×n=3×3 ，中心点 xc⃗\\vec{x_c}​x​c​​​⃗​​ 的卷积核，记边缘检测拉普帕斯滤波核函数为 Lp(xc⃗)\\mathcal{L}_p(\\vec{x_c})L​p​​(​x​c​​​⃗​​) ，则： Lp(xc⃗)=−K⋅∇2S(xc⃗) {\\displaystyle \\begin{aligned} \\mathcal{L}_p(\\vec{x_c}) = -K \\cdot \\nabla^2 S(\\vec{x_c}) \\\\ \\end{aligned} } ​L​p​​(​x​c​​​⃗​​)=−K⋅∇​2​​S(​x​c​​​⃗​​)​​​ 考虑到需要调节边缘检测强弱。我们采用强度因子 K∈(−∞,+∞)K \\in (-\\infty, +\\infty)K∈(−∞,+∞) 作为权重，以便进行敏感度控制。 则 KKK 取正值时增强， KKK 取负值时衰减， 绝对值 ∣K∣\\vert K \\vert∣K∣ 大小表示放缩强度。 记核函数为 Ln(xc⃗)\\mathcal{L}_n(\\vec{x_c})L​n​​(​x​c​​​⃗​​) ，有： Ln(xc⃗)=S(xc⃗)+Lp(xc⃗)=S(xc⃗)−K⋅∇2S(xc⃗) {\\displaystyle \\begin{aligned} \\mathcal{L}_n(\\vec{x_c}) =& S(\\vec{x_c}) + \\mathcal{L}_p(\\vec{x_c}) \\\\ =& S(\\vec{x_c}) - K \\cdot \\nabla^2 S(\\vec{x_c}) \\\\ \\end{aligned} } ​L​n​​(​x​c​​​⃗​​)=​=​​​​S(​x​c​​​⃗​​)+L​p​​(​x​c​​​⃗​​)​S(​x​c​​​⃗​​)−K⋅∇​2​​S(​x​c​​​⃗​​)​​ 若 Lp(xc⃗)\\mathcal{L}_p(\\vec{x_c})L​p​​(​x​c​​​⃗​​) 不计算偏导数在内，即 只处理轴方向二阶导数 。我们就可以得到 双通（2-Way）拉普拉斯核 ： ∇2S(x)=d2S(xc⃗)dxc⃗2=∂2S∂x2+∂2S∂y2=S(x−1, y) − 2⋅S(x,y) + S(x+1, y) + S(x,y−1) − 2⋅S(x,y) + S(x,y+1)Lp(xc⃗)=−K⋅∑xySxy⋅[0,  1,  01,−4,  10,  1,  0]Ln(xc⃗)=−K⋅∑xySxy⋅[0,  1,  01,−4,  10,  1,  0] + S(xc⃗) {\\displaystyle \\begin{aligned} \\nabla^2 S(x) =& \\tfrac{\\mathrm{d}^2 S(\\vec{x_c})}{\\mathrm{d}{\\vec{x_c}^2}} = \\tfrac{ \\partial^2 S}{\\partial x^2} + \\tfrac{ \\partial^2 S}{\\partial y^2} \\\\ =& S(x-1,\\ y)\\ -\\ 2 \\cdot S(x,y)\\ +\\ S(x+1,\\ y)\\ +\\ \\\\ & S(x,y-1)\\ -\\ 2 \\cdot S(x,y)\\ +\\ S(x,y+1) \\\\ \\mathcal{L}_p(\\vec{x_c}) =& -K \\cdot \\sum_{xy}S_{xy} \\cdot { \\begin{bmatrix} 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\\\ 1 ,& \\quad -4 ,& \\quad \\ \\ 1 \\\\ 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\end{bmatrix} }\\\\ \\mathcal{L}_n(\\vec{x_c}) =& - K \\cdot \\sum_{xy}S_{xy} \\cdot { \\begin{bmatrix} 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\\\ 1 ,& \\quad -4 ,& \\quad \\ \\ 1 \\\\ 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\end{bmatrix} }\\ +\\ S(\\vec{x_c}) \\\\ \\end{aligned} } ​∇​2​​S(x)=​=​​L​p​​(​x​c​​​⃗​​)=​L​n​​(​x​c​​​⃗​​)=​​​​​d​x​c​​​⃗​​​2​​​​d​2​​S(​x​c​​​⃗​​)​​=​∂x​2​​​​∂​2​​S​​+​∂y​2​​​​∂​2​​S​​​S(x−1, y) − 2⋅S(x,y) + S(x+1, y) + ​S(x,y−1) − 2⋅S(x,y) + S(x,y+1)​−K⋅​xy​∑​​S​xy​​⋅​⎣​⎡​​​0,​1,​0,​​​  1,​−4,​  1,​​​  0​  1​  0​​​⎦​⎤​​​−K⋅​xy​∑​​S​xy​​⋅​⎣​⎡​​​0,​1,​0,​​​  1,​−4,​  1,​​​  0​  1​  0​​​⎦​⎤​​ + S(​x​c​​​⃗​​)​​ 若 Lp(xc⃗)\\mathcal{L}_p(\\vec{x_c})L​p​​(​x​c​​​⃗​​) 包含对角方向 的影响，即处理偏导数情况，我们就可以得到 四通（4-Way）拉普拉斯核 ： ∇2S(x)=d2S(xc⃗)dxc⃗2=∂2S∂x2+∂2S∂x∂y+∂2S∂y∂x+∂2S∂y2=S(x−1, y+0) − 2⋅S(x, y) + S(x+1, y+0) + S(x−1, y−1) − 2⋅S(x, y) + S(x+1, y+1) + S(x+1, y−1) − 2⋅S(x, y) + S(x−1, y+1) + S(x+0, y−1) − 2⋅S(x, y) + S(x+0, y+1) Lp(xc⃗)=−K⋅∑xySxy⋅[1,  1,  11,−8,  11,  1,  1]Ln(xc⃗)=−K⋅∑xySxy⋅[1,  1,  11,−8,  11,  1,  1] + S(xc⃗) {\\displaystyle \\begin{aligned} \\nabla^2 S(x) =& \\tfrac{\\mathrm{d}^2 S(\\vec{x_c})}{\\mathrm{d}{\\vec{x_c}^2}} = \\tfrac{ \\partial^2 S}{\\partial x^2} + \\tfrac{ \\partial^2 S}{\\partial x \\partial y} + \\tfrac{ \\partial^2 S}{\\partial y \\partial x} + \\tfrac{ \\partial^2 S}{\\partial y^2} \\\\ =& S(x-1,\\ y+0)\\ -\\ 2 \\cdot S(x,\\ y)\\ +\\ S(x+1,\\ y+0)\\ +\\ \\\\ & S(x-1,\\ y-1)\\ -\\ 2 \\cdot S(x,\\ y)\\ +\\ S(x+1,\\ y+1)\\ +\\ \\\\ & S(x+1,\\ y-1)\\ -\\ 2 \\cdot S(x,\\ y)\\ +\\ S(x-1,\\ y+1)\\ +\\ \\\\ & S(x+0,\\ y-1)\\ -\\ 2 \\cdot S(x,\\ y)\\ +\\ S(x+0,\\ y+1)\\ \\\\ \\mathcal{L}_p(\\vec{x_c}) =& -K \\cdot \\sum_{xy}S_{xy} \\cdot { \\begin{bmatrix} 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad -8 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 \\end{bmatrix} }\\\\ \\mathcal{L}_n(\\vec{x_c}) =& - K \\cdot \\sum_{xy}S_{xy} \\cdot { \\begin{bmatrix} 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad -8 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 \\end{bmatrix} }\\ +\\ S(\\vec{x_c}) \\\\ \\end{aligned} } ​∇​2​​S(x)=​=​​​​L​p​​(​x​c​​​⃗​​)=​L​n​​(​x​c​​​⃗​​)=​​​​​d​x​c​​​⃗​​​2​​​​d​2​​S(​x​c​​​⃗​​)​​=​∂x​2​​​​∂​2​​S​​+​∂x∂y​​∂​2​​S​​+​∂y∂x​​∂​2​​S​​+​∂y​2​​​​∂​2​​S​​​S(x−1, y+0) − 2⋅S(x, y) + S(x+1, y+0) + ​S(x−1, y−1) − 2⋅S(x, y) + S(x+1, y+1) + ​S(x+1, y−1) − 2⋅S(x, y) + S(x−1, y+1) + ​S(x+0, y−1) − 2⋅S(x, y) + S(x+0, y+1) ​−K⋅​xy​∑​​S​xy​​⋅​⎣​⎡​​​1,​1,​1,​​​  1,​−8,​  1,​​​  1​  1​  1​​​⎦​⎤​​​−K⋅​xy​∑​​S​xy​​⋅​⎣​⎡​​​1,​1,​1,​​​  1,​−8,​  1,​​​  1​  1​  1​​​⎦​⎤​​ + S(​x​c​​​⃗​​)​​ 显然，四通拉普拉斯对中心点突变特征能有更好的提炼。如果需要对更多方向进行评估，则需要增大核面积。根据拉普拉斯二阶微分自身的特性可知，大小为 n×nn \\times nn×n 的卷积核，可选评估方向为 2(n−1)2(n-1)2(n−1) 个，相应的需求采样也会成倍扩增。且增大采样面积仅仅是预先提炼出，中心点周边的相邻点的突变情况。用这些点的加权增强值来计算中心点加权增强值。所以，更大的拉普拉斯核只是利用了小核的富集，反而并不一定能够得到更优秀的筛选结果（比如单核内波动，具有复杂高低差变化时）。因此，为了相对保证结果的稳定性，我们一般不会采用超过 n×n=3×3n \\times n = 3 \\times 3n×n=3×3 大小的拉普拉斯卷积核。 拉普拉斯滤波的 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装了。 如果是 边缘锐化（Edge Sharpening） 的场景，数据只采用灰度值处理即可。对于 原色格式（Primaries Format）为 CIE RGB 1931 色彩空间 的数据，可按下式用 RGB 快速换算： Grey=0.299⋅R + 0.587⋅G + 0.114⋅B Grey = 0.299 \\cdot R\\ +\\ 0.587 \\cdot G\\ +\\ 0.114 \\cdot B Grey=0.299⋅R + 0.587⋅G + 0.114⋅B 此处演示为了便于说明和展示，选择采用更广泛的适用范围，针对广义锐化（Sharpening）构造像素全通道采样的拉普拉斯滤波器。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 没有太多操作，因为关键的部分在 像素程序片（Pixel Shader/Fragment Shader） 上。依据双通还是四通做一下区分。我们采用两种实现，双通情况下直接计算，有： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform bool only_edge; uniform vec2 pixel_bias; uniform mat3 laplacian_matrix; uniform sampler2D target_texture; void main() { vec3 output_; output_ += texture2D(target_texture, fs_texcoord.xy).rgb * ((only_edge? 0.0 : 1.0) + laplacian_matrix[1][1]); output_ += texture2D(target_texture, fs_texcoord.xy + vec2(-1, -1) * pixel_bias).rgb * laplacian_matrix[0][0]; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(-1, +1) * pixel_bias).rgb * laplacian_matrix[2][0]; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(+1, -1) * pixel_bias).rgb * laplacian_matrix[0][2]; output_ += texture2D(target_texture, fs_texcoord.xy + vec2(+1, +1) * pixel_bias).rgb * laplacian_matrix[2][2]; gl_FragColor = vec4(output_, 1.0); } 四通则采用 for 循环实现，传入双通的 拉普拉斯算子 laplacian_matrix 即可兼容，有： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform bool only_edge; uniform vec2 pixel_bias; uniform mat3 laplacian_matrix; uniform sampler2D target_texture; void main() { vec3 output_ = only_edge? vec3(0) : texture2D(target_texture, fs_texcoord.xy).rgb; for (int i = 0; i 上述程序片中，我们通过 only_edge 开关 控制是否只获取边缘信息。而传入的 拉普拉斯算子 laplacian_matrix 和 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。由于采用 Web 展示，此处方法以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_laplacian_kernel(step, way_count, str_factor) { let n = step * 2 + 1; let max_way = (n - 1) * 2; let cur_way = Math.min(way_count, max_way); let way_step = Math.floor(max_way / cur_way); let kernel = new Float32Array(n * n); for (let i = 0; i 至此，双通和四通的标准拉普拉斯广义锐化滤波器程序片就完成了。 拉普拉斯滤波的局限性 从卷积核可以看出，拉普拉斯滤波仍然是固定梯度的。但是否启用对角元素（Diagonal Elements）对卷积核特性还是会有较大的影响的。 双通拉普拉斯，只对于横纵方向上的数据敏感，构成的卷积核为 非各向同性（Not Isotropic） 卷积核。但是在有权重的方向上，数据变化梯度（Gradient）却是等大的。因此，双通拉普拉斯也 非各向异性（Not Anisotropic） 。 四通拉普拉斯，由于引入对角线方向代表的 45∘45^{\\circ}45​∘​​ 、 135∘135^{\\circ}135​∘​​ 、 225∘225^{\\circ}225​∘​​ 、 315∘315^{\\circ}315​∘​​ 的计算，使 3×33 \\times 33×3 核心相邻元素所含所有方向上的梯度都成为等大参考值，因此，四通拉普拉斯的卷积核，为 各向同性（Isotropic） 卷积核。 所以，虽然四通拉普拉斯能够更好的提取临界边缘特征，但也会同步的保留并增强高频扰动，从而在结果中留存更多的高频噪音。双通则要相对好一些，但相应的临界特征提取能力也变得更弱。不过，若是能够提升数据源的质量，通过 先行降噪（NRF [Noise Reduction First]） 过滤部分干扰。那么理论上，最终提取产物的质量也会有一定程度的提升。马尔滤波（Marr Filter） 就是对此方向的探索。 同时，拉普拉斯滤波 并非是脱离中心参考值的边缘锐化（Edge Sharpening）算法 ，对于一些复杂的边缘位置波动情况，会有 边缘扩散（Edge Spread） 的风险。且由于 包含高权重的中心值参与了计算过程 ，使得拉普拉斯滤波对噪声非常敏感，从而极易丢失边缘方向信息，最终导致检测得到的边缘不连续。基于该情况，部分后续的改进算法采用了 *去中心化（Center Insensitive） 思想，来一定程度上避免问题发生。比如， 索贝尔滤波（Sobel Filter） 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_2_4.html":{"url":"Chapter_3/Language/cn/Docs_3_2_4.html","title":"3.2.4 马尔滤波（Marr Filter）","keywords":"","body":"3.2.4 马尔滤波（Marr Filter） 马尔滤波（Marr Filter） 是拉普拉斯滤波采用 先行降噪（NRF [Noise Reduction First]） 的改进算法。利用高斯滤波对频率波动性的处理能力，对图片的高频信息进行模糊过滤。再行使标准拉普拉斯边缘检测，筛选突变明显的剩余高频部分并增强，达到更好的效果 [14] 。 因此马尔滤波也被称为 拉普拉斯-高斯滤波（LoG [Laplacian of Gaussian]） ，或 马尔-希德雷斯算法（Marr–Hildreth Algorithm） 。还是以 ∣target∣1\\vert target \\vert_1∣target∣​1​​ 表示归一化操作。我们记高斯滤波核函数为 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) ，记 LoG 的边缘检测核函数为 LoGp(xc⃗){LoG}_p(\\vec{x_c})LoG​p​​(​x​c​​​⃗​​) ，有： LoGn(xc⃗)=Lp(xc⃗)∣Fn=−K⋅∇2Fn(xc⃗) {\\displaystyle \\begin{aligned} {LoG}_n(\\vec{x_c}) =& \\mathcal{L}_p(\\vec{x_c})|_{F_n} = -K \\cdot \\nabla^2 F_n(\\vec{x_c}) \\\\ \\end{aligned} } ​LoG​n​​(​x​c​​​⃗​​)=​​​​L​p​​(​x​c​​​⃗​​)∣​F​n​​​​=−K⋅∇​2​​F​n​​(​x​c​​​⃗​​)​​ 其中 KKK 是我们取来控制强度的强度因子，展开简化上式有： LoGp(xc⃗)=−K⋅∑xySxy⋅∣(−1πδ4⋅[1−(Δx2+Δy2)2⋅δ2]⋅e−(Δx2+Δy2)2⋅δ2)xy∣1 {\\displaystyle \\begin{aligned} {LoG}_p(\\vec{x_c}) =& -K \\cdot \\sum_{xy}S_{xy} \\cdot \\vert ( -\\tfrac{1}{\\pi \\delta ^4} \\cdot [1- \\tfrac{(\\Delta x^2+\\Delta y^2)}{2 \\cdot \\delta ^2}] \\cdot e ^{-\\tfrac{(\\Delta x^2+\\Delta y^2)}{2 \\cdot \\delta ^2}})_{xy} \\vert_1 \\\\ \\end{aligned} } ​LoG​p​​(​x​c​​​⃗​​)=​​​​−K⋅​xy​∑​​S​xy​​⋅∣(−​πδ​4​​​​1​​⋅[1−​2⋅δ​2​​​​(Δx​2​​+Δy​2​​)​​]⋅e​−​2⋅δ​2​​​​(Δx​2​​+Δy​2​​)​​​​)​xy​​∣​1​​​​ 显然，LoGp(xc⃗){LoG}_p(\\vec{x_c})LoG​p​​(​x​c​​​⃗​​) 也满足高斯滤波的特性，在 δ\\deltaδ 确定的情况下具有固定大小的算子。如果选用的高斯核大小为 3×33 \\times 33×3 ，则考虑到最大程度生效的感受野大小，算法的卷积核必须得保证有至少 n×n≥3×3n \\times n \\geq 3 \\times 3n×n≥3×3 的取值。但也不能太大。如果超过核心高斯算子大小的 555 倍，即 n×n≥15×15n \\times n \\geq 15 \\times 15n×n≥15×15 时，会非常容易产生采样元素的过度富集，导致边缘取值偏移和过曝问题。 因此，一般而言 LoGn(xc⃗){LoG}_n(\\vec{x_c})LoG​n​​(​x​c​​​⃗​​) 算子的大小会取奇数范围 n×n∈[5×5, 11×11]∣oddn \\times n \\in [5 \\times 5, \\ 11 \\times 11]|_{odd}n×n∈[5×5, 11×11]∣​odd​​ , 记为 MLoGM_{LoG}M​LoG​​ 。 为了便于说明，我们采用 n×n=9×9n \\times n = 9 \\times 9n×n=9×9 的核大小做计算。当 δ=1.4\\delta = 1.4δ=1.4 且 K=1.0K = 1.0K=1.0 时，未归一化的 MLoGM_{LoG}M​LoG​​ 可算得为： MLoG∣δ=1.4K=1.0=[0,  1,  1,  2,  2,  2,  1,  1,  01,  2,  4,  5,  5,  5,  4,  2,  11,  4,  5,  3,  0,  3,  5,  4,  12,  5,  3,−12,−24,−12,  3,  5,  22,  5,  0,−24,−40,−24,  0,  5,  22,  5,  3,−12,−24,−12,  3,  5,  21,  4,  5,  3,  0,  3,  5,  4,  11,  2,  4,  5,  5,  5,  4,  2,  10,  1,  1,  2,  2,  2,  1,  1,  0]9×9 {\\displaystyle \\begin{aligned} M_{LoG}|_{\\delta=1.4}^{K=1.0} =& { \\begin{bmatrix} 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\\\ 1 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 1 \\\\ 2 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 3 ,& \\quad -12 ,& \\quad -24 ,& \\quad -12 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 2 \\\\ 2 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 0 ,& \\quad -24 ,& \\quad -40 ,& \\quad -24 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 2 \\\\ 2 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 3 ,& \\quad -12 ,& \\quad -24 ,& \\quad -12 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 2 \\\\ 1 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ 3 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 1 \\\\ 1 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 5 ,& \\quad \\ \\ 4 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 1 \\\\ 0 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 2 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 1 ,& \\quad \\ \\ 0 \\end{bmatrix} } _{9 \\times 9} \\\\ \\end{aligned} } ​M​LoG​​∣​δ=1.4​K=1.0​​=​​​​​⎣​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎢​⎡​​​0,​1,​1,​2,​2,​2,​1,​1,​0,​​​  1,​  2,​  4,​  5,​  5,​  5,​  4,​  2,​  1,​​​  1,​  4,​  5,​  3,​  0,​  3,​  5,​  4,​  1,​​​  2,​  5,​  3,​−12,​−24,​−12,​  3,​  5,​  2,​​​  2,​  5,​  0,​−24,​−40,​−24,​  0,​  5,​  2,​​​  2,​  5,​  3,​−12,​−24,​−12,​  3,​  5,​  2,​​​  1,​  4,​  5,​  3,​  0,​  3,​  5,​  4,​  1,​​​  1,​  2,​  4,​  5,​  5,​  5,​  4,​  2,​  1,​​​  0​  1​  1​  2​  2​  2​  1​  1​  0​​​⎦​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎥​⎤​​​9×9​​​​ 此时，有 LoGn(xc⃗)∣δ=1.4K=1.0{LoG}_n(\\vec{x_c})|_{\\delta=1.4}^{K=1.0}LoG​n​​(​x​c​​​⃗​​)∣​δ=1.4​K=1.0​​ 可表示如下： LoGn(xc⃗)∣δ=1.4=∑xySxy⋅∣(MLoG∣δ=1.4K=1.0)∣1∈R9×9 {\\displaystyle \\begin{aligned} {LoG}_n(\\vec{x_c})|_{\\delta=1.4} =& \\sum_{xy}S_{xy} \\cdot \\vert (M_{LoG}|_{\\delta=1.4}^{K=1.0}) \\vert_1 \\in \\mathbb{R}^{9 \\times 9} \\\\ \\end{aligned} } ​LoG​n​​(​x​c​​​⃗​​)∣​δ=1.4​​=​​​​​xy​∑​​S​xy​​⋅∣(M​LoG​​∣​δ=1.4​K=1.0​​)∣​1​​∈R​9×9​​​​ 除了采样不占优势外，马尔滤波核本身在确定 δ\\deltaδ 取值后并不复杂。考虑到最小采样成本，我们一般取用 5×55 \\times 55×5 大小的卷积核。且不建议对马尔滤波核使用线性采样简化运算，否则会扩大误差。 马尔滤波的 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 程序化马尔滤波的关键处理部分，依旧在 像素程序片（Pixel Shader/Fragment Shader）上和 CPU 的马尔算子的计算上 。我们先看像素程序片（Pixel Shader/Fragment Shader）是怎么实现的： precision mediump float; const int n = 5; varying vec4 fs_position; varying vec2 fs_texcoord; uniform vec2 pixel_bias; uniform float marr_matrix[n * n]; uniform sampler2D target_texture; void main() { vec3 output_; for (int i = 0; i 完全就是高斯的像素程序片。或者说，对于以矩阵形式传入的固定算子，在程序片的实现上都是可以复用的。因此，如果遇到类似场景，此类程序片也可以考虑合并或者同态转换。 而传入的 马尔算子 marr_matrix 和 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_marr_kernel(step, delta) { let n = step * 2 + 1; let kernel = new Float32Array(n * n); let factor_1 = 1.0 / (Math.PI * Math.pow(delta, 4)); // trick: normalized skip let factor_2 = 1.0 / (2.0 * delta * delta); let normalize_div = 0; for (let i = 0; i 至此，简易马尔滤波器程序片就完成了。 马尔滤波的局限性 马尔滤波最大问题就在于采样数上。但如果不考虑采样的消耗，其本身也并非毫无缺点。 虽然马尔滤波因 具有对信号数据所携带高频干扰（即高频噪声）的一定抗性 ，使得算法结果相较于拉普拉斯滤波而言，有较大的改善。但却不能避免非各向异性（Not Anisotropic）引入并增强摩尔纹的缺点。 且马尔滤波更容易受没有针对中心高权重进行处理，而采用大卷积核进一步 增加了中心占比 的影响，出现 边缘扩散 和 非连续 的问题。 不过在取 δ1.0\\delta δ1.0 时，利用高斯算法对波动性的削弱，马尔滤波能够在抑制噪音的同时，进行有限程度并考虑相邻波动特征的边缘增强。这让马尔滤波配合原始数据下，能够达到更自然的滤波效果。所以，我们一般不采用马尔滤波检测边缘，而是使用其处理广义锐化场景 。 马尔滤波的广义锐化应用 马尔滤波在广义锐化下的核函数是怎样的呢？参考拉普拉斯滤波，我们只需要替换掉权重部分即可： Ln(xc⃗)=S(xc⃗)+LoGn(xc⃗)=S(xc⃗)−K⋅∇2Fn(xc⃗) {\\displaystyle \\begin{aligned} \\mathcal{L}_n(\\vec{x_c}) =& S(\\vec{x_c}) + {LoG}_n(\\vec{x_c}) \\\\ =& S(\\vec{x_c}) -K \\cdot \\nabla^2 F_n(\\vec{x_c}) \\\\ \\end{aligned} } ​L​n​​(​x​c​​​⃗​​)=​=​​​​S(​x​c​​​⃗​​)+LoG​n​​(​x​c​​​⃗​​)​S(​x​c​​​⃗​​)−K⋅∇​2​​F​n​​(​x​c​​​⃗​​)​​ 这里已经有一些复合函数的感觉了。如果我们将数据源 S(xc⃗)S(\\vec{x_c})S(​x​c​​​⃗​​) 更换为高斯滤波结果，为区别于 Fn(xc⃗)F_n(\\vec{x_c})F​n​​(​x​c​​​⃗​​) ，这里我们记为 Gn(xc⃗)G_n(\\vec{x_c})G​n​​(​x​c​​​⃗​​) 。则整个处理函数就成为了，在高斯模糊的基础上再行锐化，达到模糊着色面，增强轮廓边缘的效果。此时的核函数为： Ln(xc⃗)=Gn(xc⃗)−K⋅∇2Fn(xc⃗) {\\displaystyle \\begin{aligned} \\mathcal{L}_n(\\vec{x_c}) =& G_n(\\vec{x_c}) -K \\cdot \\nabla^2 F_n(\\vec{x_c}) \\\\ \\end{aligned} } ​L​n​​(​x​c​​​⃗​​)=​​​​G​n​​(​x​c​​​⃗​​)−K⋅∇​2​​F​n​​(​x​c​​​⃗​​)​​ 以此类推，我们也可以将数据源 S(xc⃗)S(\\vec{x_c})S(​x​c​​​⃗​​) 换成其他滤波的结果，将马尔滤波（进一步衍生到所有可行的滤波函数）作为后级处理，构建连续的滤波处理流水线 。这种思想，即是 滤波链路（Filter Chain） 技术的概念起源。 所以，应用于锐化的马尔滤波链路，也被称为 马尔锐化（Marr Sharpening） ，或简称为 朴素锐化（Simple Sharpening） 算法。 马尔锐化的 GLSL 渲染程序片 根据上文的分析，马尔锐化包含两部分：前级数据 和 后级数据。前级数据用于内容主体，后级数据用于叠加锐化。这里我们取用可配置是否采用高斯模糊，作为可选前级数据的程序片方案，对已实现的马尔滤波进行改造。 由于顶点程序片仍然可以被沿用，此处我们单独来看 像素程序片（Pixel Shader/Fragment Shader） 该怎么定义： precision mediump float; const int n = 3; const int m = 5; varying vec4 fs_position; varying vec2 fs_texcoord; uniform bool only_edge; uniform bool marr_blur; uniform vec2 pixel_bias; uniform float gaussian_matrix[n * n]; uniform float marr_matrix[m * m]; uniform float str_factor; uniform sampler2D target_texture; vec3 gauss_operation() { vec3 output_; for (int i = 0; i 显然，作为前级输入的高斯滤波，其滤波核大小并不一定需要和后级处理核大小保持一致。我们依旧采用 强度参数 str_factor ，对锐化介入的强度进行了直接调控。而传入的 高斯算子 gaussian_matrix 、 马尔算子 marr_matrix 和 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_gaussian_kernel(step, delta) { let n = step * 2 + 1; let kernel = new Float32Array(n * n); let factor_1 = 1.0 / (Math.sqrt(2.0 * Math.PI) * delta); let factor_2 = 1.0 / (2.0 * delta * delta); let normalize_div = 0; for (let i = 0; i 至此，马尔锐化基本完成。 看来更稳定的边缘检测，还是需要依赖去中心化的索贝尔滤波了。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_2_5.html":{"url":"Chapter_3/Language/cn/Docs_3_2_5.html","title":"3.2.5 索贝尔滤波（Sobel Filter）","keywords":"","body":"3.2.5 索贝尔滤波（Sobel Filter） 索贝尔滤波（Sobel Filter） 是由 斯坦福人工智能实验室（SAIL [Stanford Artificial Intelligence Laboratory]） 的 艾尔文·索贝尔（Irwin Sobel，1940 - present） 和 格雷·费尔德曼（Gary Feldman，1942 - present） 于 1968 年提出的一种用于 边缘检测（Edge Detection） 的 去中心化（Center Insensitive）一阶离散微分算子 [15] 。 通过在构建 3×33 \\times 33×3 卷积核中，对横纵两个方向距离中心点不同偏移的相邻点，采用不同的方位权重占比的方式，针对性的计算边缘变化影响。其实，是将平面点漂移的方向向量，拆解为以卷积核中心点构建的 xyxyxy 坐标系下的方向分量。通过抽象方向分量的 一维简易高斯分布（1D Simple Gaussian Distribution） 密度函数到方差同位表示，来记录中心点的运动情况。而核内不同取值，则代表垂直于该取值方向的分量高斯分布函数切片，占当前相位的百分比（ 归一化后 ）。 因此，仍然取用大小 n×n=3×3n \\times n = 3 \\times 3n×n=3×3 ，中心点 xc⃗\\vec{x_c}​x​c​​​⃗​​ 的卷积核。记原信号为 S(x)S(x)S(x) ，边缘检测索贝尔滤波核函数为 Sp(xc⃗)\\mathcal{S}_p(\\vec{x_c})S​p​​(​x​c​​​⃗​​) ，则： Sp(xc⃗)=K⋅Gx2+Gy2 {\\displaystyle \\begin{aligned} \\mathcal{S}_p(\\vec{x_c}) =& K \\cdot \\sqrt{ {G_x}^{2} + {G_y}^{2} } \\\\ \\end{aligned} } ​S​p​​(​x​c​​​⃗​​)=​​​​K⋅√​G​x​​​2​​+G​y​​​2​​​​​​​ 横向 xxx 轴方向的滤波核函数 GxG_xG​x​​ 为： Gx(xc⃗)=Kx⋅[+1,  0,  −1+2,  0,  −2+1,  0,  −1]⋅∑xyxc⃗Sxy∈R3×3 {\\displaystyle \\begin{aligned} G_x(\\vec{x_c}) =& K_x \\cdot { \\begin{bmatrix} +1 ,& \\ \\ 0 ,& \\ \\ -1 \\\\ +2 ,& \\ \\ 0 ,& \\ \\ -2 \\\\ +1 ,& \\ \\ 0 ,& \\ \\ -1 \\end{bmatrix} } \\cdot \\sum_{xy}^{\\vec{x_c}}S_{xy} \\in \\mathbb{R}^{3 \\times 3} \\\\ \\end{aligned} } ​G​x​​(​x​c​​​⃗​​)=​​​​K​x​​⋅​⎣​⎡​​​+1,​+2,​+1,​​​  0,​  0,​  0,​​​  −1​  −2​  −1​​​⎦​⎤​​⋅​xy​∑​​x​c​​​⃗​​​​S​xy​​∈R​3×3​​​​ 横向 yyy 轴方向的滤波核函数 GyG_yG​y​​ 为： Gy(xc⃗)=Ky⋅[+1, +2, +10,  0,0−1, −2, −1]⋅∑xyxc⃗Sxy∈R3×3 {\\displaystyle \\begin{aligned} G_y(\\vec{x_c}) =& K_y \\cdot { \\begin{bmatrix} +1 ,& \\ +2 ,& \\ +1 \\\\ 0 ,& \\ \\ 0 ,& \\quad 0 \\\\ -1 ,& \\ -2 ,& \\ -1 \\end{bmatrix} } \\cdot \\sum_{xy}^{\\vec{x_c}}S_{xy} \\in \\mathbb{R}^{3 \\times 3} \\\\ \\end{aligned} } ​G​y​​(​x​c​​​⃗​​)=​​​​K​y​​⋅​⎣​⎡​​​+1,​0,​−1,​​​ +2,​  0,​ −2,​​​ +1​0​ −1​​​⎦​⎤​​⋅​xy​∑​​x​c​​​⃗​​​​S​xy​​∈R​3×3​​​​ 从上式可知，强度系数 KKK 可以拆分到 xyxyxy 各自方向的子核中，记为 K⃗=(Kx,Ky)\\vec{K} = (K_x,K_y)​K​⃗​​=(K​x​​,K​y​​) 。则，当 K⃗=(0, 1)\\vec{K} = (0,\\ 1)​K​⃗​​=(0, 1) 时 Sp(xc⃗)=K⋅Gy(xc⃗)\\mathcal{S}_p(\\vec{x_c}) = K \\cdot G_y(\\vec{x_c})S​p​​(​x​c​​​⃗​​)=K⋅G​y​​(​x​c​​​⃗​​) 只保留纵向滤波结果，当 K⃗=(1, 0)\\vec{K} = (1,\\ 0)​K​⃗​​=(1, 0) 时 Sp(xc⃗)=K⋅Gx(xc⃗)\\mathcal{S}_p(\\vec{x_c}) = K \\cdot G_x(\\vec{x_c})S​p​​(​x​c​​​⃗​​)=K⋅G​x​​(​x​c​​​⃗​​) 只保留横向滤波结果。不过，一般情况下我们不会只进行单边检测，因此方便起见还是采用在整体滤波结果上进行强度控制，即使用 K∈RK \\in \\mathbb{R}K∈R 来调整。 显然，索贝尔滤波是同时具有 梯度方向（Orientate） 和 强度（Magnitude） 的。记方向为 Θ\\ThetaΘ ，强度为 AAA 。则有： A=∣Sp(xc⃗)∣=K⋅Gx2+Gy2Θ=∠Sp(xc⃗) =atan2(Gy, Gx) {\\displaystyle \\begin{aligned} A =& \\vert {\\mathcal{S}_p(\\vec{x_c})} \\vert = K \\cdot \\sqrt{ {G_x}^{2} + {G_y}^{2} } \\\\ \\Theta =& \\angle \\mathcal{S}_p(\\vec{x_c})\\ = {atan2}(G_y,\\ G_x)\\\\ \\end{aligned} } ​A=​Θ=​​​​∣S​p​​(​x​c​​​⃗​​)∣=K⋅√​G​x​​​2​​+G​y​​​2​​​​​​∠S​p​​(​x​c​​​⃗​​) =atan2(G​y​​, G​x​​)​​ 此时，有 LoGn(xc⃗)∣δ=1.4K=1.0{LoG}_n(\\vec{x_c})|_{\\delta=1.4}^{K=1.0}LoG​n​​(​x​c​​​⃗​​)∣​δ=1.4​K=1.0​​ 可表示如下： LoGn(xc⃗)∣δ=1.4=∑xySxy⋅∣(MLoG∣δ=1.4K=1.0)∣1∈R9×9 {\\displaystyle \\begin{aligned} {LoG}_n(\\vec{x_c})|_{\\delta=1.4} =& \\sum_{xy}S_{xy} \\cdot \\vert (M_{LoG}|_{\\delta=1.4}^{K=1.0}) \\vert_1 \\in \\mathbb{R}^{9 \\times 9} \\\\ \\end{aligned} } ​LoG​n​​(​x​c​​​⃗​​)∣​δ=1.4​​=​​​​​xy​∑​​S​xy​​⋅∣(M​LoG​​∣​δ=1.4​K=1.0​​)∣​1​​∈R​9×9​​​​ 因此，用索贝尔滤波也可以得到图像中心像素的 运动漂移信息 ，可用于 方向梯度直方图（HOG [Histogram of Oriented Gradient]） 中获取像素点梯度矢量的计算方法。此部分我们在随后的章节中进行。 那么，基于索贝尔滤波的边界检测该怎样实现呢？ 索贝尔滤波的 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 程序化索贝尔滤波的关键处理部分，依旧在 像素程序片（Pixel Shader/Fragment Shader）上和 CPU 的索贝尔算子的计算上 。我们先看像素程序片（Pixel Shader/Fragment Shader）是怎么实现的： precision mediump float; varying vec4 fs_position; varying vec2 fs_texcoord; uniform bool only_edge; uniform vec2 pixel_bias; uniform mat3 sobel_matrix_x; uniform mat3 sobel_matrix_y; uniform sampler2D target_texture; void main() { vec3 output_ = only_edge? vec3(0) : texture2D(target_texture, fs_texcoord.xy).rgb; vec3 color_center_x; vec3 color_center_y; for (int i = 0; i 我们依旧采用 强度参数 str_factor ，对锐化介入的强度进行直接调控。而传入的 索贝尔算子分为两个方向记为 sobel_matrix_x 和 sobel_matrix_y 。同 相邻像素归一化的偏移距离 pixel_bias 的操作，只需要在执行前由 CPU 计算一次即可。以 JavaScript 语法实现： function pixel_bias(width, height) { return new Float32Array([ 1.0 / width, 1.0 / height ]); } function calculate_sobel_kernel(use_horizontal, str_factor) { let kernel = new Float32Array(use_horizontal ? [ +1.0, 0.0, -1.0, +2.0, 0.0, -2.0, +1.0, 0.0, -1.0 ] : [ +1.0, +2.0, +1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 ]) for (let i = 0; i 至此，简易索贝尔滤波器程序片就完成了。 索贝尔滤波的局限性 虽然索贝尔滤波通过去中心化检测目标像素点周边的运动情况，检测结果也 相对准确 ，并摆脱了 由卷积核中心权值造成像素富集而导致对干扰抗性较弱的问题 。但也正因此 进一步扩大了边缘扩散（Edge Spread）的风险 。且当物体轮廓处的灰度（光亮度）变化过于发散时，算法会有一定程度的丢失，即 对抗弱边缘（Weak Edge）的能力较差。 不过，这些缺点在只需要边缘位置的情况下，可以通过 阈值限定二值化（Thresholding） 来得到一定程度的改善（ 这种做法经常出现在机器学习的数据前处理过程中 ）。由于一般音视频工程并不会需要如此精度，考虑到索贝尔滤波的快捷、简单、高效和高干扰抗性的特点，算法本身常被用于各种场景下的 边缘数据提取 和 像素信息预测 过程。但本身不适合(也不应该)作为噪音抑制算法使用。 经过几个滤波算法的辨析，我们发现想要真正的有效抑制噪音，达到自然模糊且边缘保存的目的，单纯以多 非各向异性 滤波器组合的形式，还是很难得到同 各向异性 滤波算法相同的效果。 当然，不同的算法各有自身的优势，并非是独一的非此即彼的对立关系。作为工程师，在不同需求下，还是要灵活取用和组合达成所求。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_2_6.html":{"url":"Chapter_3/Language/cn/Docs_3_2_6.html","title":"3.2.6 各向异性扩散（Anisotropic Diffusion）","keywords":"","body":"3.2.6 各向异性扩散（Anisotropic Diffusion） 【待补充】 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_3.html":{"url":"Chapter_3/Language/cn/Docs_3_3.html","title":"3.3 时间冗余控制 - 常用特征提取与朴素阈值处理","keywords":"","body":"3.3 时间冗余控制 - 常用特征提取与朴素阈值处理 在本节之前，本书已经讲解了如何分离的处理 一维动态音频 和 二维静态图片 信号。如果我们 将一系列图片以时间轴串联，就得到一组由二维静态信号按序构成的二维动态信号 。这种类型的信号，被称为 视频流（Visual Stream） 。 相较于一维信号，静态二维信号本就具有 信息密度高 的特征。而动态化则会进一步 加剧 其对 算力资源 的消耗。不经合适的方法控制数据，将会产生大量的 冗余信息 。 严重不利于数据的保存、传输和处理。 考虑到被采样的运动物体，其前后总是存在时序关联性的客观事实。视频流作为观察物体得到的数据载体 ，相邻的两个时间节点采样图片，像素值上必然也可以抽象出相应运动特征的 位移向量投影 ，得到 关联前后数据的变化关系 。借此，工程上就可以利用像素的漂移情况，来筛选出未发生改变的数据，从而复用前值以求降低不必要计算和更新，减少消耗。 为此，需要对 运动区域进行检测，并提取运动矢量信息 。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_3_1.html":{"url":"Chapter_3/Language/cn/Docs_3_3_1.html","title":"3.3.1 方向梯度直方图（HOG [Histogram of Oriented Gradient]）","keywords":"","body":"3.3.1 方向梯度直方图（HOG [Histogram of Oriented Gradient]） 在前文中，我们提到了索贝尔滤波（Sobel Filter）卷积核对中心点周边方向信息的提炼，可以被用来获取方向梯度直方图的梯度矢量计算中。那么什么是方向梯度直方图呢？ 方向梯度直方图最早的 概念原型（Prototype） 来自于 罗伯特·麦康纳尔（Robert K. McConnell） 在 1986 年申请的有关模式识别专利中，对 视野（FoV [Field of View]） 方向性输入产生输出结果差异的判断过程。并于 1994 年 三菱电子研究实验室（Mitsubishi Electric Research Laboratories） 在手势识别应用的区域检测过程中，首次总结为当前称谓 [16] 。最终经过 2005 年 CVPR 顶会参会论文验证，重新确认了 HOG 在动态检测上的高适配度，才开始被人熟知 [17] 。 方向梯度直方图（HOG [Histogram of Oriented Gradient]） 是对用于提炼并描述区域范围内像素漂移情况方法论的概念抽象。是对过程的抽象，而非对结果的抽象。由于本身最终运算能够表示为处理单元形式，因而属于 特征描述算子（Feature Descriptor） 的一种。整体思想则是在单元间隔均匀的卷积核内，使用重叠的局部梯度提炼算法并 录表统计归一化（Normalization） ，以取得中心点变化方向矢量。方法常结合 阈值限定（Thresholding） 筛选结果，提高运动预测的准确度。 显然，方向梯度直方图并不只适用于索贝尔， 只要能够提供中心点周边梯度变化的大小和方向的算子，都可以被应用于 HOG 的求解中 。一个方向梯度直方图是否优秀，最大的影响点就在于梯度提炼的是否精准。 HOG 的标准处理流 HOG 有一套相对固定的标准过程的。基本可以按照如下顺序进行： 数据优化，通过滤波算法（如高斯滤波），减少干扰信息并增强灰度（光亮度）对比； 梯度计算，通过梯度滤波器（如索贝尔滤波）提取图像每个像素的梯度矢量； 分组抽象，指定梯度矢量采样卷积核范围，即分组（Cell） 矢量合并，将分组内所有像素的梯度矢量，以方向投票统计合并权重，获取 HOG 块归一化，指定块大小（由分组为单位），整合 HOG 统计结果并归一化快内分组权重 五个步骤，共同构成了方向梯度直方图方法论本身。 且四五两步概念不同，但密不可分。 数据优化 数据优化的目的是为了增强光亮度变化差异，并减少干扰噪声，从而更好的保存并放大像素梯度变化情况。我们记原信号为 S(x)S(x)S(x) ，记经过滤波降噪和修饰后的灰度（光亮度）数据为 Sg(x)S_g(x)S​g​​(x) 。从 S(x)S(x)S(x) 到 Sg(x)S_g(x)S​g​​(x) 的处理过程就不再赘述（见滤波，类比处理）。记经过优化函数 Og(x)O_g(x)O​g​​(x) 处理，以 Sg(x)S_g(x)S​g​​(x) 获取的优化结果为 So(x)S_o(x)S​o​​(x) 。那么，相对简单的处理方式，就是直接对 Sg(x)S_g(x)S​g​​(x) 进行 伽马矫正（Gamma Correction）来得到 So(x)S_o(x)S​o​​(x) 。取伽马因子为 γ\\gammaγ ，矫正系数（Adjust Factor）为 AAA （一般情况 A=1.0A = 1.0A=1.0 为常量），有： Og(x)=Gamma(S)=A⋅S(x)γ {\\displaystyle \\begin{aligned} O_g(x) =& Gamma(S) = A \\cdot S(x)^{\\gamma} \\\\ \\end{aligned} } ​O​g​​(x)=​​​​Gamma(S)=A⋅S(x)​γ​​​​ 伽马矫正（Gamma Correction） 本是用于应对，早期 阴极射线管（CRT [Cathode Ray Tube]）显示器 的电子偏转特征，引入的采样源数据非线性转换算法。传统的 CRT 显示器在显示时就会完成对偏转数据的自然逆向过程，而在 液晶显示器（LCD [Liquid Crystal Display]） 上，则需要 主动的实现这一反向运算 ，否则会面临数据亮度过爆的问题。 由于采样时采用 γ1\\gamma γ1 应用于数据修正, 所以 γ1\\gamma γ1 时的 γ\\gammaγ 值被称为 编码伽马值（Encoding Gamma） 。相应的，γ>1\\gamma > 1γ>1 时的 γ\\gammaγ 值被称为 解码伽马值（Decoding Gamma） 。而采样到还原的过程中，对伽马矫正的不同运用被分别称为 伽马编码（Gamma Encode） 和 伽马解码（Gamma Decode） 。 图 3.3.1-1 原数据经过伽马编解码（伽马矫正）的还原过程示意图 伽马矫正本身的作用正是针对原图色彩通道数据，进行非线性的映射。衍生为对图片整体光亮度的调节，因此在灰度值上的体现最为明显。我们利用这种特性，来增强图片的对比信息，放大像素梯度变化。 这一步，通常取用 γ∈[0.45, 1.25]\\gamma \\in [0.45,\\ 1.25]γ∈[0.45, 1.25] 区间内的值，或 γ=0.5\\gamma = 0.5γ=0.5 的原论文推荐值来进行修正。得到用于后续处理的灰度数据源 So(x)S_o(x)S​o​​(x) 。 梯度计算 在经过优化得到高对比度的 灰度（光亮度）图 后，就可以利用一些方向梯度卷积核算法，来计算每一个像素点光亮度变换的梯度矢量了。 此时应用边缘检测索贝尔滤波，目的同 HOG 的默认设定中，采用横纵方向均取 单一中线 的简化 普雷维特算子（Prewitt Operator） ，以求取梯度 方向（Orientate） 和 强度（Magnitude） 的作用一致。显然，并不只有索贝尔算法或普雷维特算法，适用于方向梯度直方图中梯度矢量的计算。只要能够提供中心点周边梯度变化的大小和方向的算子，都可以被应用于 HOG 的此步的求解计算中。 我们记方向为 Θ\\ThetaΘ ，强度为 AAA ，横向 xxx 轴方向的滤波核函数 GxG_xG​x​​ ，纵向 yyy 轴方向的滤波核函数 GyG_yG​y​​ 。强度系数 KKK 为同态值 K=Kx=KyK= K_x = K_yK=K​x​​=K​y​​$ 。此处不含推导展示结论。 记 边缘检测普雷维特滤波核函数 为 Pp(xc⃗)\\mathcal{P}_p(\\vec{x_c})P​p​​(​x​c​​​⃗​​) ，有： Gx=Kx⋅[+1,0,−1] ⋅So(xc⃗)3×1Gy=Ky⋅[+1,0,−1]T⋅So(xc⃗)1×3A=∣Pp(xc⃗)∣=K⋅Gx2+Gy2Θ=∠Pp(xc⃗) =atan2(Gy, Gx) {\\displaystyle \\begin{aligned} G_x =& K_x \\cdot { \\begin{bmatrix} +1 ,& \\quad 0 ,& \\quad -1 \\end{bmatrix} } \\ \\cdot S_o(\\vec{x_c})^{3 \\times 1} \\\\ G_y =& K_y \\cdot { \\begin{bmatrix} +1 ,& \\quad 0 ,& \\quad -1 \\end{bmatrix} ^{T} } \\cdot S_o(\\vec{x_c})^{1 \\times 3} \\\\ A =& \\vert {\\mathcal{P}_p(\\vec{x_c})} \\vert = K \\cdot \\sqrt{ {G_x}^{2} + {G_y}^{2} } \\\\ \\Theta =& \\angle \\mathcal{P}_p(\\vec{x_c})\\ = {atan2}(G_y,\\ G_x)\\\\ \\end{aligned} } ​G​x​​=​G​y​​=​A=​Θ=​​​​K​x​​⋅[​+1,​​​0,​​​−1​​] ⋅S​o​​(​x​c​​​⃗​​)​3×1​​​K​y​​⋅[​+1,​​​0,​​​−1​​]​T​​⋅S​o​​(​x​c​​​⃗​​)​1×3​​​∣P​p​​(​x​c​​​⃗​​)∣=K⋅√​G​x​​​2​​+G​y​​​2​​​​​​∠P​p​​(​x​c​​​⃗​​) =atan2(G​y​​, G​x​​)​​ 记 边缘检测索贝尔滤波核函数 为 Sp(xc⃗)\\mathcal{S}_p(\\vec{x_c})S​p​​(​x​c​​​⃗​​) ，有： Gx=Kx⋅[+1,  0,  −1+2,  0,  −2+1,  0,  −1]⋅So(xc⃗)3×3Gy=Ky⋅[+1, +2, +10,  0,0−1, −2, −1]⋅So(xc⃗)3×3A=∣Sp(xc⃗)∣=K⋅Gx2+Gy2Θ=∠Sp(xc⃗) =atan2(Gy, Gx) {\\displaystyle \\begin{aligned} G_x =& K_x \\cdot { \\begin{bmatrix} +1 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ -1 \\\\ +2 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ -2 \\\\ +1 ,& \\quad \\ \\ 0 ,& \\quad \\ \\ -1 \\end{bmatrix} } \\cdot S_o(\\vec{x_c})^{3 \\times 3} \\\\ G_y =& K_y \\cdot { \\begin{bmatrix} +1 ,& \\quad \\ +2 ,& \\quad \\ +1 \\\\ 0 ,& \\quad \\ \\ 0 ,& \\quad \\quad 0 \\\\ -1 ,& \\quad \\ -2 ,& \\quad \\ -1 \\end{bmatrix} } \\cdot S_o(\\vec{x_c})^{3 \\times 3} \\\\ A =& \\vert {\\mathcal{S}_p(\\vec{x_c})} \\vert = K \\cdot \\sqrt{ {G_x}^{2} + {G_y}^{2} } \\\\ \\Theta =& \\angle \\mathcal{S}_p(\\vec{x_c})\\ = {atan2}(G_y,\\ G_x)\\\\ \\end{aligned} } ​G​x​​=​G​y​​=​A=​Θ=​​​​K​x​​⋅​⎣​⎡​​​+1,​+2,​+1,​​​  0,​  0,​  0,​​​  −1​  −2​  −1​​​⎦​⎤​​⋅S​o​​(​x​c​​​⃗​​)​3×3​​​K​y​​⋅​⎣​⎡​​​+1,​0,​−1,​​​ +2,​  0,​ −2,​​​ +1​0​ −1​​​⎦​⎤​​⋅S​o​​(​x​c​​​⃗​​)​3×3​​​∣S​p​​(​x​c​​​⃗​​)∣=K⋅√​G​x​​​2​​+G​y​​​2​​​​​​∠S​p​​(​x​c​​​⃗​​) =atan2(G​y​​, G​x​​)​​ 更明确的，当我们采用不同算法进行梯度计算时，梯度提炼的结果，将会在较大程度上影响最终得到的方向梯度直方图。是需要更准确、更快捷，还是需要高抗性、低波动，应以实际工程角度考量。根据具体需要来采用不同的边缘检测算法。 而梯度方向和强度的计算则可统一为共识： A=K⋅Gx2+Gy2Θ=∠ [tan−1(GyGx)] {\\displaystyle \\begin{aligned} A =& K \\cdot \\sqrt{ {G_x}^{2} + {G_y}^{2} } \\\\ \\Theta =& \\angle \\ [{tan^{-1}}(\\tfrac{G_y}{G_x})] \\\\ \\end{aligned} } ​A=​Θ=​​​​K⋅√​G​x​​​2​​+G​y​​​2​​​​​​∠ [tan​−1​​(​G​x​​​​G​y​​​​)]​​ 称为 通用卷积核梯度矢量公式（Formula of Kernel Gradient Vector） 。 经过此步计算后，灰度数据源 So(x)S_o(x)S​o​​(x) 的输入就被转换为原信号为 S(x)S(x)S(x) 的所有像素点，梯度方向数据集 Θ(x)\\Theta(x)Θ(x) 和 梯度强度数据集 A(x)A(x)A(x) 。不过此时的数据量相对较大，不便于计算处理，还需 简化信息量 。 分组抽象 & 矢量合并 分组抽象的目的是为了提炼每个像素点的数据，汇总分组内逐个像素特征到分组整体的单元特征。 由于原有梯度方向的平面完整性，以 Θ\\ThetaΘ 范围即便只限定为整数角，也包含 [0∘, 360∘)[0^{\\circ},\\ 360^{\\circ})[0​∘​​, 360​∘​​) 共 360360360 个取值。 这样造成的数据膨胀，不利于有限算力的处理。 因此，以尽可能不损失方向包含实际意义为前提， 将角度按照权重分割 来表示原梯度包含信息，是个不错的办法。 假设我们将 [0∘, 360∘)[0^{\\circ},\\ 360^{\\circ})[0​∘​​, 360​∘​​) 按照 ∠Θ=[Θ0 , ... , Θθ−1]\\angle \\Theta = [\\Theta_0\\ ,\\ ...\\ ,\\ \\Theta_{\\theta-1}]∠Θ=[Θ​0​​ , ... , Θ​θ−1​​] 的边界角度，拆分为 θ\\thetaθ 个指定方向。记存在像素点 xc⃗\\vec{x_c}​x​c​​​⃗​​ 的梯度 G⃗(xc⃗)=(Ac, Θc)\\vec{G}(\\vec{x_c}) = (A_c,\\ \\Theta_c)​G​⃗​​(​x​c​​​⃗​​)=(A​c​​, Θ​c​​) 的方向落于角度区间 [Θa, Θb)[\\Theta_a,\\ \\Theta_b)[Θ​a​​, Θ​b​​) 内，有： Ac=Wa⋅Aa+Wb⋅AbΘc=Wa⋅Θa+Wb⋅ΘbWa=Θc−ΘaΘb−ΘaWb=Θb−ΘcΘb−Θa {\\displaystyle \\begin{aligned} A_c = W_a & \\cdot A_a + W_b \\cdot A_b \\\\ \\Theta_c = W_a & \\cdot \\Theta_a + W_b \\cdot \\Theta_b \\\\ W_a = \\frac{\\Theta_c - \\Theta_a}{\\Theta_b - \\Theta_a} & \\quad \\quad W_b = \\frac{\\Theta_b - \\Theta_c}{\\Theta_b - \\Theta_a} \\\\ \\end{aligned} } ​A​c​​=W​a​​​Θ​c​​=W​a​​​W​a​​=​Θ​b​​−Θ​a​​​​Θ​c​​−Θ​a​​​​​​​​⋅A​a​​+W​b​​⋅A​b​​​⋅Θ​a​​+W​b​​⋅Θ​b​​​W​b​​=​Θ​b​​−Θ​a​​​​Θ​b​​−Θ​c​​​​​​ 其中 Wa+Wb=1W_a + W_b = 1W​a​​+W​b​​=1 ，按照权重 WaW_aW​a​​ 、 WbW_bW​b​​ 即可拆分 G⃗(xc⃗)\\vec{G}(\\vec{x_c})​G​⃗​​(​x​c​​​⃗​​) 数据到 Θa\\Theta_aΘ​a​​ 、 Θb\\Theta_bΘ​b​​ 角度分量混合表示。记两个角度方向的分量分别为 Ga⃗\\vec{G_a}​G​a​​​⃗​​ 、 Gb⃗\\vec{G_b}​G​b​​​⃗​​ ，则： Ga⃗=(Wa⋅Ac, Wa⋅Θc)Gb⃗=(Wb⋅Ac, Wa⋅Θc)G⃗(xc⃗)=Ga⃗+Gb⃗ {\\displaystyle \\begin{aligned} \\vec{G_a} =& (W_a \\cdot A_c ,\\ W_a \\cdot \\Theta_c) \\\\ \\vec{G_b} =& (W_b \\cdot A_c ,\\ W_a \\cdot \\Theta_c) \\\\ \\vec{G}(\\vec{x_c}) &= \\vec{G_a} + \\vec{G_b} \\\\ \\end{aligned} } ​​G​a​​​⃗​​=​​G​b​​​⃗​​=​​G​⃗​​(​x​c​​​⃗​​)​​​​(W​a​​⋅A​c​​, W​a​​⋅Θ​c​​)​(W​b​​⋅A​c​​, W​a​​⋅Θ​c​​)​=​G​a​​​⃗​​+​G​b​​​⃗​​​​ 显然，以 ∠Θ=[Θ0 , ... , Θθ−1]\\angle \\Theta = [\\Theta_0\\ ,\\ ...\\ ,\\ \\Theta_{\\theta-1}]∠Θ=[Θ​0​​ , ... , Θ​θ−1​​] 指定方向的矢量合形式表示 ， G⃗(xc⃗)\\vec{G}(\\vec{x_c})​G​⃗​​(​x​c​​​⃗​​) 除了 Θa\\Theta_aΘ​a​​ 、 Θb\\Theta_bΘ​b​​ 角度外，其余角度分量为 000 ， 有： G⃗(xc⃗)=∠Θ(0, ... ,Wa,Wb, ... ,0) {\\displaystyle \\begin{aligned} \\vec{G}(\\vec{x_c}) &= \\angle \\Theta(0, \\ ...\\ , W_a, W_b,\\ ...\\ ,0) \\\\ \\end{aligned} } ​​G​⃗​​(​x​c​​​⃗​​)​​​​=∠Θ(0, ... ,W​a​​,W​b​​, ... ,0)​​ 由于不需要考虑反向的数据还原，核内采样按照 ∠Θ=[Θ0 , ... , Θθ−1]\\angle \\Theta = [\\Theta_0\\ ,\\ ...\\ ,\\ \\Theta_{\\theta-1}]∠Θ=[Θ​0​​ , ... , Θ​θ−1​​] 的边界角度的方向矢量合形式求和，即可完成分组内的特征整合。记得到分组的 θ\\thetaθ 维特征向量 Cell⃗\\vec{Cell}​Cell​⃗​​ ，则： Cell⃗=∑∠G⃗(xc⃗) {\\displaystyle \\begin{aligned} \\vec{Cell} &= \\sum \\angle \\vec{G}(\\vec{x_c}) \\\\ \\end{aligned} } ​​Cell​⃗​​​​​​=∑∠​G​⃗​​(​x​c​​​⃗​​)​​ 那么现在的问题就是如何分组，或者分为几组了。 当采样核为 n×nn \\times nn×n 时，我们取边界整数点出发过核心 (12n, 12n)(\\tfrac {1}{2}n,\\ \\tfrac {1}{2}n)(​2​​1​​n, ​2​​1​​n) 的连线，加上对角线一起作为分组分割线。 由任意两条相邻分割线间的夹角，构成以核心为原点的角度分组。 所以， ∠Θ=[Θ0 , ... , Θθ−1]\\angle \\Theta = [\\Theta_0\\ ,\\ ...\\ ,\\ \\Theta_{\\theta-1}]∠Θ=[Θ​0​​ , ... , Θ​θ−1​​] 代表的正是分割线角度。因此，当不区分夹角及其对角方向时，中心角能够分为 θ=n+1\\theta = n + 1θ=n+1 组，称为 无符号梯度（Unsigned Gradient） 分组。当考虑夹角与对角方向互反时，中心角能够分为 θ=2(n+1)\\theta = 2(n+1)θ=2(n+1) 组，称为 有符号梯度（Signed Gradient） 分组。 采样核一般为 n×n=8×8n \\times n = 8 \\times 8n×n=8×8 大小，此时无符号梯度以方向标记，可分为 999 组即: ∠Θ=[0∘, 20∘, 40∘, 60∘, 80∘, 100∘, 120∘, 140∘, 160∘] {\\displaystyle \\begin{aligned} \\angle \\Theta =& [0^{\\circ},\\ 20^{\\circ},\\ 40^{\\circ},\\ 60^{\\circ},\\ 80^{\\circ},\\ 100^{\\circ},\\ 120^{\\circ},\\ 140^{\\circ},\\ 160^{\\circ}] \\\\ \\end{aligned} } ​∠Θ=​​​​[0​∘​​, 20​∘​​, 40​∘​​, 60​∘​​, 80​∘​​, 100​∘​​, 120​∘​​, 140​∘​​, 160​∘​​]​​ 而有符号梯度则可分为 181818 组： ∠Θ=[∠Θlt∠Θrb]=[0∘,20∘,40∘,60∘,80∘,100∘,120∘,140∘,160∘180∘,200∘,220∘,240∘,260∘,280∘,300∘,320∘,340∘] {\\displaystyle \\begin{aligned} \\angle \\Theta = \\begin{bmatrix} &\\angle \\Theta_{lt} \\\\ &\\angle \\Theta_{rb} \\end{bmatrix} = \\begin{bmatrix} 0^{\\circ},& 20^{\\circ},& 40^{\\circ},& 60^{\\circ},& 80^{\\circ},& 100^{\\circ},& 120^{\\circ},& 140^{\\circ},& 160^{\\circ} \\\\ 180^{\\circ},& 200^{\\circ},& 220^{\\circ},& 240^{\\circ},& 260^{\\circ},& 280^{\\circ},& 300^{\\circ},& 320^{\\circ},& 340^{\\circ} \\end{bmatrix} \\end{aligned} } ​∠Θ=[​​​​​∠Θ​lt​​​∠Θ​rb​​​​]=[​0​∘​​,​180​∘​​,​​​20​∘​​,​200​∘​​,​​​40​∘​​,​220​∘​​,​​​60​∘​​,​240​∘​​,​​​80​∘​​,​260​∘​​,​​​100​∘​​,​280​∘​​,​​​120​∘​​,​300​∘​​,​​​140​∘​​,​320​∘​​,​​​160​∘​​​340​∘​​​​]​​ 以无符号梯度的 999 组分组为例，统计只需累计入组即可： 图 3.3.1-2 核大小 的无符号梯度（Unsigned Gradient）分组示意图 随后依次统计分组的采样核内数据。上图数据统计结果如下（概略图）： 图 3.3.1-3 无符号梯度分组的单组采样核内统计结果示意直方图 统计完毕时，特征向量 Cell⃗\\vec{Cell}​Cell​⃗​​ 随即生成完毕。我们以 WθW_{\\theta}W​θ​​ 表示分组的特征向量，在方向 θ\\thetaθ 上的强度大小（即此方向矢量的秩），则对于无符号梯度（Unsigned Gradient）分组： Cell⃗=∑∠G⃗(xc⃗)=Θ⃗(W0∘, ... ,W160∘)∈R9×1 {\\displaystyle \\begin{aligned} \\vec{Cell} &= \\sum \\angle \\vec{G}(\\vec{x_c}) = \\vec{\\Theta}(W_{0^{\\circ}}, \\ ...\\ , W_{160^{\\circ}}) \\in \\mathbb{R}^{9 \\times 1} \\\\ \\end{aligned} } ​​Cell​⃗​​​​​​=∑∠​G​⃗​​(​x​c​​​⃗​​)=​Θ​⃗​​(W​0​∘​​​​, ... ,W​160​∘​​​​)∈R​9×1​​​​ 同样，对有符号梯度（Signed Gradient）分组： Cell⃗=∑∠G⃗(xc⃗)=Θ⃗(W0∘, ... ,W160∘, ... ,W340∘)∈R18×1 {\\displaystyle \\begin{aligned} \\vec{Cell} &= \\sum \\angle \\vec{G}(\\vec{x_c}) = \\vec{\\Theta}(W_{0^{\\circ}}, \\ ...\\ , W_{160^{\\circ}}, \\ ...\\ , W_{340^{\\circ}}) \\in \\mathbb{R}^{18 \\times 1} \\\\ \\end{aligned} } ​​Cell​⃗​​​​​​=∑∠​G​⃗​​(​x​c​​​⃗​​)=​Θ​⃗​​(W​0​∘​​​​, ... ,W​160​∘​​​​, ... ,W​340​∘​​​​)∈R​18×1​​​​ 至此，完成分组提炼。 这种对数据梯度的蒸馏手段非常重要，因为它不只可以运用于物体识别等情况的中间步骤，也可以被运用于粗糙的运动特征检测。 而从分组的数据得来的分组特征，还需要归一化才能被有效使用。 块归一化 由于分组内梯度矢量的分解叠加有可能会使某个方向上的梯度强度 远超其他方向 ，因而造成该方向上的灰度（光亮度）变化会极大的影响结果。 这样的影响当然是有利的，但无法相对统一的权重，也会给处理带来大量的不确定性。 如图例： 图 3.3.1-4 块归一化说明图例（数据源） 取绿色框中以 n×n=8×8n \\times n = 8 \\times 8n×n=8×8 采样核，经过前几步以无符号梯度（Unsigned Gradient）方式处理，会得到的四个分组： 图 3.3.1-5 图例（数据源）绿色框中四个分组特征向量直方图表示 如果能够将这种变化趋势原封不动的保存下来，并缩小尺度到统一标准，就可以实现即保证特征不被不必要的削减，也有足够一致的度量衡。 因此，归一化就是解决办法。 归一化（Normalization） 是将目标数据集，按照总体权重等比放缩到指定区间范围的一种数学工具。通常我们选取当前采样分组包含的数据，即为归一化的目标数据集。组与组间独立归一化。但 块归一化（Block Normalization） 和一般情况下不完全一样，是以 块（Block） 为样本源而非 组（Cell） 样本源本身，来进行归一化处理的。 什么是块（Block）呢？ 块（Block）是对于由一系列分组（Cell）按照一定规则（例如四叉树、标准单元等）组合构成的分组并集单元的称谓。 是组的集合。对块的分法有各种形式，但在方向梯度直方图中，使用的是一种直接切入的固定设置。记块大小为 N×NN \\times NN×N ，块的最小单位为组，则取 N×N=2×2N \\times N = 2 \\times 2N×N=2×2 的固定大小组采样，构成 HOG 的分块。即图例中的绿色方块： 图 3.3.1-6 图例（数据源）块划分单一块示意图 同分组一样，分块的目的也是为了更好的将特征数据进行汇总。只不过分块时的基础单元，从分组时的像素梯度矢量，变为了分组特征向量。记分块为 BlockBlockBlock ，分块特征向量为 Block⃗\\vec{Block}​Block​⃗​​ 。仍以 ∣target∣1\\vert target \\vert_1∣target∣​1​​ 表示归一化操作，有： Block⃗=∣[Cell⃗1, Cell⃗2, Cell⃗3, Cell⃗4]∣1∈R(N×N)⋅θ×1 {\\displaystyle \\begin{aligned} \\vec{Block} &= \\vert [\\vec{Cell}_1,\\ \\vec{Cell}_2,\\ \\vec{Cell}_3,\\ \\vec{Cell}_4] \\vert_1 \\in \\mathbb{R}^{(N \\times N) \\cdot \\theta \\times 1} \\\\ \\end{aligned} } ​​Block​⃗​​​​​​=∣[​Cell​⃗​​​1​​, ​Cell​⃗​​​2​​, ​Cell​⃗​​​3​​, ​Cell​⃗​​​4​​]∣​1​​∈R​(N×N)⋅θ×1​​​​ 可见，在 2×22 \\times 22×2 大小的固定分块下，分块特征向量 的维度即为分组特征向量方向的 444 倍，即 (N×N)⋅θ(N \\times N) \\cdot \\theta(N×N)⋅θ 。如果我们采用 L-2 归一化（即 L2范数）处理，记归一化因子为 L2L_2L​2​​ ，则： L2=∣Cell⃗1∣2+ ∣Cell⃗2∣2+ ∣Cell⃗3∣2+ ∣Cell⃗4∣2=∑(∣∠G⃗1∣2+ ∣∠G⃗2∣2+ ∣∠G⃗3∣2+ ∣∠G⃗4∣2)Block⃗=1L2[Cell⃗1, Cell⃗2, Cell⃗3, Cell⃗4]∈R(N×N)⋅θ×1 {\\displaystyle \\begin{aligned} L_2 &= \\sqrt{|\\vec{Cell}_1 |^2+\\ |\\vec{Cell}_2 |^2+\\ |\\vec{Cell}_3 |^2+\\ |\\vec{Cell}_4 |^2} \\\\ &= \\sqrt{\\sum (| \\angle \\vec{G}_1|^2 +\\ | \\angle \\vec{G}_2|^2 +\\ | \\angle \\vec{G}_3|^2 +\\ | \\angle \\vec{G}_4|^2 )} \\\\ \\vec{Block} &= \\frac{1}{L_2}[\\vec{Cell}_1,\\ \\vec{Cell}_2,\\ \\vec{Cell}_3,\\ \\vec{Cell}_4] \\in \\mathbb{R}^{(N \\times N) \\cdot \\theta \\times 1} \\end{aligned} } ​L​2​​​​​Block​⃗​​​​​=√​∣​Cell​⃗​​​1​​∣​2​​+ ∣​Cell​⃗​​​2​​∣​2​​+ ∣​Cell​⃗​​​3​​∣​2​​+ ∣​Cell​⃗​​​4​​∣​2​​​​​​=√​∑(∣∠​G​⃗​​​1​​∣​2​​+ ∣∠​G​⃗​​​2​​∣​2​​+ ∣∠​G​⃗​​​3​​∣​2​​+ ∣∠​G​⃗​​​4​​∣​2​​)​​​​=​L​2​​​​1​​[​Cell​⃗​​​1​​, ​Cell​⃗​​​2​​, ​Cell​⃗​​​3​​, ​Cell​⃗​​​4​​]∈R​(N×N)⋅θ×1​​​​ 那么，对图例中的分组进行块归一化到 [0, 1][0,\\ 1][0, 1] 区间，所得如下： 图 3.3.1-7 图例（数据源）绿色框对应块的块归一化特征向量结果 之后，按照块大小为步长，对全图分块计算即可得到输入图片的方向梯度直方图运算结果。达成对图片整体和分块区域的运动检测目的。 那么，在具体实践中是怎么做的呢？ 同前文中对滤波的处理方法类似，对于此类存在核操作流的方法论，为了充分利用 GPU 并行计算能力，通用思路仍然是抽象为可执行的渲染程序片来交由 GPU 加速。 以索贝尔梯度计算 HOG 的 GLSL 渲染程序片 现在，我们可以依据理论来做 GPU 的动态管线程序片封装。 首先，我们需要定义 顶点程序片（Vertex Shader） 。通过该程序片指定 GPU 的绘制区域，以及纹理与物体的点位映射。由于我们是对整个视窗界面进行处理，所以可以采用对传入的顶点数据进行坐标变换的方式，来求得顶点映射的纹理坐标，减少少量数据通信： attribute vec3 position; varying vec4 fs_position; varying vec2 fs_texcoord; void main() { fs_position = vec4(position.x, position.y, position.z, 1.0); fs_texcoord = (position.xy + vec2(1.0, 1.0)) / 2.0; gl_Position = fs_position; } 程序化 HOG 的关键处理部分，依旧在 像素程序片（Pixel Shader/Fragment Shader） 上。相比之前对于滤波算法的实现，这里 显然复杂得多 ： precision mediump float; const float PI = 3.1415927; const int n = 8; const int N = 2; const int SIZE_CV = (n + 1); const int SIZE_BV = /*N * N **/ SIZE_CV; // for orientation weight sum const float ANGLE_GAP = 20.0 * PI / 180.0; const vec3 ANGLE_0 = vec3(cos(ANGLE_GAP * 0.0), sin(ANGLE_GAP * 0.0), 100); // x=cos y=sin z=cot const vec3 ANGLE_20 = vec3(cos(ANGLE_GAP * 1.0), sin(ANGLE_GAP * 1.0), 2.74747742); const vec3 ANGLE_40 = vec3(cos(ANGLE_GAP * 2.0), sin(ANGLE_GAP * 2.0), 1.19175359); const vec3 ANGLE_60 = vec3(cos(ANGLE_GAP * 3.0), sin(ANGLE_GAP * 3.0), 0.57735027); const vec3 ANGLE_80 = vec3(cos(ANGLE_GAP * 4.0), sin(ANGLE_GAP * 4.0), 0.17632698); const vec3 ANGLE_100 = vec3(cos(ANGLE_GAP * 5.0), sin(ANGLE_GAP * 5.0), -0.17632698); const vec3 ANGLE_120 = vec3(cos(ANGLE_GAP * 6.0), sin(ANGLE_GAP * 6.0), -0.57735027); const vec3 ANGLE_140 = vec3(cos(ANGLE_GAP * 7.0), sin(ANGLE_GAP * 7.0), -1.19175359); const vec3 ANGLE_160 = vec3(cos(ANGLE_GAP * 8.0), sin(ANGLE_GAP * 8.0), -2.74747742); const vec3 ANGLE_180 = vec3(cos(ANGLE_GAP * 9.0), sin(ANGLE_GAP * 9.0), -100); const float CELL_TILE_SIZE = 8.0; //pixels const float BLOCK_TILE_SIZE = 2.0; //cells const float HOG_TILE_SIZE = 16.0; //pixels(n*N) const float HOG_SHAFT_LENGTH = 14.0; const float HOG_SHAFT_THICKNESS = 0.5; const float HOG_SHAFT_HEAD_RATE = 64.0; const vec3 HOG_COLOR = vec3(1.0, 1.0, 0.0); const float HOG_MIN_MAGNITUDE = 0.1; varying vec4 fs_position; varying vec2 fs_texcoord; uniform bool only_edge; uniform vec2 pixel_bias; uniform mat3 sobel_matrix_x; uniform mat3 sobel_matrix_y; uniform float hog_magnitude_limit; uniform sampler2D target_texture; /* Simple Grey */ float grey(vec3 c) { return 0.299 * c[0] + 0.587 * c[1] + 0.114 * c[2]; } /* Calucate HOG Orient-hog Density (pixel by pixel) */ float hog_density(vec2 target_coord, vec3 field_vector) { vec2 ori_pos = target_coord.xy / pixel_bias; vec2 tile_center = (floor(ori_pos / HOG_TILE_SIZE) + 0.5) * HOG_TILE_SIZE; float magnitude = abs(field_vector.z); if (magnitude > max(HOG_MIN_MAGNITUDE, hog_magnitude_limit)) { float distance = clamp(magnitude * HOG_SHAFT_LENGTH, 0.1, HOG_SHAFT_LENGTH); vec2 normalizer = normalize(field_vector.xy); vec2 tile_offset = ori_pos - tile_center; float density = HOG_SHAFT_THICKNESS / HOG_SHAFT_HEAD_RATE - max( abs(dot(tile_offset, vec2(+normalizer.y, -normalizer.x))), abs(dot(tile_offset, vec2(+normalizer.x, +normalizer.y))) - distance ); return clamp(1.0 + density, 0.0, 1.0); } return 0.0; } /* Calucate Sobel Field at target center */ vec3 sobel_edge_detection(vec2 target_coord) { float gradient_center_x; float gradient_center_y; for (int i = 0; i = seek_to && seek_to >= ANGLE_20.z){ wight_as = abs((seek_to - ANGLE_0.z)/(ANGLE_20.z - ANGLE_0.z)); result[0][0] += field_vector[2] *wight_as; result[0][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_20.z>= seek_to && seek_to >= ANGLE_40.z){ wight_as = abs((seek_to - ANGLE_20.z)/(ANGLE_40.z - ANGLE_20.z)); result[0][1] += field_vector[2] * wight_as; result[0][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_40.z>= seek_to && seek_to >= ANGLE_60.z){ wight_as = abs((seek_to - ANGLE_40.z)/(ANGLE_60.z - ANGLE_40.z)); result[0][2] += field_vector[2] * wight_as; result[1][0] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_60.z>= seek_to && seek_to >= ANGLE_80.z){ wight_as = abs((seek_to - ANGLE_60.z)/(ANGLE_80.z - ANGLE_60.z)); result[1][0] += field_vector[2] * wight_as; result[1][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_80.z>= seek_to && seek_to >= ANGLE_100.z){ wight_as = abs((seek_to - ANGLE_80.z)/(ANGLE_100.z - ANGLE_80.z)); result[1][1] += field_vector[2] * wight_as; result[1][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_100.z>= seek_to && seek_to >= ANGLE_120.z){ wight_as = abs((seek_to - ANGLE_100.z)/(ANGLE_120.z - ANGLE_100.z)); result[1][2] += field_vector[2] * wight_as; result[2][0] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_120.z>= seek_to && seek_to >= ANGLE_140.z){ wight_as = abs((seek_to - ANGLE_120.z)/(ANGLE_140.z - ANGLE_120.z)); result[2][0] += field_vector[2] * wight_as; result[2][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_140.z>= seek_to && seek_to >= ANGLE_160.z){ wight_as = abs((seek_to - ANGLE_140.z)/(ANGLE_160.z - ANGLE_140.z)); result[2][1] += field_vector[2] * wight_as; result[2][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_160.z>= seek_to && seek_to >= ANGLE_180.z){ wight_as = abs((seek_to - ANGLE_160.z)/(ANGLE_180.z - ANGLE_160.z)); result[2][2] += field_vector[2] * wight_as; result[0][0] += field_vector[2] * (1.0 - wight_as); } } } } return result; } /* Calucate Block Feature at target center */ float block_feature_extraction(vec2 target_coord) { float orient_hog_density = 0.0; float block_feature_vector[SIZE_BV]; vec2 cell_bias = vec2(n, n) * pixel_bias; mat3 cell_lt = cell_feature_extraction(target_coord); mat3 cell_rt = cell_feature_extraction(target_coord + vec2(cell_bias.x, 0.0)); mat3 cell_lb = cell_feature_extraction(target_coord + vec2(0.0, cell_bias.y)); mat3 cell_rb = cell_feature_extraction(target_coord + cell_bias); float normalization_factor = 0.0; for (int i = 0; i 样例采用 单一流水线过程 ，我们将几个关键流程节点封装为方法，实现了 HOG 的处理。相对于顶点程序片，像素程序片不太容易理解，还需分步拆开解读。 HOG 片元着色器（Fragment Shader）的细节拆解 首先需要在处理前，进行一部分方法和常量准备。这些 前置工作包含两个部分 。 第一部分由纯常量构成。用于辅助实现 方向梯度直方图（HOG）算法 中，各个步骤所使用到的关键恒定参数，有： const float PI = 3.1415927; const int n = 8; const int N = 2; const int SIZE_CV = (n + 1); const int SIZE_BV = /*N * N **/ SIZE_CV; // for orientation weight sum const float ANGLE_GAP = 20.0 * PI / 180.0; const vec3 ANGLE_0 = vec3(cos(ANGLE_GAP * 0.0), sin(ANGLE_GAP * 0.0), 100); // x=cos y=sin z=cot const vec3 ANGLE_20 = vec3(cos(ANGLE_GAP * 1.0), sin(ANGLE_GAP * 1.0), 2.74747742); const vec3 ANGLE_40 = vec3(cos(ANGLE_GAP * 2.0), sin(ANGLE_GAP * 2.0), 1.19175359); const vec3 ANGLE_60 = vec3(cos(ANGLE_GAP * 3.0), sin(ANGLE_GAP * 3.0), 0.57735027); const vec3 ANGLE_80 = vec3(cos(ANGLE_GAP * 4.0), sin(ANGLE_GAP * 4.0), 0.17632698); const vec3 ANGLE_100 = vec3(cos(ANGLE_GAP * 5.0), sin(ANGLE_GAP * 5.0), -0.17632698); const vec3 ANGLE_120 = vec3(cos(ANGLE_GAP * 6.0), sin(ANGLE_GAP * 6.0), -0.57735027); const vec3 ANGLE_140 = vec3(cos(ANGLE_GAP * 7.0), sin(ANGLE_GAP * 7.0), -1.19175359); const vec3 ANGLE_160 = vec3(cos(ANGLE_GAP * 8.0), sin(ANGLE_GAP * 8.0), -2.74747742); const vec3 ANGLE_180 = vec3(cos(ANGLE_GAP * 9.0), sin(ANGLE_GAP * 9.0), -100); const float CELL_TILE_SIZE = 8.0; //pixels const float BLOCK_TILE_SIZE = 2.0; //cells 第二部分则包含常量和辅助方法。用于辅助 HOG 最终结果的图像化显示，有： const float CELL_TILE_SIZE = 8.0; //pixels const float BLOCK_TILE_SIZE = 2.0; //cells const float HOG_TILE_SIZE = 16.0; //pixels(n*N) const float HOG_SHAFT_LENGTH = 14.0; const float HOG_SHAFT_THICKNESS = 0.5; const float HOG_SHAFT_HEAD_RATE = 64.0; const vec3 HOG_COLOR = vec3(1.0, 1.0, 0.0); const float HOG_MIN_MAGNITUDE = 0.1; /* Simple Grey */ float grey(vec3 c) { return 0.299 * c[0] + 0.587 * c[1] + 0.114 * c[2]; } /* Calucate HOG Orient-hog Density (pixel by pixel) */ float hog_density(vec2 target_coord, vec3 field_vector) { vec2 ori_pos = target_coord.xy / pixel_bias; vec2 tile_center = (floor(ori_pos / HOG_TILE_SIZE) + 0.5) * HOG_TILE_SIZE; float magnitude = abs(field_vector.z); if (magnitude > max(HOG_MIN_MAGNITUDE, hog_magnitude_limit)) { float distance = clamp(magnitude * HOG_SHAFT_LENGTH, 0.1, HOG_SHAFT_LENGTH); vec2 normalizer = normalize(field_vector.xy); vec2 tile_offset = ori_pos - tile_center; float density = HOG_SHAFT_THICKNESS / HOG_SHAFT_HEAD_RATE - max( abs(dot(tile_offset, vec2(+normalizer.y, -normalizer.x))), abs(dot(tile_offset, vec2(+normalizer.x, +normalizer.y))) - distance ); return clamp(1.0 + density, 0.0, 1.0); } return 0.0; } 灰度（光亮度）值采用 BT.601 的狭隘区间（Narrow Range） 标准快速计算，运用中也可以替换为均值（部分场景）或根据情况更换其他标准（ 如 RGB数据 非采样得原始数据的标准原色格式而来，则因根据转换前的传输格式来选择配套的规格 ，见上一章）。 注意以 HOG_[xx] 为格式的常量。这些常量被用于计算，上屏显示的无符号梯度（Unsigned Gradient）对应方向上的权重柱形轴。 柱形轴过分块中心，轴的长度和颜色的深浅（即能量密度）代表归一化后的权重大小。而方法计算所得 density 则为当前像素点对应块内位置的能量密度值。显然，密度值只有在轴方向上才存在有效值。另一方面，较小的能量密度也不具有代表性，需要通过 阈值限定进行过滤 ，此处采用 max(HOG_MIN_MAGNITUDE, hog_magnitude_limit) 进行设置。 准备完成后，就该正式流程的处理了。这里的封装思路，是以 生成的最小结果单元为分割依据 进行的。所以，将 HOG 步骤方法封为一下三个： sobel_edge_detection 针对 像素点（Pixel）梯度矢量 的 索贝尔边界检测 /* Calucate Sobel Field at target center */ vec3 sobel_edge_detection(vec2 target_coord) { float gradient_center_x; float gradient_center_y; for (int i = 0; i cell_feature_extraction 针对 分组（Cell）特征提取 为结果的 矢量统计合并 /* Calucate Cell Feature at target center */ mat3 cell_feature_extraction(vec2 target_coord) { mat3 result; float bias_unit = float(n-1)/2.0; vec2 ori_pos = target_coord.xy / pixel_bias; vec2 cell_center = (floor(ori_pos / CELL_TILE_SIZE) + 0.5) * CELL_TILE_SIZE; float normalization_factor = 0.0; for (int i = 0; i = seek_to && seek_to >= ANGLE_20.z){ wight_as = abs((seek_to - ANGLE_0.z)/(ANGLE_20.z - ANGLE_0.z)); result[0][0] += field_vector[2] *wight_as; result[0][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_20.z>= seek_to && seek_to >= ANGLE_40.z){ wight_as = abs((seek_to - ANGLE_20.z)/(ANGLE_40.z - ANGLE_20.z)); result[0][1] += field_vector[2] * wight_as; result[0][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_40.z>= seek_to && seek_to >= ANGLE_60.z){ wight_as = abs((seek_to - ANGLE_40.z)/(ANGLE_60.z - ANGLE_40.z)); result[0][2] += field_vector[2] * wight_as; result[1][0] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_60.z>= seek_to && seek_to >= ANGLE_80.z){ wight_as = abs((seek_to - ANGLE_60.z)/(ANGLE_80.z - ANGLE_60.z)); result[1][0] += field_vector[2] * wight_as; result[1][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_80.z>= seek_to && seek_to >= ANGLE_100.z){ wight_as = abs((seek_to - ANGLE_80.z)/(ANGLE_100.z - ANGLE_80.z)); result[1][1] += field_vector[2] * wight_as; result[1][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_100.z>= seek_to && seek_to >= ANGLE_120.z){ wight_as = abs((seek_to - ANGLE_100.z)/(ANGLE_120.z - ANGLE_100.z)); result[1][2] += field_vector[2] * wight_as; result[2][0] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_120.z>= seek_to && seek_to >= ANGLE_140.z){ wight_as = abs((seek_to - ANGLE_120.z)/(ANGLE_140.z - ANGLE_120.z)); result[2][0] += field_vector[2] * wight_as; result[2][1] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_140.z>= seek_to && seek_to >= ANGLE_160.z){ wight_as = abs((seek_to - ANGLE_140.z)/(ANGLE_160.z - ANGLE_140.z)); result[2][1] += field_vector[2] * wight_as; result[2][2] += field_vector[2] * (1.0 - wight_as); } else if (ANGLE_160.z>= seek_to && seek_to >= ANGLE_180.z){ wight_as = abs((seek_to - ANGLE_160.z)/(ANGLE_180.z - ANGLE_160.z)); result[2][2] += field_vector[2] * wight_as; result[0][0] += field_vector[2] * (1.0 - wight_as); } } } } return result; } block_feature_extraction 针对 分块（Block）特征提取 为结果的 块归一化 /* Calucate Block Feature at target center */ float block_feature_extraction(vec2 target_coord) { float orient_hog_density = 0.0; float block_feature_vector[SIZE_BV]; vec2 cell_bias = vec2(n, n) * pixel_bias; mat3 cell_lt = cell_feature_extraction(target_coord); mat3 cell_rt = cell_feature_extraction(target_coord + vec2(cell_bias.x, 0.0)); mat3 cell_lb = cell_feature_extraction(target_coord + vec2(0.0, cell_bias.y)); mat3 cell_rb = cell_feature_extraction(target_coord + cell_bias); float normalization_factor = 0.0; for (int i = 0; i 考虑到思路连贯性，样例中的实现将所有步骤放在一张纹理过程中处理，且没有对核计算做优化。这会导致每个像素都存在一次 HOG 计算金字塔，而按理来说 一个块内并不需要重复计算 。样例中相当于将块内运算重复了 16×1616 \\times 1616×16 次，极大的增加了消耗。 因此，在实际应用中，需要对上文的实现进行改造。 把文中程序片内的各个步骤的方法，分配到不同阶的程序片中，并优化纹理过程。 之后才能被更为高效的予以运用。介于骨干并无不同，此处就不再展开赘述。 经过处理后的最终结果，以能量密度的形式附加到当前像素点的色彩值上，实现最终的图形化展示： void main() { vec3 output_ = only_edge? vec3(0) : texture2D(target_texture, fs_texcoord.xy).rgb; float orient_hog_density = block_feature_extraction(fs_texcoord.xy); vec3 hogs_ = orient_hog_density * HOG_COLOR; gl_FragColor = vec4(output_ + hogs_, 1.0); } 现在，整个 HOG 的简易程序片就完成了。 到此为止，方向梯度直方图技术可以初步应用于音视频当中了。 虽然在上文样例的渲染程序片实现过程中，但从普遍意义上来讲，HOG 仍然属于相对高消耗的算法， HOG 提供的方法论更多被应用在 编解码规格制定的时域冗余处理 上。其本身具有一定的 硬件门槛。 HOG 最终产物的用处 假设输入帧长宽为 W×H=256×256W \\times H = 256 \\times 256W×H=256×256 。按照前文采用块大小 2×22 \\times 22×2 ，分组大小 8×88 \\times 88×8 进行处理，则得到方向梯度直方图最终输出结果为包含 16×16=25616 \\times 16 = 25616×16=256 个块特征向量的数据集合。每一个块特征向量由 (2×2)⋅9=36(2 \\times 2) \\cdot 9 = 36(2×2)⋅9=36 维（参数）构成。为了方便描述，我们将输出数据集称为 HOG 数据帧 。 HOG 数据帧（HOG Frame）更多被作为经过特征提取后的预处理输入数据，传入目标物体检测等人工智能计算机视觉方向的算法模型。 通过模型获取的物体识别结果后，再利用训练好的目标跟踪模型，或传统目标跟踪算法（诸如：核卷积滤波（KCF [Kernelized Correlation Filter]）[18] 、MOSSE 算法等）等，来获取视频流中运动物体在时序上的关联性。 那么，用于判断目标检测结果是否准确的方法，也就是目标检测模型的 损失函数（Loss Function） 是什么呢？ Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_3_2.html":{"url":"Chapter_3/Language/cn/Docs_3_3_2.html","title":"3.3.2 朴素目标检测结果度量 - IoU & GIoU","keywords":"","body":"3.3.2 朴素目标检测结果度量 - IoU & GIoU 考虑到算法本身需要作为目标检测结果准确性的衡量标准，并用于模型的计算过程。所以不能采用较高复杂程度的算法。而 交并比（IoU [Intersection over Union]） 计算作为相对简单的区域检测算法，则是可被采用的不错方案。 交并比顾名思义，即为交集和并集的比值。 只不过这里的交集和并集，指的是 预测结果（Prediction）对应的预测框（Anchor Box）和标注框（Ground Truth）的交集与并集 ，记为 I=IntersectionI = IntersectionI=Intersection 和 U=UnionU = UnionU=Union 。 图 3.3.2-1 原论文中交并比示意图[19] 如图所示，交并比公式非常简洁（注意 并非 IoU Loss ），可记为： IoU=Intersection(Anchor, Truth)Union(Anchor, Truth)=IU {\\displaystyle \\begin{aligned} IoU &= \\frac{Intersection(Anchor,\\ Truth)}{Union(Anchor,\\ Truth)} = \\frac{I}{U} \\\\ \\end{aligned} } ​IoU​​​​=​Union(Anchor, Truth)​​Intersection(Anchor, Truth)​​=​U​​I​​​​ 而根据交并比设计的损失函数，就是交并比损失函数（IoU Loss）。 同其他有关深度学习领域，针对损失函数提出的算法理论一致。IoU Loss 在模型中同样存在两项应用，分别为 前向预测（Forward Prediction） 和 反向传播（Backward Propagation） 。 即标准损失的计算和模型梯度迭代的加速。 交并比损失函数（IoU Loss） 根据原论文的设计，IoU 前向扩散作用在 ReLU 激活函数层（ReLU Layer）后，以代替传统物体识别模型采用的 L2L_2L​2​​ 损失函数，判断待筛选的预测框是否命中。由于始终有 IoU∈[0, 1]IoU \\in [0, \\ 1]IoU∈[0, 1] ，交并比损失函数可被认为是 p(IoU=1)=1p(IoU = 1) = 1p(IoU=1)=1 的 特殊交叉熵损失函数（cross-entropy Loss） ，有： IoU Loss=−p⋅ln(IoU)−(1−p)⋅ln(1−IoU)∣p(IoU=1)=1=−ln(IoU) {\\displaystyle \\begin{aligned} IoU \\ \\mathcal{L}oss &= -p \\cdot ln(IoU) - (1 - p) \\cdot ln(1-IoU) | \\quad p(IoU = 1) = 1 \\\\ &= -ln(IoU) \\\\ \\end{aligned} } ​IoU Loss​​​​​=−p⋅ln(IoU)−(1−p)⋅ln(1−IoU)∣p(IoU=1)=1​=−ln(IoU)​​ 带入交并比实际值，有： IoU Loss=−lnIntersection(Anchor, Truth)Union(Anchor, Truth)=−lnIU {\\displaystyle \\begin{aligned} IoU \\ \\mathcal{L}oss &= -ln \\frac{Intersection(Anchor,\\ Truth)}{Union(Anchor,\\ Truth)} = -ln \\frac{I}{U} \\\\ \\end{aligned} } ​IoU Loss​​​​=−ln​Union(Anchor, Truth)​​Intersection(Anchor, Truth)​​=−ln​U​​I​​​​ 此即为 交并比损失函数 。由于 IoU∈[0, 1]IoU \\in [0, \\ 1]IoU∈[0, 1] 有 −ln(IoU)≈1−IoU-ln(IoU) \\approx 1-IoU−ln(IoU)≈1−IoU ，考虑到计算便利性，在条件范围内常用差值代替对数计算 。即： IoU Loss≈1−IoUIoU∈[0, 1] {\\displaystyle \\begin{aligned} IoU \\ \\mathcal{L}oss &\\approx 1-IoU \\quad IoU \\in [0, \\ 1] \\\\ \\end{aligned} } ​IoU Loss​​​​≈1−IoUIoU∈[0, 1]​​ 相比 L2L_2L​2​​ 损失函数的简单区域差值来衡量命中的方式， IoU 考虑到了 预测框与标准框的平面空间位置关系 ，并通过对位置的衡量 锁定了两者间的平面位姿独立优化 ，因而具有更贴合客观的代表性。且在交叉熵类型损失函数（详见下一章）的特性作用下，结果落于单位量化的百分比区间 ，利于阈值衡量和操作之便。 交并比损失函数（IoU Loss）的反向传播（Backward Propagation） 反向传播（Backward Propagation） 简单来说，是通过当前学习到的参数在参数空间内指定方向的运动趋势，来反相强化或衰减该方向上的参数权重，进而达到更快使模型拟合的数学方法论统称。自 杰弗里·辛顿（Geoffrey Hinton，“深度学习之父”，当代人工智能领域三巨头之一） 教授提出并汇总这一概念以来，持续的被作为深度学习根基理论之一，应用在各类算法的学习过程中。 如果从物理学角度来看，把参与训练的相关模型参数的权重向量比作速度 ，那么，损失函数的反向传播，就相当于 速度在各个方向上的某一时刻的加速度 。所以，其影响的是权重在方向上的迭代步长变化，即为优化算法的输出。 交并比损失函数的反向传播，为便于称呼，简称 反向交并比（Backward IoU/ IoU Back） 。取图 3.3.2-1 说明，记预测框为 x=(xl,xt,xr,xb)x = (x_l, x_t, x_r, x_b)x=(x​l​​,x​t​​,x​r​​,x​b​​) 面积为 XXX ，标注框为 x~=(x~l,x~t,x~r,x~b)\\tilde{x} = (\\tilde{x}_l, \\tilde{x}_t, \\tilde{x}_r, \\tilde{x}_b)​x​~​​=(​x​~​​​l​​,​x​~​​​t​​,​x​~​​​r​​,​x​~​​​b​​) 面积为 X~\\tilde{X}​X​~​​ ，则反向交并比可表示为： IoU Back=∂L∂x=I⋅(∇xX−∇xI)−U⋅∇xIU2⋅IoU=1U⋅∇xX − U+IUI⋅∇xI {\\displaystyle \\begin{aligned} IoU\\ \\mathcal{B}ack &= \\frac{\\partial \\mathcal{L}}{\\partial x} = \\frac{I \\cdot (\\nabla_xX - \\nabla_xI) - U \\cdot \\nabla_xI}{U^2 \\cdot IoU} \\\\ &= \\tfrac{1}{U} \\cdot \\nabla_xX \\ - \\ \\tfrac{U+I}{UI} \\cdot \\nabla_xI \\\\ \\end{aligned} } ​IoU Back​​​​​=​∂x​​∂L​​=​U​2​​⋅IoU​​I⋅(∇​x​​X−∇​x​​I)−U⋅∇​x​​I​​​=​U​​1​​⋅∇​x​​X − ​UI​​U+I​​⋅∇​x​​I​​ 其中， ∇xX\\nabla_xX∇​x​​X 是 预测框面积关于位置的偏导数（Partial Derivative） ， ∇xI\\nabla_xI∇​x​​I 是 交集区域面积关于位置的偏导数 ，有： Iw=min(xl, x~l)+min(xr, x~r)Ih=min(xt, x~t)+min(xb, x~b)∇xX={∂X∂xt(or ∂xb)=xl+xr∂X∂xl(or ∂xr)=xt+xb∇xI={∂I∂xt(or ∂xb)={Iw, if(xtx~t or xbx~b)0,otherwise∂I∂xl(or ∂xr)={Ih, if(xlx~l or xrx~r)0,otherwise {\\displaystyle \\begin{aligned} I_w &= min(x_l,\\ \\tilde{x}_l) + min(x_r,\\ \\tilde{x}_r) \\\\ I_h &= min(x_t,\\ \\tilde{x}_t) + min(x_b,\\ \\tilde{x}_b) \\\\ \\nabla_xX &= { \\begin{cases} \\frac{\\partial X}{\\partial x_t( \\mathbf{or}\\ \\partial x_b)} = x_l + x_r \\\\ \\frac{\\partial X}{\\partial x_l( \\mathbf{or}\\ \\partial x_r)} = x_t + x_b \\end{cases} } \\\\ \\nabla_xI &= { \\begin{cases} \\frac{\\partial I}{\\partial x_t( \\mathbf{or}\\ \\partial x_b)} = { \\begin{cases} I_w &, \\ if ( x_t ​I​w​​​I​h​​​∇​x​​X​∇​x​​I​​​​=min(x​l​​, ​x​~​​​l​​)+min(x​r​​, ​x​~​​​r​​)​=min(x​t​​, ​x​~​​​t​​)+min(x​b​​, ​x​~​​​b​​)​=​⎩​⎪​⎨​⎪​⎧​​​​∂x​t​​(or ∂x​b​​)​​∂X​​=x​l​​+x​r​​​​∂x​l​​(or ∂x​r​​)​​∂X​​=x​t​​+x​b​​​​​=​⎩​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎧​​​​∂x​t​​(or ∂x​b​​)​​∂I​​={​I​w​​​0​​​, if(x​t​​​x​~​​​t​​ or x​b​​​x​~​​​b​​)​,otherwise​​​​∂x​l​​(or ∂x​r​​)​​∂I​​={​I​h​​​0​​​, if(x​l​​​x​~​​​l​​ or x​r​​​x​~​​​r​​)​,otherwise​​​​​​ 带入求得 IoU BackIoU\\ \\mathcal{B}ackIoU Back 值，作用于 优化算法的梯度变换 ，如 自适应动量算法（Adam） 等。来发挥相应作用。 交并比损失函数（IoU Loss）的简单 C++ 语言实现 到这里，我们就可以根据基本情况来做一下交并比的代码实现了。由于需要进行一些基本的矩阵运算，我们选择采用引入 轻量级的 GLM（GL Mathematics） 开源库，来协助完成基本工作。 我们选择 GLM 库的原因，是因为其可以通过纯粹的包含头文件的方式，简便轻巧的启动包含基本图形矩阵数据结构和方法的完整库功能。在其开源协议保证下，非常适合运用于大部分工程项目。如果需要也可以自己分装部分算法和操作。例如在某些场景下，我们需要计算物体体积方块区域，到视窗平面上的投影位置： #include #include \"stdio.h\" #include \"math.h\" typedef glm::vec2 Vector_2f; typedef glm::vec3 Vector_3f; typedef glm::vec4 Vector_4f; typedef glm::mat2 Matrix_2x2f; typedef glm::mat3 Matrix_3x3f; typedef glm::mat4 Matrix_4x4f; #define XC_PI 3.14159265358979323846 #define XC_RADIAN(d_) (XC_PI * d_ / 180.0f) #define XC_VECTOR_NORMALIZE(v_) glm::normalize(v_) #define XC_VECTOR_CROSS(vl_, vr_) glm::cross(vl_, vr_) #define XC_VECTOR_DOT(vl_, vr_) glm::dot(vl_, vr_) #define XC_MATRIX_INVERSE(m_) glm::inverse(m_) #define XC_MATRIX_TRANSPOSE(m_) glm::transpose(m_) #define XC_MATRIX_DOT(ml_, mr_) dot_m4x4(ml_, mr_) #define XC_V4_M44_DOT(vl_, mr_) dot_v4_m4x4(vl_, mr_) Vector_4f dot_v4_m4x4(Vector_4f v4_, Matrix_4x4f m4x4_) { return m4x4_[0] * v4_[0] + m4x4_[1] * v4_[1] + m4x4_[2] * v4_[2] + m4x4_[3] * v4_[3]; } Matrix_4x4f dot_m4x4(Matrix_4x4f ml_, Matrix_4x4f mr_) { Matrix_4x4f result_; result_[0] = mr_[0] * ml_[0][0] + mr_[1] * ml_[0][1] + mr_[2] * ml_[0][2] + mr_[3] * ml_[0][3]; result_[1] = mr_[0] * ml_[1][0] + mr_[1] * ml_[1][1] + mr_[2] * ml_[1][2] + mr_[3] * ml_[1][3]; result_[2] = mr_[0] * ml_[2][0] + mr_[1] * ml_[2][1] + mr_[2] * ml_[2][2] + mr_[3] * ml_[2][3]; result_[3] = mr_[0] * ml_[3][0] + mr_[1] * ml_[3][1] + mr_[2] * ml_[3][2] + mr_[3] * ml_[3][3]; return result_; } 此处我们简单的实现了两个快速算法，用于协助我们完成目标 4×14 \\times 14×1 向量与 4×44 \\times 44×4 矩阵的点乘，和两个 4×44 \\times 44×4 矩阵的点乘。 其实类似的快速算法已在库内有封装，此处仅是用于说明 GLM 的一些基本用法。 不过，对于交并比的代码工程化来说，并不需要这么复杂： #include #include \"stdio.h\" #include \"math.h\" typedef glm::vec2 Vector_2f; typedef glm::vec4 Vector_4f; bool static IoU_simple(Vector_4f anchor_box_, Vector_4f ground_box_, float threshold_ = 0.8f) { float M_area_, T_area_, I_area_, U_area_; float IoU_mark_; { Vector_2f I_lt = { MAX(anchor_box_[0], ground_box_[0]), MAX(anchor_box_[1], ground_box_[1]) }; Vector_2f I_rb = { MIN(anchor_box_[2], ground_box_[2]), MIN(anchor_box_[3], ground_box_[3]) }; if (I_rb.x threshold_); } 上面的简短过程，就是整个交并比的 C++ 语言封装了。可见易于迁移。 IoU 的缺点与 GIoU 的改进 交并比损失函数并非是没有缺陷的。 一个显而易见的问题就是 IoU 无法评估预测框和标注框无交集区域时，预测框的优劣程度（梯度消失）。 这所造成的直接问题就是，当 无交集情况出现 ，我们将无法只通过 IoU 损失函数，来使预测框快速的向标注框方向运动。从而导致数据浪费并产生不准确的结果，且有可能使模型陷入局部解而导致停滞。 2019 年的 CVPR 上，来自斯坦福大学的研究团队以交并比为基础，提出了 IoU 的改进版 通用交并比（GIoU [Generalized Intersection over Union]）算法 [20] 。解决了无交集的判断问题。 GIoU 采用的处理办法为，在原有 IoU 计算的基础上，引入预测框与标注框区域所构成的最小外接矩形，即 两者的最小外接闭包（smallest enclosing convex） 参与损失函数计算，来辅助量化两者之间的远近到权重迭代中， 记为 C=ConvexC = ConvexC=Convex 。 图 3.3.2-2 红框即为 IoU 图例中，I 和 U 的最小外接矩形 改进后的通用交并比公式 同样非常简洁 （注意 并非 GIoU Loss ），可记为： GIoU=IoU−∣C−(A∪B)∣∣C∣=IoU−∣C−U∣∣C∣ {\\displaystyle \\begin{aligned} GIoU &= IoU - \\frac{|C - (A \\cup B)|}{|C|} = IoU - \\frac{|C - U|}{|C|} \\\\ \\end{aligned} } ​GIoU​​​​=IoU−​∣C∣​​∣C−(A∪B)∣​​=IoU−​∣C∣​​∣C−U∣​​​​ 从公式可知，当 预测框与标注框不存在交集时 ， U=∣A∪B∣=0→IoU=0U = |A \\cup B| = 0 \\rightarrow IoU = 0U=∣A∪B∣=0→IoU=0 有： GIoU=IoU−C−0C=−1 {\\displaystyle \\begin{aligned} GIoU &= IoU - \\frac{C-0}{C} = -1 \\\\ \\end{aligned} } ​GIoU​​​​=IoU−​C​​C−0​​=−1​​ 当 预测框与标注框完全重合时 ， I=∣A∩B∣=∣A∪B∣=U→IoU=1I = |A \\cap B| = |A \\cup B| = U \\rightarrow IoU = 1I=∣A∩B∣=∣A∪B∣=U→IoU=1 有： GIoU=IoU−C−UC=IoU−0C=1 {\\displaystyle \\begin{aligned} GIoU &= IoU - \\frac{C-U}{C} = IoU - \\frac{0}{C} = 1 \\\\ \\end{aligned} } ​GIoU​​​​=IoU−​C​​C−U​​=IoU−​C​​0​​=1​​ 基于此，GIoU 的取值范围为 GIoU∈[−1, +1]GIoU \\in [-1, \\ +1]GIoU∈[−1, +1] 。 通用交并比损失函数（GIoU Loss） GIoU 本质是一种对 IoU 算法的 泛化补充 ，所以在损失函数 GIoU LossGIoU \\ \\mathcal{L}ossGIoU Loss 的表达上，直接采用 GIoU 代替 IoU 作为影响因子即可 。有： GIoU Loss=−ln(GIoU)≈1−GIoUGIoU∈[−1, 1] {\\displaystyle \\begin{aligned} GIoU \\ \\mathcal{L}oss & = -ln(GIoU) \\approx 1-GIoU \\quad GIoU \\in [-1, \\ 1] \\\\ \\end{aligned} } ​GIoU Loss​​​​=−ln(GIoU)≈1−GIoUGIoU∈[−1, 1]​​ 同理，记 ∇xX\\nabla_xX∇​x​​X 是预测框面积关于位置的偏导数（Partial Derivative）， ∇xX~\\nabla_x\\tilde{X}∇​x​​​X​~​​ 是标注框面积关于位置的偏导数（Partial Derivative）， ∇xI\\nabla_xI∇​x​​I 是交集区域面积关于位置的偏导数，有： GIoU Back=∂L∂x=∂LIoU∂x+∂LUoC∂x=I⋅(∇xX−∇xI)−U⋅∇xIU2⋅IoU+U⋅(∇xX+∇xX~)−C⋅(∇xX−∇xI)C⋅U=1U⋅∇xX − U+IUI⋅∇xI + 1U⋅∇xI +1C⋅∇xX~ − C−UCU⋅∇xX=1C⋅∇xX − 1I⋅∇xI + 1C⋅∇xX~ {\\displaystyle \\begin{aligned} GIoU\\ \\mathcal{B}ack &= \\frac{\\partial \\mathcal{L}}{\\partial x} = \\frac{\\partial \\mathcal{L}_{IoU}}{\\partial x} + \\frac{\\partial \\mathcal{L}_{UoC}}{\\partial x} \\\\ &= \\frac{I \\cdot (\\nabla_xX - \\nabla_xI) - U \\cdot \\nabla_xI}{U^2 \\cdot IoU} + \\frac{U \\cdot (\\nabla_xX + \\nabla_x\\tilde{X}) - C \\cdot (\\nabla_xX - \\nabla_xI)}{C \\cdot U} \\\\ &= \\tfrac{1}{U} \\cdot \\nabla_xX \\ - \\ \\tfrac{U+I}{UI} \\cdot \\nabla_xI \\ + \\ \\tfrac{1}{U} \\cdot \\nabla_xI \\ + \\tfrac{1}{C} \\cdot \\nabla_x\\tilde{X} \\ - \\ \\tfrac{C-U}{CU} \\cdot \\nabla_xX \\\\ &= \\tfrac{1}{C} \\cdot \\nabla_xX \\ - \\ \\tfrac{1}{I} \\cdot \\nabla_xI \\ + \\ \\tfrac{1}{C} \\cdot \\nabla_x\\tilde{X} \\\\ \\end{aligned} } ​GIoU Back​​​​​​​=​∂x​​∂L​​=​∂x​​∂L​IoU​​​​+​∂x​​∂L​UoC​​​​​=​U​2​​⋅IoU​​I⋅(∇​x​​X−∇​x​​I)−U⋅∇​x​​I​​+​C⋅U​​U⋅(∇​x​​X+∇​x​​​X​~​​)−C⋅(∇​x​​X−∇​x​​I)​​​=​U​​1​​⋅∇​x​​X − ​UI​​U+I​​⋅∇​x​​I + ​U​​1​​⋅∇​x​​I +​C​​1​​⋅∇​x​​​X​~​​ − ​CU​​C−U​​⋅∇​x​​X​=​C​​1​​⋅∇​x​​X − ​I​​1​​⋅∇​x​​I + ​C​​1​​⋅∇​x​​​X​~​​​​ 而 标注框在单次迭代中是常量值 ，即 ∇xX~=0\\nabla_x\\tilde{X} = 0∇​x​​​X​~​​=0 代入： GIoU Back=1C⋅∇xX − 1I⋅∇xI {\\displaystyle \\begin{aligned} GIoU\\ \\mathcal{B}ack &= \\tfrac{1}{C} \\cdot \\nabla_xX \\ - \\ \\tfrac{1}{I} \\cdot \\nabla_xI \\end{aligned} } ​GIoU Back​​​=​C​​1​​⋅∇​x​​X − ​I​​1​​⋅∇​x​​I​​ 显然 GIoU 的反向传播计算相比 IoU 更为快捷有效 。这也是其 通用性 的体现之一。 通用交并比损失函数（GIoU Loss）的简单 C++ 语言实现 万事具备，现在只需要代码实现 GIoU 算法即可，仍然非常便捷。只需在原 IoU 算法上补充改进部分即可： #include #include \"stdio.h\" #include \"math.h\" typedef glm::vec2 Vector_2f; typedef glm::vec4 Vector_4f; bool static GIoU_simple(Vector_4f anchor_box_, Vector_4f ground_box_, float threshold_ = 0.8f) { float M_area_, T_area_, I_area_, U_area_, C_area_; float IoU_mark_, GIoU_mark_; { Vector_2f I_lt = { MAX(anchor_box_[0], ground_box_[0]), MAX(anchor_box_[1], ground_box_[1]) }; Vector_2f I_rb = { MIN(anchor_box_[2], ground_box_[2]), MIN(anchor_box_[3], ground_box_[3]) }; if (I_rb.x threshold_); } 完成 GIoU 算法的程序化封装。 GIoU 的缺点与 IoU 算法族的发展 那么，GIoU 算法是否依旧存在缺陷呢？ 虽然 GIoU 可以适度的缓解无交集情况的梯度消失问题，但 并不能加速当预测框完整包含标注框时的梯度迭代 。此时 GIoU 算法，会因为最小外接矩形等同于并集 的缘故，退化为 IoU 算法。从而无法起到有向加速梯度趋向更贴合标注大小的目的。 图 3.3.2-3 预测框（绿）包含标注框时 GIoU 退化为 IoU 示意图[20] 针对这种情形，后续的一些研究试图通过引入 框中心点（DIoU [Distance-IoU]） [21] ，结合 长宽一致性（CIoU [Complete-IoU]） [21] ，并在中心点基础上 进一步优化损失函数的设计（EIoU [Efficient-IoU]） [22] 来解决此问题。虽然取得了不错的效果，但算法复杂度也有较大变化，考虑到实际工程情况取舍可以酌情选用，本书不再展开讲解。 几种算法的对比结果如下，仅供参考： 图 3.3.2-4 当前主流 IoU 算法族基于 COCO val-2017 数据集的对比结果[22] 进行到这里，在一些耗时训练之后，我们就能够得到一个静态的物体识别算法模型了。 由于静态模型不需要持续迭代，通过直接取模型参数或者接入其他成型的推理引擎，即可完成对指定关注物体的识别操作。 需要注意的是，目前训练所得的 简易模型 ，还不能在 不经过辅助方法 的情况下，自主完成锁定需要检测的物体 。模型只能用于判断某一个给定检测范围（检测框）内的数据，是否属于被用于训练录入的标签物体，并给出命中率。 因此，依旧需要人为提供用于辅助锁定检测目标的方法。 配合检测所得命中率经过阈值筛选最终结果，得到其所处像素位置。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_3_3.html":{"url":"Chapter_3/Language/cn/Docs_3_3_3.html","title":"3.3.3 朴素目标检测物体锁定 - 分步滑动窗口（Simple Sliding Window）","keywords":"","body":"3.3.2 朴素目标检测物体锁定 - 分步滑动窗口（Simple Sliding Window） 分步滑动窗口（Simple Sliding Window） 是一种常用的辅助锁定检测目标的手段。其优势在于，简单易行且精度可控 。 作为一个经典的工具范式，分步滑动窗口被广泛应用于深度学习相关的特征提取、语义分割、物体检测、物体识别等各种场合。前面的章节中使用 HOG 提取特征向量时的卷积核操作，其中卷积核就可以被认为是一个步长等于窗口大小的滑动窗口。本质上，滑动窗口和卷积核只是不同视角下对同种数学工具的不同描述而已。 滑动窗口 实则为一个泛化的概念，而称谓上的差异，主要体现在狭义的分步滑动窗口更注重强调概念上的步长选择。例如中科院就从变步长角度出发，提出了一种基于滑动窗口捕获图像信息的分批量化整合空间结构局部相关性的视觉 Transformer 基础模型 SimViT [23] 。滑动窗口之名，仅用于区分关注点的差异，可见一斑。 图 3.3.3-1 滑动窗口在 SimViT 中的运用[23] 我们日常工程中，在已经有可以被部署的物体检测模型阶段之后，可用滑动窗口锁定随时间轴变化而发生运动的目标。 方法本身有三个关键概念，分别是：窗口大小（Window Size） 、滑动步长（Sliding Step） 、采样层级（Sample Level） 。 窗口大小（Window Size） 即 滑动窗口的空间属性 ，等价于卷积核大小的意义。在二维情况下通常指由 宽（Width）和高（Height）组成的矩形所围成的闭包内区域 ，记为 Size=(W,H)Size = (W,H)Size=(W,H) 。 滑动步长（Sliding Step） 即 滑动窗口的运动属性 ，代表窗口在维度空间内的移动状态。在二维情况下则分为 横向（Horizontal） 和 纵向（Vertical） 两个方向。一般在大多数工程场景下，都会选择 速度为常量取值的匀速步长（Uniform Step） ，且 优先横向扫描（Transverse Scaning） ，记为 Step=(u,v)Step = (u,v)Step=(u,v) 。 采样层级（Sample Level） 即 原数据的缩放（提取）层级 ，如 SimViT 的图例中，就可以被认为在窗口大小恒定情况下，利用 MCSA 注意力激励算法向上采样，构建了双层（2-Level）的变步长滑动窗口单元，记为 Level=(l)Level = (l)Level=(l) ，有： Level=(l)=Subsampling+Upsampling+1 Level = (l) = Subsampling + Upsampling + 1 Level=(l)=Subsampling+Upsampling+1 由于本身是通过设定大小的窗口 滑动筛选过滤 ，因此窗口的大小是否 贴合被检测目标的大小 ，会较大程度上影响最终判定结果。但也需要均衡算力消耗。假设当前用于检测的图像大小为 (Img_W, Img_H)(Img\\_W,\\ Img\\_H)(Img_W, Img_H) ，一套工程上的经验方法计算方式如下： WParams={Size=(W,H)=(⌊Img_W2⌋+1, ⌊Img_H2⌋+1)Step=(u,v)=(Img_Wlv⋅W, Img_Hlv⋅H)Level=(lv),lv∈[1, 3] {\\displaystyle \\begin{aligned} {WParams} = { \\begin{cases} Size &= (W,H) = ( \\lfloor \\tfrac{Img\\_W}{2} \\rfloor + 1,\\ \\lfloor \\tfrac{Img\\_H}{2} \\rfloor + 1) \\\\ Step &= (u,v) = ( \\tfrac{Img\\_W}{lv \\cdot W},\\ \\tfrac{Img\\_H}{lv \\cdot H}) \\\\ Level &= (lv) ,\\quad lv \\in [1,\\ 3 ] \\end{cases} } \\\\ \\end{aligned} } ​WParams=​⎩​⎪​⎨​⎪​⎧​​​Size​Step​Level​​​=(W,H)=(⌊​2​​Img_W​​⌋+1, ⌊​2​​Img_H​​⌋+1)​=(u,v)=(​lv⋅W​​Img_W​​, ​lv⋅H​​Img_H​​)​=(lv),lv∈[1, 3]​​​​​ 代入图像大小获得配置，来快速获取包含完整被检测物体的闭包，方便模型处理得到目标实际区域，并工程缩减模型的输入。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_4.html":{"url":"Chapter_3/Language/cn/Docs_3_4.html","title":"3.4 空域冗余控制 - 基础光流算法与色度压缩","keywords":"","body":"3.4 空域冗余控制 - 基础光流算法与色度压缩 介于上一节分析的时域冗余性质可以得知，时空本身就是紧密相联的。时域冗余的压缩，主要体现于从覆盖整个数据过程的更广视角，来处理宏观上的实际物理物体运动所产生的信息。所以这里的 时域（Time Domain）冗余 ，指的是 广时空域（Full Spatiotemporal Domain）物体冗余（Objects Redundancy） 。而我们 这里所指的空域（Spacial Domain）冗余 ，可以认为是 相较于时域（Time Domain）的整个数据过程的广度，在单一极短（如前后几帧）的范围内，更细节的像素运动情况的处理 ，即 狭时空域（Narrow Spatiotemporal Domain）像素冗余（Pixels Redundancy） 。 依赖新兴的人工智能方面的运用。广时空域冗余的处理当下虽处于起步阶段，但在标准工程层面探索，如新一代的编解码规格（VVC、MPAI 等）制定获得时续具有关联性的运动区域信息中，已有提案。虽然目前还无法确定最终是否会被采用。其所代表的新一代编解码规格对时域冗余的处理思路，仍然可被有效的借鉴于后续标准确立。这也意味着，传统编解码手段的未来发展方向，需要与人工智能领域在更为基础的方面相结合。必然不可避免需要多级模型的联动。 显而易见，为了保证多级模型的效率，大多数诸如 HOG 在内的一二维信号数据的前处理工作，就需要在模型外解决。而以往这些处理，仅被用于在应用层的具体某些功能过程（比如人脸识别、特征点蒙皮等）的数据准备工作，并未触及到编解码工程的核心区域（不过现在已有一些编解码框架，在利用了这些特性来做相关实践了），因此总是以单元化的单个功能的形式出现。在利用模型针对时域（广）压缩的可能性出现后，部分模型处理结果的简单重复判断过程，可以结合空域频域（如光流运动检测、频域动态分析等）的其他手段，转为由量化的传统算法单元达成。届时整体前后向反馈的系统化工作，会需要提升到音视频工程层面来协助解决。直至模型的推理引擎或算法对应算子的工程标准能够一定程度的统一，从而作为基础功能的一部分，下沉至整体编解码器的规格配置。而这将是一个漫长的过程。 所以，当下必不可少的， 会要求音视频工程师对深度学习（DL [Deep Learning]）为代表的机器学习，有一定程度的基础了解和认知。 本书会在第四章节，对这部分的基础知识进行阐述。而现在，让我们回到剩余的域中冗余处理。 空域（指狭时空域，之后若无特别说明则统一按此简化表述） 和频域冗余，在编解码中已有更为成熟的方法论积累。 空域冗余目前的主流处理思路，是在传统块矢量预测、运动补偿的基础上，从更精细的尺度，基于对近似像素前后相邻时间段内的漂移情况分析来进行一定程度的预估。通过块内运动矢量来测算一段时间内，指定空间范围像素亮度值（灰度值）变化。从而使之只需要保存矢量信息，即可适当完成空域信息的还原。 在分块上基于运动矢量推导，而像素则常采用光流法完成。分块处理和规格强相关，我们将在后续编解码规格分析中再行展开。现在让我们只关注细部。 那么什么是 光流（Optical Flow） 和 光流法（Methods of Optical Flow） 呢？ Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/Docs_3_4_1.html":{"url":"Chapter_3/Language/cn/Docs_3_4_1.html","title":"3.4.1 传统光流法（Classic Optical Flow Methods）","keywords":"","body":"3.4.1 传统光流法（Classic Optical Flow Methods） 在 计算机视觉（Computer Vision） 体系中，光流（Optical Flow） 指的是场景内像素点在观察者所观察场景空间视角下的瞬时相对运动速度。 光流法（Methods of Optical Flow） 即是利用场景序列间的像素时域运动与相邻像素相关性变化，构建前后场景间像素对应关系的数学模型，完成像素运动信息推算的方法。 光流是一个基于观察者的相对概念，并不能完全覆盖真实的物体运动情况。在由二维图像按时序组成的视频中，采样自原三维空间的抽象像素，其三维运动矢量会被投影到观察者的视窗平面上，转为运动矢量在视窗平面上的二维投影矢量。因此，为了便于区分，往往将原三维空间三维运动矢量全体组成的矢量空间称为 三维光流场（3D Optical Flow Field） ，简称 光动场（OMF [Optical Momentum Field]） 。而把视窗平面全体投影矢量构成的矢量平面称为 二维光流场（2D Optical Flow Field） ，简称 光流场（OFF [Optical Flow Field]） 。 观察者、光动场、光流场三者的关系如下图所示： 图 3.4.1-1 观察者、光动场、光流场投射变化视图[24] 在使用光流法前，首先需要量化光流的表达。 工程上通常选用生物光学的 梯度光流公式族（Gradient-Based Optical Flow Method） 来作为衡量光流的基本数学描述。因此，梯度光流法也被称为 基本光流法（Baseline Methods of Optical Flow） [25] 。 基本光流公式（Basic Gradient-Based Optical Formula） 基本光流公式（Basic Gradient-Based Optical Formula） 也称为 基本光流约束（Basic Optical Constraint） ，是所有传统梯度光流法的根基，提供了光流与光流场在时序上的基础关系，并构建了通用的基本假设。分别是： 灰度不变假设，即时域稳定，每一个像素点，灰度值不随时间发生改变； 光流场内可导，即空域稳定，每一个像素与其相邻区域，像素的光流场变化是连续的； 这两个假设决定了在此条件下，每个光动场内抽象像素和其投影光流场内像素，在光流运动上的时空稳定性 。 记在 ttt 时刻的某位于 p=(x, y)p = (x,\\ y)p=(x, y) 的像素点，存在平面瞬时速度 v⃗=(u, v)\\vec{v} = (u,\\ v)​v​⃗​​=(u, v) 即光流。取 I(p, t)I(p,\\ t)I(p, t) 代表对应像素点的灰度值，则根据条件，单位时间变化有： I(p, t)=I(p+v⃗, t+1) {\\displaystyle \\begin{aligned} I(p,\\ t) = I(p + \\vec{v},\\ t+1) \\\\ \\end{aligned} } ​I(p, t)=I(p+​v​⃗​​, t+1)​​​ 当 不限制时间流向 ，自 ttt 时刻经历 Δt\\Delta tΔt 到 t1=t+Δtt_1 = t + \\Delta tt​1​​=t+Δt ，存在 I(p, t)=I(p+v⃗, t+Δt)I(p,\\ t) = I(p + \\vec{v},\\ t + \\Delta t) I(p, t)=I(p+​v​⃗​​, t+Δt) 有： {I(x, y, t)=I(x+Δx,y+Δy,t+Δt)v⃗(u, v)=(ΔxΔt, ΔyΔt) {\\displaystyle \\begin{aligned} { \\begin{cases} I(x,\\ y,\\ t) &= I (x + \\Delta x,y + \\Delta y,t + \\Delta t) \\\\ \\vec{v}(u,\\ v) & = (\\tfrac{\\Delta x}{\\Delta t}, \\ \\tfrac{\\Delta y}{\\Delta t}) \\end{cases} } \\\\ \\end{aligned} } ​{​I(x, y, t)​​v​⃗​​(u, v)​​​=I(x+Δx,y+Δy,t+Δt)​=(​Δt​​Δx​​, ​Δt​​Δy​​)​​​​​ 则根据 泰勒级数（Taylor series） 展开，有： I(x+Δx,y+Δy,t+Δt)=I(x, y, t) + ∂I∂x⋅Δx + ∂I∂y⋅Δy + ∂I∂t⋅Δt + ε=I(x, y, t) + ∂I∂x⋅u⋅Δt + ∂I∂y⋅v⋅Δt + ∂I∂t⋅Δt + ε {\\displaystyle \\begin{aligned} I (x + \\Delta x,y + \\Delta y,t + \\Delta t) &= I(x,\\ y,\\ t) \\ +\\ \\tfrac{ \\partial I}{\\partial x} \\cdot \\Delta x \\ +\\ \\tfrac{ \\partial I}{\\partial y} \\cdot \\Delta y \\ +\\ \\tfrac{ \\partial I}{\\partial t} \\cdot \\Delta t \\ +\\ \\varepsilon \\\\ &= I(x,\\ y,\\ t) \\ +\\ \\tfrac{ \\partial I}{\\partial x} \\cdot u \\cdot \\Delta t \\ +\\ \\tfrac{ \\partial I}{\\partial y} \\cdot v \\cdot \\Delta t \\ +\\ \\tfrac{ \\partial I}{\\partial t} \\cdot \\Delta t \\ +\\ \\varepsilon \\\\ \\end{aligned} } ​I(x+Δx,y+Δy,t+Δt)​​​​​=I(x, y, t) + ​∂x​​∂I​​⋅Δx + ​∂y​​∂I​​⋅Δy + ​∂t​​∂I​​⋅Δt + ε​=I(x, y, t) + ​∂x​​∂I​​⋅u⋅Δt + ​∂y​​∂I​​⋅v⋅Δt + ​∂t​​∂I​​⋅Δt + ε​​ 其中 ε\\varepsilonε 为泰勒展式的高阶无穷小项，它代表了影响灰度不变假设中灰度值的实际样本噪音和量化引入误差，纳入负号，显然我们期望： ∂I∂x⋅u⋅Δt + ∂I∂y⋅v⋅Δt + ∂I∂t⋅Δt + ε=0⇒ε=∂I∂x⋅u + ∂I∂y⋅v + ∂I∂t→0 {\\displaystyle \\begin{aligned} \\tfrac{ \\partial I}{\\partial x} \\cdot u \\cdot \\Delta t \\ +\\ &\\tfrac{ \\partial I}{\\partial y} \\cdot v \\cdot \\Delta t \\ +\\ \\tfrac{ \\partial I}{\\partial t} \\cdot \\Delta t \\ +\\ \\varepsilon = 0 \\\\ &\\Rightarrow \\\\ \\varepsilon =\\tfrac{ \\partial I}{\\partial x} \\cdot u \\ &+\\ \\tfrac{ \\partial I}{\\partial y} \\cdot v \\ +\\ \\tfrac{ \\partial I}{\\partial t} \\rightarrow 0 \\\\ \\end{aligned} } ​​∂x​​∂I​​⋅u⋅Δt + ​​ε=​∂x​​∂I​​⋅u ​​​​​∂y​​∂I​​⋅v⋅Δt + ​∂t​​∂I​​⋅Δt + ε=0​⇒​+ ​∂y​​∂I​​⋅v + ​∂t​​∂I​​→0​​ 上式中 ∂I∂x\\tfrac{ \\partial I}{\\partial x}​∂x​​∂I​​ 、 ∂I∂y\\tfrac{ \\partial I}{\\partial y}​∂y​​∂I​​ 、 ∂I∂t\\tfrac{ \\partial I}{\\partial t}​∂t​​∂I​​ 是 I(p, t)=I(x, y, t)I(p,\\ t) = I(x,\\ y,\\ t)I(p, t)=I(x, y, t) 分别在三个参数方向的偏导数，记 ∇xI=∂I∂x\\nabla_xI = \\tfrac{ \\partial I}{\\partial x}∇​x​​I=​∂x​​∂I​​ 、 ∇yI=∂I∂y\\nabla_yI = \\tfrac{ \\partial I}{\\partial y}∇​y​​I=​∂y​​∂I​​ 、 ∇tI=∂I∂t\\nabla_t I = \\tfrac{ \\partial I}{\\partial t}∇​t​​I=​∂t​​∂I​​ 。则原等式就相当于： ε=I′(x, y)⋅v⃗ + ∇tI=∇pI⋅v⃗ + ∇tI→0 {\\displaystyle \\begin{aligned} \\varepsilon = I{'}(x,\\ y) \\cdot \\vec{v} \\ +\\ \\nabla_t I = \\nabla_p I \\cdot \\vec{v} \\ +\\ \\nabla_t I \\rightarrow 0 \\\\ \\end{aligned} } ​ε=I​′​​(x, y)⋅​v​⃗​​ + ∇​t​​I=∇​p​​I⋅​v​⃗​​ + ∇​t​​I→0​​​ 这就是 基本光流公式 了。 可见当 ttt 确定时，想要求得指定像素点 ppp 的光流 v⃗=(u, v)\\vec{v} = (u,\\ v)​v​⃗​​=(u, v) ，单凭基本约束是不够的。因此，必须通过其他的方式引入新的约束条件来进行光流的求解。最容易联想到的，就是通过已有的空域图像信息来进行限制。由此，根据采用空域信息量的方法，传统梯度光流法被分为了 稠密光流法（Dense Optical Flow Methods） 和 稀疏光流法（Sparse Optical Flow Methods） 。 稠密光流法（Dense Optical Flow Methods） ，即 全局光流法（Global Optical Flow Methods） ，指引入的补充约束需要计算场内所有像素点情况。 稀疏光流法（Sparse Optical Flow Methods），指引入的补充约束只需要计算部分像素区域的光流信息，即可达成约束要求的光流法。 经典稠密光流法的代表是 Horn–Schunck 光流算法，经典稀疏光流法的代表是 Lucas-Kanade 光流算法。 Horn–Schunck 梯度光流法（Horn–Schunck Method） 1981 年，麻省理工计算机实验室的 贝尔特霍尔德·霍恩（Berthold K.P. Horn，1943～Present） 和 布莱恩·舒克（Brian G. Schunck） ，在基本光流约束的前提下，提出了单帧光流场内光流全局光滑变化的假设 [26] 。 该假设认为，若光流场内 任意一点的光流 与 临近点的光流 变化都是光滑的，则存在能够 描述全场能量的单帧光流场能量函数 ，使得该时间段的场内能量变化 小值稳定 。即对原光流场内可导假设进行了补充，使其建立了范围覆盖到整个场内像素的宏微观光流变化，与全抽象能量场能量强度间的关系。 这一补充假设也被称为 光流平滑约束（Optical Flow Smoothness Constraint） ，或 Horn–Schunck 约束 。由于需要对整个场内的所有像素点光流进行计算，从而获取能量函数求最小值，方法被归类为稠密光流法。 数学上可以通过对 v⃗\\vec{v}​v​⃗​​ 求 p=(x, y)p = (x,\\ y)p=(x, y) 的二阶偏导数趋向无穷小来逼近无突变情况，构建平滑程度表示，有： {∇p2u=∂2u∂x2 + ∂2u∂y2∇p2v=∂2v∂x2 + ∂2v∂y2∇p2v⃗=∇p2u + ∇p2v→0 {\\displaystyle \\begin{aligned} &{ \\begin{cases} \\nabla^2_p u &= \\tfrac{ \\partial^2 u}{\\partial x^2} \\ +\\ \\tfrac{ \\partial^2 u}{\\partial y^2} \\\\ \\nabla^2_p v &= \\tfrac{ \\partial^2 v}{\\partial x^2} \\ +\\ \\tfrac{ \\partial^2 v}{\\partial y^2} \\end{cases} } \\\\ &\\nabla^2_p \\vec{v} = \\nabla^2_p u \\ +\\ \\nabla^2_p v \\rightarrow 0 \\\\ \\end{aligned} } ​​​​​​{​∇​p​2​​u​∇​p​2​​v​​​=​∂x​2​​​​∂​2​​u​​ + ​∂y​2​​​​∂​2​​u​​​=​∂x​2​​​​∂​2​​v​​ + ​∂y​2​​​​∂​2​​v​​​​​∇​p​2​​​v​⃗​​=∇​p​2​​u + ∇​p​2​​v→0​​ 而 ∇p2u\\nabla^2_p u∇​p​2​​u 、 ∇p2v\\nabla^2_p v∇​p​2​​v 则可以通过 拉普拉斯展式 ，利用周边像素点光流求逼近值的方式获取 [27] 。 图 3.4.1-2 Horn–Schunck 法采用的中心光流平滑度逼近卷积核[27] 有： ∇p2v⃗=∇p2u + ∇p2v=∑xyv⃗xy⋅[112,  16,  11216,−1,  16112,  16,  112]=(u¯ − u)2 + (v¯ − v)2 {\\displaystyle \\begin{aligned} \\nabla^2_p \\vec{v} &= \\nabla^2_p u \\ +\\ \\nabla^2_p v \\\\ &= \\sum_{xy}\\vec{v}_{xy} \\cdot { \\begin{bmatrix} \\tfrac{1}{12} ,& \\quad \\ \\ \\tfrac{1}{6} ,& \\quad \\ \\ \\tfrac{1}{12} \\\\ \\tfrac{1}{6} ,& \\quad -1 ,& \\quad \\ \\ \\tfrac{1}{6} \\\\ \\tfrac{1}{12} ,& \\quad \\ \\ \\tfrac{1}{6} ,& \\quad \\ \\ \\tfrac{1}{12} \\end{bmatrix} } \\\\ &= (\\bar{u} \\ -\\ u)^2 \\ +\\ (\\bar{v} \\ -\\ v)^2 \\end{aligned} } ​∇​p​2​​​v​⃗​​​​​​​=∇​p​2​​u + ∇​p​2​​v​=​xy​∑​​​v​⃗​​​xy​​⋅​⎣​⎡​​​​12​​1​​,​​6​​1​​,​​12​​1​​,​​​  ​6​​1​​,​−1,​  ​6​​1​​,​​​  ​12​​1​​​  ​6​​1​​​  ​12​​1​​​​​⎦​⎤​​​=(​u​¯​​ − u)​2​​ + (​v​¯​​ − v)​2​​​​ 那么，指定 εc2\\varepsilon_c^2ε​c​2​​ 为光流平滑约束的 L2L_2L​2​​ 误差代表值，则： εc2=(u¯ − u)2 + (v¯ − v)2→0 {\\displaystyle \\begin{aligned} \\varepsilon_c^2 = (\\bar{u} \\ -\\ u)^2 \\ +\\ (\\bar{v} \\ -\\ v)^2 \\rightarrow 0 \\\\ \\end{aligned} } ​ε​c​2​​=(​u​¯​​ − u)​2​​ + (​v​¯​​ − v)​2​​→0​​​ 结合基本约束条件，针对像素点 ppp 的光流 v⃗=(u, v)\\vec{v} = (u,\\ v)​v​⃗​​=(u, v) 求解，就有两个约束条件了： {ε=∇pI⋅v⃗ + ∇tI→0εc2=(u¯ − u)2 + (v¯ − v)2→0 {\\displaystyle \\begin{aligned} { \\begin{cases} \\varepsilon = \\nabla_p I \\cdot \\vec{v} \\ +\\ \\nabla_t I \\rightarrow 0 \\\\ \\varepsilon_c^2 = (\\bar{u} \\ -\\ u)^2 \\ +\\ (\\bar{v} \\ -\\ v)^2 \\rightarrow 0 \\end{cases} } \\\\ \\end{aligned} } ​{​ε=∇​p​​I⋅​v​⃗​​ + ∇​t​​I→0​ε​c​2​​=(​u​¯​​ − u)​2​​ + (​v​¯​​ − v)​2​​→0​​​​​ 至此，假设当前时间 ttt 有全光流场能量 EEE ，引入光滑因子 α\\alphaα 构建能量函数。问题随即转换为，求满足约束的 (u, v)(u,\\ v)(u, v) 值，使得 EEE 最小： E=∫∫(ε2 + α2εc2) dxdy=∫∫[∇pI⋅v⃗ + ∇tI + α2∇p2u + α2∇p2v] dxdy→min {\\displaystyle \\begin{aligned} E &= \\int\\int (\\varepsilon^2 \\ +\\ \\alpha^2 \\varepsilon_c^2) \\ dxdy \\\\ &= \\int\\int [\\nabla_p I \\cdot \\vec{v} \\ +\\ \\nabla_t I \\ +\\ \\alpha^2 \\nabla^2_p u \\ +\\ \\alpha^2 \\nabla^2_p v] \\ dxdy \\\\ &\\rightarrow min \\end{aligned} } ​E​​​​​=∫∫(ε​2​​ + α​2​​ε​c​2​​) dxdy​=∫∫[∇​p​​I⋅​v​⃗​​ + ∇​t​​I + α​2​​∇​p​2​​u + α​2​​∇​p​2​​v] dxdy​→min​​ 显然，当 EEE 取得最小时： {∂E∂u=2⋅(∇pI⋅v⃗ + ∇tI)⋅∇xI − 2α2(u¯ − u)=0∂E∂v=2⋅(∇pI⋅v⃗ + ∇tI)⋅∇yI − 2α2(v¯ − v)=0 {\\displaystyle \\begin{aligned} &{ \\begin{cases} \\tfrac{ \\partial E}{\\partial u} = 2 \\cdot (\\nabla_p I \\cdot \\vec{v} \\ +\\ \\nabla_t I) \\cdot \\nabla_xI \\ -\\ 2\\alpha^2 (\\bar{u} \\ -\\ u) = 0\\\\ \\tfrac{ \\partial E}{\\partial v} = 2 \\cdot (\\nabla_p I \\cdot \\vec{v} \\ +\\ \\nabla_t I) \\cdot \\nabla_yI \\ -\\ 2\\alpha^2 (\\bar{v} \\ -\\ v) = 0 \\end{cases} } \\\\ \\end{aligned} } ​​​​​{​​∂u​​∂E​​=2⋅(∇​p​​I⋅​v​⃗​​ + ∇​t​​I)⋅∇​x​​I − 2α​2​​(​u​¯​​ − u)=0​​∂v​​∂E​​=2⋅(∇​p​​I⋅​v​⃗​​ + ∇​t​​I)⋅∇​y​​I − 2α​2​​(​v​¯​​ − v)=0​​​​ 进一步对两侧同求 ppp 的二阶导可化为： {(α2 + ∇xI2 + ∇yI2)⋅(u¯ − u)=∇xI⋅(∇xI⋅u¯ + ∇yI⋅v¯ + ∇tI)(α2 + ∇xI2 + ∇yI2)⋅(v¯ − v)=∇xI⋅(∇xI⋅u¯ + ∇yI⋅v¯ + ∇tI) {\\displaystyle \\begin{aligned} &{ \\begin{cases} (\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2) \\cdot (\\bar{u} \\ -\\ u) = \\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u} \\ +\\ \\nabla_yI \\cdot \\bar{v} \\ +\\ \\nabla_t I) \\\\ (\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2) \\cdot (\\bar{v} \\ -\\ v) = \\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u} \\ +\\ \\nabla_yI \\cdot \\bar{v} \\ +\\ \\nabla_t I) \\end{cases} } \\\\ \\end{aligned} } ​​​​​{​(α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​)⋅(​u​¯​​ − u)=∇​x​​I⋅(∇​x​​I⋅​u​¯​​ + ∇​y​​I⋅​v​¯​​ + ∇​t​​I)​(α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​)⋅(​v​¯​​ − v)=∇​x​​I⋅(∇​x​​I⋅​u​¯​​ + ∇​y​​I⋅​v​¯​​ + ∇​t​​I)​​​​ 即： {(u − u¯)=−∇xI⋅(∇xI⋅u¯ + ∇yI⋅v¯ + ∇tI)α2 + ∇xI2 + ∇yI2(v − v¯)=−∇xI⋅(∇xI⋅u¯ + ∇yI⋅v¯ + ∇tI)α2 + ∇xI2 + ∇yI2 {\\displaystyle \\begin{aligned} &{ \\begin{cases} (u \\ -\\ \\bar{u}) = - \\frac{\\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u} \\ +\\ \\nabla_yI \\cdot \\bar{v} \\ +\\ \\nabla_t I)}{\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2} \\\\ (v \\ -\\ \\bar{v}) = - \\frac{\\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u} \\ +\\ \\nabla_yI \\cdot \\bar{v} \\ +\\ \\nabla_t I)}{\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2} \\end{cases} } \\\\ \\end{aligned} } ​​​​​​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​(u − ​u​¯​​)=−​α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​​​∇​x​​I⋅(∇​x​​I⋅​u​¯​​ + ∇​y​​I⋅​v​¯​​ + ∇​t​​I)​​​(v − ​v​¯​​)=−​α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​​​∇​x​​I⋅(∇​x​​I⋅​u​¯​​ + ∇​y​​I⋅​v​¯​​ + ∇​t​​I)​​​​​​ 但由于启动时 v⃗p=(u, v)\\vec{v}_p = (u,\\ v)​v​⃗​​​p​​=(u, v) 实际是未知的，而 avg(v⃗p)=(u¯, v¯)avg(\\vec{v}_p) = (\\bar{u},\\ \\bar{v})avg(​v​⃗​​​p​​)=(​u​¯​​, ​v​¯​​) 也是未知的。因此，我们需要将计算转换为由前一次结果驱动的向后迭代运算进行。 通过 克拉默法则（Cramer's Rule） 可知，位于第 n+1 次迭代的像素点 p = (x,\\ y) 光流 v⃗n+1\\vec{v}_{n+1}​v​⃗​​​n+1​​ 取值，与第 nnn 次迭代时，对应相同像素点 p=(x, y)p = (x,\\ y)p=(x, y) 所处卷积核的光流均值 avg(v⃗n)=(u¯n, v¯n)avg(\\vec{v}_n) = (\\bar{u}_n,\\ \\bar{v}_n)avg(​v​⃗​​​n​​)=(​u​¯​​​n​​, ​v​¯​​​n​​) 存在关系： {un+1=u¯n−∇xI⋅(∇xI⋅u¯n + ∇yI⋅v¯n + ∇tI)α2 + ∇xI2 + ∇yI2vn+1=v¯n−∇xI⋅(∇xI⋅u¯n + ∇yI⋅v¯n + ∇tI)α2 + ∇xI2 + ∇yI2 {\\displaystyle \\begin{aligned} &{ \\begin{cases} u_{n+1} = \\bar{u}_n - \\frac{\\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u}_n \\ +\\ \\nabla_yI \\cdot \\bar{v}_n \\ +\\ \\nabla_t I)}{\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2} \\\\ v_{n+1} = \\bar{v}_n - \\frac{\\nabla_xI \\cdot (\\nabla_xI \\cdot \\bar{u}_n \\ +\\ \\nabla_yI \\cdot \\bar{v}_n \\ +\\ \\nabla_t I)}{\\alpha^2 \\ +\\ \\nabla_xI^2 \\ +\\ \\nabla_yI^2} \\end{cases} } \\\\ \\end{aligned} } ​​​​​​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​u​n+1​​=​u​¯​​​n​​−​α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​​​∇​x​​I⋅(∇​x​​I⋅​u​¯​​​n​​ + ∇​y​​I⋅​v​¯​​​n​​ + ∇​t​​I)​​​v​n+1​​=​v​¯​​​n​​−​α​2​​ + ∇​x​​I​2​​ + ∇​y​​I​2​​​​∇​x​​I⋅(∇​x​​I⋅​u​¯​​​n​​ + ∇​y​​I⋅​v​¯​​​n​​ + ∇​t​​I)​​​​​​ 上式即是 HS 法的核心光流推到公式 了。 当设置好启动时的 avg(v⃗0)=(u¯0, v¯0)avg(\\vec{v}_0) = (\\bar{u}_0,\\ \\bar{v}_0)avg(​v​⃗​​​0​​)=(​u​¯​​​0​​, ​v​¯​​​0​​) 初始值，就可以迭代获取后续帧内的像素光流场情况了。 一般取启动帧所有像素点 avg(v⃗0)=(0, 0)avg(\\vec{v}_0) = (0,\\ 0)avg(​v​⃗​​​0​​)=(0, 0) 。 可见 Horn–Schunck 算法是需要逐个像素参与核运算，且保存完整前值的历史算法。 Lucas-Kanade 梯度光流法（Lucas-Kanade Method） 1981 年同年，在 HS 法提出的近乎相同时间，当时还在 卡内基梅隆大学（Carnegie-Mellon University） 计算机学院的 布鲁斯·卢卡斯（Bruce D. Lucas） 和 金出武雄（Takeo Kanade，1945～Present） 教授，共同提出了 Lucas-Kanade 光流法，同样试图借此完成对基础光流约束的补充，使得能够预测光流场情况 [26] 。 和 HS 法纯粹对空域的关注不同，LK 法细化基础光流约束中的时空稳定条件 [28] ： 时域上，LK 法提出了 像素微位移假设 。假设认为图像像素位置随时间变化是连续的，进而才能够求的像素光流和时间之间的偏导关系； 空域上，LK 法提出了 空间趋同性假设 。假设认为场景中相同表面的相邻像素点运动模式是趋同的，且由光动场到光流场投影后，其光流情况也是保持了这一性质。 这两个补充条件，让 LK 法定义的整个场景时空，任意一点和其相邻空间都是时空连续的。 这使我们可以将有关全图逐个像素点光流时空关系的推导，通过分割整体图像的像素点集合，转换为不同像素点子集构成的对应分块（卷积核），以核内区域为单元的光流时空关系推导。从点对点，变为了区域对区域。 基于此，在核心位置 c=(x, y)c = (x,\\ y)c=(x, y) 和所处时刻 ttt 已知的情况下，核内区域光流场内所有像素的光流可以被认为是一个相同值 v⃗=(u, v)\\vec{v} = (u,\\ v)​v​⃗​​=(u, v) 。且必然有区域内，基础约束条件 ε=∇cI⋅v⃗ + ∇tI\\varepsilon = \\nabla_c I \\cdot \\vec{v} \\ +\\ \\nabla_t Iε=∇​c​​I⋅​v​⃗​​ + ∇​t​​I 的高阶无穷小 ε=0\\varepsilon = 0ε=0 成立。 记当前图像大小为 W×HW \\times HW×H ，有 n×nn \\times nn×n 大小分块（卷积核），全图光流场面临的计算量会降为对 N=W/n×H/nN = W/n \\times H/nN=W/n×H/n 个窗口核心光流的推算。记 m=n2m = n^2m=n​2​​ ，则存在核内方程组： {∇cI11⋅v⃗ + ∇tI11=0∇cI12⋅v⃗ + ∇tI12=0⋯∇cInn⋅v⃗ + ∇tInn=0⇒{∇xI1⋅u + ∇yI1⋅v = −∇tI1∇xI2⋅u + ∇yI2⋅v = −∇tI2⋯∇xIm⋅u + ∇yIm⋅v = −∇tIm {\\displaystyle \\begin{aligned} &{ \\begin{cases} \\nabla_c I_{11} \\cdot \\vec{v} \\ +\\ \\nabla_t I_{11} = 0 \\\\ \\nabla_c I_{12} \\cdot \\vec{v} \\ +\\ \\nabla_t I_{12} = 0 \\\\ \\cdots \\\\ \\nabla_c I_{nn} \\cdot \\vec{v} \\ +\\ \\nabla_t I_{nn} = 0 \\end{cases} \\quad \\Rightarrow \\quad \\begin{cases} \\nabla_x I_1 \\cdot u \\ +\\ \\nabla_y I_1 \\cdot v \\ =\\ -\\nabla_t I_1 \\\\ \\nabla_x I_2 \\cdot u \\ +\\ \\nabla_y I_2 \\cdot v \\ =\\ -\\nabla_t I_2 \\\\ \\cdots \\\\ \\nabla_x I_m \\cdot u \\ +\\ \\nabla_y I_m \\cdot v \\ =\\ -\\nabla_t I_m \\end{cases} } \\\\ \\end{aligned} } ​​​​​​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​∇​c​​I​11​​⋅​v​⃗​​ + ∇​t​​I​11​​=0​∇​c​​I​12​​⋅​v​⃗​​ + ∇​t​​I​12​​=0​⋯​∇​c​​I​nn​​⋅​v​⃗​​ + ∇​t​​I​nn​​=0​​⇒​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​∇​x​​I​1​​⋅u + ∇​y​​I​1​​⋅v = −∇​t​​I​1​​​∇​x​​I​2​​⋅u + ∇​y​​I​2​​⋅v = −∇​t​​I​2​​​⋯​∇​x​​I​m​​⋅u + ∇​y​​I​m​​⋅v = −∇​t​​I​m​​​​​​ 即： [∑∇xIm, ∑∇yIm][uv]=[∑−∇tIm] {\\displaystyle \\begin{aligned} \\begin{bmatrix} \\sum \\nabla_x I_m , \\ \\sum \\nabla_y I_m \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\begin{bmatrix} \\sum -\\nabla_t I_m \\end{bmatrix} \\\\ \\end{aligned} } ​[​∑∇​x​​I​m​​, ∑∇​y​​I​m​​​​][​u​v​​]=[​∑−∇​t​​I​m​​​​]​​​ 记 Mc=[∑∇xIm, ∑∇yIm]M_c =\\begin{bmatrix} \\sum \\nabla_x I_m , \\ \\sum \\nabla_y I_m \\end{bmatrix}M​c​​=[​∑∇​x​​I​m​​, ∑∇​y​​I​m​​​​] ， Mt=[∑−∇tIm]M_t =\\begin{bmatrix} \\sum -\\nabla_t I_m \\end{bmatrix}M​t​​=[​∑−∇​t​​I​m​​​​] ，则： v⃗=[uv]=(McT⋅Mc)−1⋅McT⋅Mt=[∑(∇xIm)2, ∑∇xIm⋅∇yIm∑∇xIm⋅∇yIm, ∑(∇yIm)2]−1[∑∇xIm⋅∇tIm∑∇xIm⋅∇tIm] {\\displaystyle \\begin{aligned} \\vec{v} &= \\begin{bmatrix} u \\\\ v \\end{bmatrix} = ({M_c}^T \\cdot M_c)^{-1} \\cdot {M_c}^T \\cdot M_t \\\\ &= \\begin{bmatrix} &\\sum (\\nabla_x I_m)^2 &, \\ \\sum \\nabla_x I_m \\cdot \\nabla_y I_m \\\\ &\\sum \\nabla_x I_m \\cdot \\nabla_y I_m &, \\ \\sum (\\nabla_y I_m)^2 \\end{bmatrix}^{-1} \\begin{bmatrix} \\sum \\nabla_x I_m \\cdot \\nabla_t I_m \\\\ \\sum \\nabla_x I_m \\cdot \\nabla_t I_m \\end{bmatrix} \\end{aligned} } ​​v​⃗​​​​​​=[​u​v​​]=(M​c​​​T​​⋅M​c​​)​−1​​⋅M​c​​​T​​⋅M​t​​​=[​​​​​∑(∇​x​​I​m​​)​2​​​∑∇​x​​I​m​​⋅∇​y​​I​m​​​​​, ∑∇​x​​I​m​​⋅∇​y​​I​m​​​, ∑(∇​y​​I​m​​)​2​​​​]​−1​​[​∑∇​x​​I​m​​⋅∇​t​​I​m​​​∑∇​x​​I​m​​⋅∇​t​​I​m​​​​]​​ 上式即是 LK 法的核心光流推到公式 了。 可见 Lucas-Kanade 算法，属于只需要启动（且不用初始化），就能够在分块（卷积核）内自行完成核心光流保存的自适应循环算法。 从物理角度理解，式子中的 ∇xIm\\nabla_x I_m∇​x​​I​m​​ 、 ∇yIm\\nabla_y I_m∇​y​​I​m​​ 、 ∇tIm\\nabla_t I_m∇​t​​I​m​​ ，是分块 mmm 内像素 ppp 的灰度值 III ，对其所处全图像素位置 p=(x, y)p = (x,\\ y)p=(x, y) 和时间参数 ttt 方向的变化趋势，即 灰度加速度 。鉴于完备的灰度数据，加速度可以利用动量算法结合牛顿法等方式逼近，快速的从帧变化中取得。那么对光流 v⃗\\vec{v}​v​⃗​​ 的求解就成为了 简单的数值计算问题 。 对比 HS 稠密光流和 LK 稀疏光流经典算法，显然 LK 在工程场景中更具优势。 同样，以 LK 算法为代表的稀疏光流法，由于其本身占用数据量和算力远远小于稠密光流法的缘故，得到了更为广泛的工程运用。尤其是 LK 算法本身，凭借高可控和简单的特性，被大量使用在如今的编解码器技术上。例如空域冗余压缩所采用的双向光流等算法，就可以被认为是从 LK 算法衍生出的实际运用产物。而稠密光流法，目前还停留在单帧分析等场景，不过考虑到深度学习带来的变革，利用稠密光流的思想来训练光流约束模型，并引入新一代音视频编解码过程，也从另一个角度开始发挥稠密光流法的工程价值。 但不论是哪一种类型的光流法，基于学术需求和面向工程要求的精度还是有极大的差异的。传统音视频工程对于效率要求高，而精度要求相对较低，我们需要 更快速 的处理方式。 Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "},"Chapter_3/Language/cn/References_3.html":{"url":"Chapter_3/Language/cn/References_3.html","title":"【参考文献】","keywords":"","body":"三、【参考文献】 [1] Fourier, J.B. Joseph (1878) [1822], The Analytical Theory of Heat, translated by Alexander Freeman, The University Press (translated from French). [2] Champeney, D.C. (1987), A Handbook of Fourier Theorems, Cambridge University Press. [3] Clozel, Laurent; Delorme, Patrice (1985), \"Sur le théorème de Paley-Wiener invariant pour les groupes de Lie réductifs réels\", Comptes Rendus de l'Académie des Sciences, Série I, 300: 331–333. [4] Rahman, Matiur (2011), Applications of Fourier Transforms to Generalized Functions, WIT Press, ISBN 978-1-84564-564-9. [5] Stein, Elias; Weiss, Guido (1971), Introduction to Fourier Analysis on Euclidean Spaces, Princeton, N.J.: Princeton University Press, ISBN 978-0-691-08078-9. [6] Wolf, Kurt B. (1979), Integral Transforms in Science and Engineering, Springer, doi:10.1007/978-1-4757-0872-1, ISBN 978-1-4757-0874-5. [7] Grafakos, Loukas (2004), Classical and Modern Fourier Analysis, Prentice-Hall, ISBN 978-0-13-035399-3. [8] Gauss, Carl Friedrich (1876). Theoria Interpolationis Methodo Nova Tractata. Band 3. Göttingen: Königliche Gesellschaft der Wissenschaften. pp. 265–327. [9] Heideman, M. T., D. H. Johnson, and C. S. Burrus, \"Gauss and the history of the fast Fourier transform,\" IEEE ASSP Magazine, 1, (4), 14–21 (1984). [10] James W. Cooley, John W. Tukey, (1965). \"An algorithm for the machine calculation of complex Fourier series\". Math. Comput. 19 (90): 297–301. doi:10.2307/2003354. [11] James W. Cooley, Peter A. W. Lewis, and Peter W. Welch, \"Historical notes on the fast Fourier transform,\" Proc. IEEE, vol. 55 (no. 10), p. 1675–1677 (1967). [12] Ghissoni, S. , Costa, E. , Lazzari, C. , Monteiro, J. , & Reis, R. . (2011). Radix-2 Decimation in Time (DIT) FFT implementation based on a Matrix-Multiple Constant multiplication approach. IEEE International Conference on Electronics. IEEE. [13] C. Tomasi and R. Manduchi, \"Bilateral filtering for gray and color images,\" Sixth International Conference on Computer Vision (IEEE Cat. No.98CH36271), Bombay, India, 1998, pp. 839-846, doi: 10.1109/ICCV.1998.710815. [14] R. Haralick and L. Shapiro Computer and Robot Vision, Vol. 1, Addison-Wesley Publishing Company, 1992, pp 346 - 351. [15] Irwin Sobel, 2014, History and Definition of the Sobel Operator [16] William T. Freeman, Michal Roth, \"Orientation Histograms for Hand Gesture Recognition\", Tech. Rep. TR94-03, Mitsubishi Electric Research Laboratories, Cambridge, MA, December 1994. [17] Dalal, N. , and B. Triggs . \"Histograms of Oriented Gradients for Human Detection.\" IEEE Computer Society Conference on Computer Vision & Pattern Recognition IEEE, 2005. [18] J. F. Henriques, R. Caseiro, P. Martins and J. Batista, \"High-Speed Tracking with Kernelized Correlation Filters,\" in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 37, no. 3, pp. 583-596, 1 March 2015, doi: 10.1109/TPAMI.2014.2345390. [19] Yu J, Jiang Y, Wang Z, et al. Unitbox: An advanced object detection network[C]//Proceedings of the 24th ACM international conference on Multimedia. 2016: 516-520. [20] Rezatofighi, Hamid , et al. \"Generalized Intersection Over Union: A Metric and a Loss for Bounding Box Regression.\" 2019 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) IEEE, 2019. [21] Zheng Z, Wang P, Liu W, et al. Distance-IoU loss: Faster and better learning for bounding box regression[C]//Proceedings of the AAAI conference on artificial intelligence. 2020, 34(07): 12993-13000. [22] Zhang Y F, Ren W, Zhang Z, et al. Focal and efficient IOU loss for accurate bounding box regression[J]. Neurocomputing, 2022, 506: 146-157. [23] Li G, Xu D, Cheng X, et al. Simvit: Exploring a simple vision transformer with sliding windows[C]//2022 IEEE International Conference on Multimedia and Expo (ICME). IEEE, 2022: 1-6. [24] Huston SJ, Krapp HG (2008) Visuomotor Transformation in the Fly Gaze Stabilization System. PLoS Biol 6(7): e173. https://doi.org/10.1371/journal.pbio.0060173. [25] Fleet, David J.; Weiss, Yair (2006). \"Optical Flow Estimation\" (PDF). In Paragios, Nikos; Chen, Yunmei; Faugeras, Olivier D. (eds.). Handbook of Mathematical Models in Computer Vision. Springer. pp. 237–257. ISBN 978-0-387-26371-7. [26] Barron, John L.; Fleet, David J. & Beauchemin, Steven (1994). \"Performance of optical flow techniques\" (PDF). International Journal of Computer Vision. 12: 43–77. CiteSeerX 10.1.1.173.481. doi:10.1007/bf01420984. S2CID 1290100. [27] Berthold.K.P. Horn and Brian.G. Schunck, \"Determining optical flow.\" Artificial Intelligence, vol 17, pp 185–203, 1981. [28] Lucas B D and T. Kanade, An iterative image registration technique with an application to stereo vision[C]//Proc. of the 7th International Conference on Artificial Intelligence, pp 121-130, 1981. [29] A. Alshin, E. Alshina and T. Lee, \"Bi-directional optical flow for improving motion compensation,\" 28th Picture Coding Symposium, Nagoya, Japan, 2010, pp. 422-425, doi: 10.1109/PCS.2010.5702525. [30] J. Luo, Y. He and W. Chen, \"Prediction Refinement with Optical Flow for Affine Motion Compensation,\" 2019 IEEE Visual Communications and Image Processing (VCIP), Sydney, NSW, Australia, 2019, pp. 1-4, doi: 10.1109/VCIP47243.2019.8965942. [31] T. Lu et al., \"Luma Mapping with Chroma Scaling in Versatile Video Coding,\" 2020 Data Compression Conference (DCC), Snowbird, UT, USA, 2020, pp. 193-202, doi: 10.1109/DCC47342.2020.00027. [32] M. Koo, M. Salehifar, J. Lim and S. -H. Kim, \"Low Frequency Non-Separable Transform (LFNST),\" 2019 Picture Coding Symposium (PCS), Ningbo, China, 2019, pp. 1-5, doi: 10.1109/PCS48520.2019.8954507. [33] X. Zhao, J. Chen, M. Karczewicz, A. Said and V. Seregin, \"Joint Separable and Non-Separable Transforms for Next-Generation Video Coding,\" in IEEE Transactions on Image Processing, vol. 27, no. 5, pp. 2514-2525, May 2018, doi: 10.1109/TIP.2018.2802202. [34] Salehifar M, Koo M, Lim J, et al. CE 6.2. 6: Reduced Secondary Transform (RST)[J]. Joint Video Experts Team (JVET) of ITU-T SG, 2018, 16: 10-18. [35] Koo M, Salehifar M, Lim J, et al. CE6: reduced secondary transform (RST)(CE6-3.1)[J]. Joint Video Experts Team (JVET) of ITU-T SG, 2019, 16: 19-27. Copyright © Since 2021 李述博 (Arikan.Li) , All Rights Reserved all right reserved，powered by GitbookLast Updated: 2023-12-22 19:52:13 "}}